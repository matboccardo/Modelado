{"ast":null,"code":"/**\n * Created by mauricio on 3/29/15.\n */\n'use strict';\n\nvar d3 = window.d3;\n\nvar evaluate = require('../evaluate');\n\nvar utils = require('../utils');\n\nmodule.exports = function (chart) {\n  var minWidthHeight;\n  var xScale = chart.meta.xScale;\n  var yScale = chart.meta.yScale;\n\n  function clampRange(vLo, vHi, gLo, gHi) {\n    // issue 69\n    // by adding the option `invert` to both the xAxis and the `yAxis`\n    // it might be possible that after the transformation to canvas space\n    // the y limits of the rectangle get inverted i.e. gLo > gHi\n    //\n    // e.g.\n    //\n    //   functionPlot({\n    //     target: '#playground',\n    //     yAxis: { invert: true },\n    //     // ...\n    //   })\n    //\n    if (gLo > gHi) {\n      var t = gLo;\n      gLo = gHi;\n      gHi = t;\n    }\n\n    var hi = Math.min(vHi, gHi);\n    var lo = Math.max(vLo, gLo);\n\n    if (lo > hi) {\n      // no overlap\n      return [-minWidthHeight, 0];\n    }\n\n    return [lo, hi];\n  }\n\n  var line = function (points, closed) {\n    var path = '';\n    var range = yScale.range();\n    var minY = Math.min.apply(Math, range);\n    var maxY = Math.max.apply(Math, range);\n\n    for (var i = 0, length = points.length; i < length; i += 1) {\n      if (points[i]) {\n        var x = points[i][0];\n        var y = points[i][1];\n        var yLo = y.lo;\n        var yHi = y.hi; // if options.closed is set to true then one of the bounds must be zero\n\n        if (closed) {\n          yLo = Math.min(yLo, 0);\n          yHi = Math.max(yHi, 0);\n        } // points.scaledDX is added because of the stroke-width\n\n\n        var moveX = xScale(x.lo) + points.scaledDx / 2;\n        var viewportY = clampRange(minY, maxY, isFinite(yHi) ? yScale(yHi) : -Infinity, isFinite(yLo) ? yScale(yLo) : Infinity);\n        var vLo = viewportY[0];\n        var vHi = viewportY[1];\n        path += ' M ' + moveX + ' ' + vLo;\n        path += ' v ' + Math.max(vHi - vLo, minWidthHeight);\n      }\n    }\n\n    return path;\n  };\n\n  function plotLine(selection) {\n    selection.each(function (d) {\n      var el = plotLine.el = d3.select(this);\n      var index = d.index;\n      var closed = d.closed;\n      var evaluatedData = evaluate(chart, d);\n      var innerSelection = el.selectAll(':scope > path.line').data(evaluatedData); // the min height/width of the rects drawn by the path generator\n\n      minWidthHeight = Math.max(evaluatedData[0].scaledDx, 1);\n      innerSelection.enter().append('path').attr('class', 'line line-' + index).attr('fill', 'none'); // enter + update\n\n      innerSelection.attr('stroke-width', minWidthHeight).attr('stroke', utils.color(d, index)).attr('opacity', closed ? 0.5 : 1).attr('d', function (d) {\n        return line(d, closed);\n      }).attr(d.attr);\n      innerSelection.exit().remove();\n    });\n  }\n\n  return plotLine;\n};","map":null,"metadata":{},"sourceType":"script"}