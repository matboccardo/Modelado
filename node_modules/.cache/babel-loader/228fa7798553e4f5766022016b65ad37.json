{"ast":null,"code":"/*\r\n* Author : Martin Donk\r\n* Website : http://www.nerdamer.com\r\n* Email : martin.r.donk@gmail.com\r\n* License : MIT\r\n* Source : https://github.com/jiggzson/nerdamer\r\n*/\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n}\n\n(function () {\n  \"use strict\";\n  /*shortcuts*/\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      N = core.groups.N,\n      P = core.groups.P,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      keys = core.Utils.keys,\n      variables = core.Utils.variables,\n      round = core.Utils.round,\n      Frac = core.Frac,\n      isInt = core.Utils.isInt,\n      Symbol = core.Symbol,\n      CONST_HASH = core.Settings.CONST_HASH,\n      math = core.Utils.importFunctions(),\n      evaluate = core.Utils.evaluate; //*************** CLASSES ***************//\n\n  /**\r\n  * Converts a symbol into an equivalent polynomial arrays of \r\n  * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n  * Univariate polymials only. \r\n  * @param {Symbol|Number} symbol\r\n  * @param {String} variable The variable name of the polynomial\r\n  * @param {int} order\r\n  */\n\n  function Polynomial(symbol, variable, order) {\n    if (core.Utils.isSymbol(symbol)) {\n      this.parse(symbol);\n      this.variable = this.variable || variable;\n    } else if (!isNaN(symbol)) {\n      order = order || 0;\n      if (variable === undefined) throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n      this.coeffs = [];\n      this.coeffs[order] = symbol;\n      this.fill(symbol);\n    } else if (typeof symbol === 'string') {\n      this.parse(_.parse(symbol));\n    }\n  }\n  /**\r\n   * Creates a Polynomial given an array of coefficients\r\n   * @param {int[]} arr\r\n   * @param {String} variable\r\n   * @returns {Polynomial}\r\n   */\n\n\n  Polynomial.fromArray = function (arr, variable) {\n    if (typeof variable === 'undefined') throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n    var p = new Polynomial();\n    p.coeffs = arr;\n    p.variable = variable;\n    return p;\n  };\n\n  Polynomial.fit = function (c1, c2, n, base, p, variable) {\n    //after having looped through and mod 10 the number to get the matching factor\n    var terms = new Array(p + 1),\n        t = n - c2;\n    terms[0] = c2; //the constants is assumed to be correct\n    //constant for x^p is also assumed know so add\n\n    terms[p] = c1;\n    t -= c1 * Math.pow(base, p); //start fitting\n\n    for (var i = p - 1; i > 0; i--) {\n      var b = Math.pow(base, i),\n          //we want as many wholes as possible\n      q = t / b,\n          sign = Math.sign(q);\n      var c = sign * Math.floor(Math.abs(q));\n      t -= c * b;\n      terms[i] = c;\n    }\n\n    if (t !== 0) return null;\n\n    for (var i = 0; i < terms.length; i++) terms[i] = new Frac(terms[i]);\n\n    return Polynomial.fromArray(terms, variable);\n  };\n\n  Polynomial.prototype = {\n    /**\r\n     * Converts Symbol to Polynomial\r\n     * @param {Symbol} symbol\r\n     * @param {Array} c - a collector array\r\n     * @returns {Polynomial}\r\n     */\n    parse: function (symbol, c) {\n      this.variable = variables(symbol)[0];\n      if (!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\n      c = c || [];\n      if (!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n\n      if (symbol.group === core.groups.N) {\n        c[0] = symbol.multiplier;\n      } else if (symbol.group === core.groups.S) {\n        c[symbol.power.toDecimal()] = symbol.multiplier;\n      } else {\n        for (var x in symbol.symbols) {\n          var sub = symbol.symbols[x],\n              p = sub.power;\n          if (core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n          p = sub.group === N ? 0 : p.toDecimal();\n\n          if (sub.symbols) {\n            this.parse(sub, c);\n          } else {\n            c[p] = sub.multiplier;\n          }\n        }\n      }\n\n      this.coeffs = c;\n      this.fill();\n    },\n\n    /**\r\n    * Fills in the holes in a polynomial with zeroes\r\n    * @param {Number} x - The number to fill the holes with\r\n    */\n    fill: function (x) {\n      x = Number(x) || 0;\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        if (this.coeffs[i] === undefined) {\n          this.coeffs[i] = new Frac(x);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Removes higher order zeros or a specific coefficient\r\n    * @returns {Array}\r\n    */\n    trim: function () {\n      var l = this.coeffs.length;\n\n      while (l--) {\n        var c = this.coeffs[l];\n        var equalsZero = c.equals(0);\n\n        if (c && equalsZero) {\n          if (l === 0) break;\n          this.coeffs.pop();\n        } else break;\n      }\n\n      return this;\n    },\n\n    /*\r\n     * Returns polynomial mod p **currently fails**\r\n     * @param {Number} p\r\n     * @returns {Polynomial}\r\n     */\n    modP: function (p) {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = this.coeffs[i];\n\n        if (c < 0) {\n          //go borrow\n          var b; //a coefficient > 0\n\n          for (var j = i; j < l; j++) {\n            //starting from where we left off\n            if (this.coeffs[j] > 0) {\n              b = this.coeffs[j];\n              break;\n            }\n          }\n\n          if (b) {\n            //if such a coefficient exists\n            for (j; j > i; j--) {\n              //go down the line and adjust using p\n              this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n              this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\n            }\n\n            c = this.coeffs[i]; //reset c\n          }\n        }\n\n        var d = c.mod(p);\n        var w = c.subtract(d).divide(p);\n\n        if (!w.equals(0)) {\n          var up_one = i + 1;\n          var next = this.coeffs[up_one] || new Frac(0);\n          next = next.add(w);\n          this.coeffs[up_one] = new Frac(next);\n          this.coeffs[i] = new Frac(d);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Adds together 2 polynomials\r\n    * @param {Polynomial} poly\r\n    */\n    add: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.add(b);\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Adds together 2 polynomials\r\n    * @param {Polynomial} poly\r\n    */\n    subtract: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.subtract(b);\n      }\n\n      return this;\n    },\n    divide: function (poly) {\n      var variable = this.variable,\n          dividend = core.Utils.arrayClone(this.coeffs),\n          divisor = core.Utils.arrayClone(poly.coeffs),\n          n = dividend.length,\n          mp = divisor.length - 1,\n          quotient = []; //loop through the dividend\n\n      for (var i = 0; i < n; i++) {\n        var p = n - (i + 1); //get the difference of the powers\n\n        var d = p - mp; //get the quotient of the coefficients\n\n        var q = dividend[p].divide(divisor[mp]);\n        if (d < 0) break; //the divisor is not greater than the dividend\n        //place it in the quotient\n\n        quotient[d] = q;\n\n        for (var j = 0; j <= mp; j++) {\n          //reduce the dividend\n          dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));\n        }\n      } //clean up\n\n\n      var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(),\n          //pass in x for safety\n      p2 = Polynomial.fromArray(quotient, variable || 'x');\n      return [p2, p1];\n    },\n    multiply: function (poly) {\n      var l1 = this.coeffs.length,\n          l2 = poly.coeffs.length,\n          c = []; //array to be returned\n\n      for (var i = 0; i < l1; i++) {\n        var x1 = this.coeffs[i];\n\n        for (var j = 0; j < l2; j++) {\n          var k = i + j,\n              //add the powers together\n          x2 = poly.coeffs[j],\n              e = c[k] || new Frac(0); //get the existing term from the new array\n\n          c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n        }\n      }\n\n      this.coeffs = c;\n      return this;\n    },\n\n    /**\r\n     * Checks if a polynomial is zero\r\n     * @returns {Boolean}\r\n     */\n    isZero: function () {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var e = this.coeffs[i];\n        if (!e.equals(0)) return false;\n      }\n\n      return true;\n    },\n\n    /** \r\n     * Substitutes in a number n into the polynomial p(n)\r\n     * @param {Number} n\r\n     * @returns {Frac}\r\n     */\n    sub: function (n) {\n      var sum = new Frac(0),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var t = this.coeffs[i];\n        if (!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n      }\n\n      return sum;\n    },\n\n    /**\r\n     * Returns a clone of the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    clone: function () {\n      var p = new Polynomial();\n      p.coeffs = this.coeffs;\n      p.variable = this.variable;\n      return p;\n    },\n\n    /**\r\n     * Gets the degree of the polynomial\r\n     * @returns {Number}\r\n     */\n    deg: function () {\n      this.trim();\n      return this.coeffs.length - 1;\n    },\n\n    /**\r\n     * Returns a lead coefficient\r\n     * @returns {Frac}\r\n     */\n    lc: function () {\n      return this.coeffs[this.deg()].clone();\n    },\n\n    /**\r\n     * Converts polynomial into a monic polynomial\r\n     * @returns {Polynomial}\r\n     */\n    monic: function () {\n      var lc = this.lc(),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) this.coeffs[i] = this.coeffs[i].divide(lc);\n\n      return this;\n    },\n\n    /**\r\n     * Returns the GCD of two polynomials\r\n     * @param {Polynomial} poly\r\n     * @returns {Polynomial}\r\n     */\n    gcd: function (poly) {\n      //get the maximum power of each\n      var mp1 = this.coeffs.length - 1,\n          mp2 = poly.coeffs.length - 1,\n          T; //swap so we always have the greater power first\n\n      if (mp1 < mp2) {\n        return poly.gcd(this);\n      }\n\n      var a = this;\n\n      while (!poly.isZero()) {\n        var t = poly.clone();\n        a = a.clone();\n        T = a.divide(t);\n        poly = T[1];\n        a = t;\n      }\n\n      var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n\n      if (!gcd.equals(1)) {\n        var l = a.coeffs.length;\n\n        for (var i = 0; i < l; i++) {\n          a.coeffs[i] = a.coeffs[i].divide(gcd);\n        }\n      }\n\n      return a;\n    },\n\n    /**\r\n     * Differentiates the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    diff: function () {\n      var new_array = [],\n          l = this.coeffs.length;\n\n      for (var i = 1; i < l; i++) new_array.push(this.coeffs[i].multiply(new Frac(i)));\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Integrates the polynomial\r\n     * @returns {Polynomial} \r\n     */\n    integrate: function () {\n      var new_array = [0],\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = new Frac(i + 1);\n        new_array[c] = this.coeffs[i].divide(c);\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Returns the Greatest common factor of the polynomial\r\n     * @param {bool} toPolynomial - true if a polynomial is wanted\r\n     * @returns {Frac|Polynomial}\r\n     */\n    gcf: function (toPolynomial) {\n      //get the first nozero coefficient and returns its power\n      var fnz = function (a) {\n        for (var i = 0; i < a.length; i++) if (!a[i].equals(0)) return i;\n      },\n          ca = [];\n\n      for (var i = 0; i < this.coeffs.length; i++) {\n        var c = this.coeffs[i];\n        if (!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n      }\n\n      var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\n\n      if (toPolynomial) {\n        var parr = [];\n        parr[p[1] - 1] = p[0];\n        p = Polynomial.fromArray(parr, this.variable).fill();\n      }\n\n      return p;\n    },\n\n    /**\r\n     * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n     * @param {bool} incl_img - Include imaginary numbers \r\n     */\n    quad: function (incl_img) {\n      var roots = [];\n      if (this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\n      if (this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n      var a = this.coeffs[2] || 0,\n          b = this.coeffs[1] || 0,\n          c = this.coeffs[0];\n      var dsc = b * b - 4 * a * c;\n      if (dsc < 0 && !incl_img) return roots;else {\n        roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\n        roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\n      }\n      return roots;\n    },\n\n    /**\r\n     * Makes polynomial square free\r\n     * @returns {Array}\r\n     */\n    squareFree: function () {\n      var a = this.clone(),\n          i = 1,\n          b = a.clone().diff(),\n          c = a.clone().gcd(b),\n          w = a.divide(c)[0];\n      var output = Polynomial.fromArray([new Frac(1)], a.variable);\n\n      while (!c.equalsNumber(1)) {\n        var y = w.gcd(c);\n        var z = w.divide(y)[0]; //one of the factors may have shown up since it's square but smaller than the \n        //one where finding\n\n        if (!z.equalsNumber(1) && i > 1) {\n          var t = z.clone();\n\n          for (var j = 1; j < i; j++) t.multiply(z.clone());\n\n          z = t;\n        }\n\n        output = output.multiply(z);\n        i++;\n        w = y;\n        c = c.divide(y)[0];\n      }\n\n      return [output, w, i];\n    },\n\n    /**\r\n     * Converts polynomial to Symbol\r\n     * @returns {Symbol}\r\n     */\n    toSymbol: function () {\n      var l = this.coeffs.length,\n          variable = this.variable;\n      if (l === 0) return new core.Symbol(0);\n      var end = l - 1,\n          str = '';\n\n      for (var i = 0; i < l; i++) {\n        //place the plus sign for all but the last one\n        var plus = i === end ? '' : '+',\n            e = this.coeffs[i];\n        if (!e.equals(0)) str += e + '*' + variable + '^' + i + plus;\n      }\n\n      return _.parse(str);\n    },\n\n    /**\r\n     * Checks if polynomial is equal to a number\r\n     * @param {Number} x\r\n     * @returns {Boolean}\r\n     */\n    equalsNumber: function (x) {\n      this.trim();\n      return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n    },\n    toString: function () {\n      return this.toSymbol().toString();\n    }\n  };\n  /**\r\n   * TODO\r\n   * ===================================================================================\r\n   * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n   * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n   * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n   * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n   * ===================================================================================\r\n  * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n  * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n  * so the symbol multiplier carries the coefficients for all contained symbols.\r\n  * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n  * @param {Array} c The coefficient array\r\n  * @param {boolean} with_order \r\n  * @return {Array}\r\n  */\n\n  Symbol.prototype.coeffs = function (c, with_order) {\n    if (with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n    c = c || [];\n    var s = this.clone().distributeMultiplier();\n\n    if (s.isComposite()) {\n      for (var x in s.symbols) {\n        var sub = s.symbols[x];\n\n        if (sub.isComposite()) {\n          sub.clone().distributeMultiplier().coeffs(c, with_order);\n        } else {\n          if (with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;else {\n            c.push(sub.multiplier);\n          }\n        }\n      }\n    } else {\n      if (with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;else {\n        if (s.group === CB && s.isImaginary()) {\n          var m = new Symbol(s.multiplier);\n          s.each(function (x) {\n            //add the imaginary part\n            if (x.isConstant(true) || x.imaginary) m = _.multiply(m, x);\n          });\n          c.push(m);\n        } else c.push(s.multiplier);\n      }\n    } //fill the holes\n\n\n    if (with_order) {\n      for (var i = 0; i < c.length; i++) if (c[i] === undefined) c[i] = new Symbol(0);\n    }\n\n    return c;\n  };\n\n  Symbol.prototype.tBase = function (map) {\n    if (typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n    var terms = [];\n    var symbols = this.collectSymbols(null, null, null, true),\n        l = symbols.length;\n\n    for (var i = 0; i < l; i++) {\n      var symbol = symbols[i],\n          g = symbol.group,\n          nterm = new MVTerm(symbol.multiplier, [], map);\n\n      if (g === CB) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x];\n          nterm.terms[map[x]] = sym.power;\n        }\n      } else {\n        nterm.terms[map[symbol.value]] = symbol.power;\n      }\n\n      terms.push(nterm.fill());\n      nterm.updateCount();\n    }\n\n    return terms;\n  };\n\n  Symbol.prototype.altVar = function (x) {\n    var m = this.multiplier.toString(),\n        p = this.power.toString();\n    return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\n  };\n  /**\r\n   * Checks to see if the symbols contain the same variables\r\n   * @param {Symbol} symbol\r\n   * @returns {Boolean}\r\n   */\n\n\n  Symbol.prototype.sameVars = function (symbol) {\n    if (!(this.symbols || this.group === symbol.group)) return false;\n\n    for (var x in this.symbols) {\n      var a = this.symbols[x],\n          b = symbol.symbols[x];\n      if (!b) return false;\n      if (a.value !== b.value) return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Groups the terms in a symbol with respect to a variable\r\n   * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n   * @returns {Factors}\r\n   */\n\n\n  Symbol.prototype.groupTerms = function (x) {\n    x = String(x);\n    var f, p, egrouped;\n    var grouped = [];\n    this.each(function (e) {\n      if (e.group === PL) {\n        egrouped = e.groupTerms(x);\n\n        for (var i = 0; i < egrouped.length; i++) {\n          var el = egrouped[i];\n          if (el) grouped[i] = el;\n        }\n      } else {\n        f = core.Utils.decompose_fn(e, x, true);\n        p = f.x.value === x ? Number(f.x.power) : 0; //check if there's an existing value\n\n        grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n      }\n    });\n    return grouped;\n  };\n  /**\r\n   * Use this to collect Factors\r\n   * @returns {Symbol[]}\r\n   */\n\n\n  Symbol.prototype.collectFactors = function () {\n    var factors = [];\n    if (this.group === CB) this.each(function (x) {\n      factors.push(x.clone());\n    });else factors.push(this.clone());\n    return factors;\n  };\n  /**\r\n   * A container class for factors\r\n   * @returns {Factors}\r\n   */\n\n\n  function Factors() {\n    this.factors = {};\n    this.length = 0;\n  }\n\n  ;\n\n  Factors.prototype.getNumberSymbolics = function () {\n    var n = 0;\n    this.each(function (x) {\n      if (!x.isConstant(true)) n++;\n    });\n    return n;\n  };\n  /**\r\n   * Adds the factors to the factor object\r\n   * @param {Symbo} s\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.add = function (s) {\n    if (s.equals(0)) return this; //nothing to add\n\n    if (s.group === CB) {\n      var factors = this;\n      if (!s.multiplier.equals(1)) factors.add(new Symbol(s.multiplier));\n      s.each(function (x) {\n        factors.add(x);\n      });\n    } else {\n      if (this.preAdd) //if a preAdd function was defined call it to do prep\n        s = this.preAdd(s);\n      if (this.pFactor) //if the symbol isn't linear add back the power\n        s = _.pow(s, new Symbol(this.pFactor));\n      var is_constant = s.isConstant();\n      if (is_constant && s.equals(1)) return this; //don't add 1\n\n      var v = is_constant ? s.value : s.text();\n      if (v in this.factors) this.factors[v] = _.multiply(this.factors[v], s);else {\n        this.factors[v] = s;\n        this.length++;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Converts the factor object to a Symbol\r\n   * @returns {Symbol}\r\n   */\n\n\n  Factors.prototype.toSymbol = function () {\n    var factored = new Symbol(1);\n\n    for (var x in this.factors) {\n      var f = this.factors[x],\n          g = f.group; //don't wrap group S or FN\n\n      var factor = f.power.equals(1) ? _.symfunction(core.PARENTHESIS, [this.factors[x]]) : this.factors[x];\n      factored = _.multiply(factored, factor);\n    }\n\n    if (factored.fname === '') factored = Symbol.unwrapPARENS(factored);\n    return factored;\n  };\n  /**\r\n   * Merges 2 factor objects into one\r\n   * @param {Factor} o\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.merge = function (o) {\n    for (var x in o) {\n      if (x in this.factors) this.factors[x] = _.multiply(this.factors[x], o[x]);else this.factors[x] = o[x];\n    }\n\n    return this;\n  };\n  /**\r\n   * The iterator for the factor object\r\n   * @param {Function} f - callback\r\n   * @returns {Factor}\r\n   */\n\n\n  Factors.prototype.each = function (f) {\n    for (var x in this.factors) {\n      var factor = this.factors[x];\n      if (factor.fname === core.PARENTHESIS && factor.isLinear()) factor = factor.args[0];\n      f.call(this, factor, x);\n    }\n\n    return this;\n  };\n  /**\r\n   * Return the number of factors contained in the factor object\r\n   * @returns {int}\r\n   */\n\n\n  Factors.prototype.count = function () {\n    return keys(this.factors).length;\n  };\n  /**\r\n   * Cleans up factors from -1\r\n   * @returns {undefined}\r\n   */\n\n\n  Factors.prototype.clean = function () {\n    try {\n      var h = core.Settings.CONST_HASH;\n\n      if (this.factors[h].lessThan(0)) {\n        if (this.factors[h].equals(-1)) delete this.factors[h];else this.factors[h].negate();\n        this.each(function (x) {\n          x.negate();\n        });\n      }\n    } catch (e) {}\n\n    ;\n  };\n\n  Factors.prototype.toString = function () {\n    return this.toSymbol().toString();\n  }; //a wrapper for performing multivariate division\n\n\n  function MVTerm(coeff, terms, map) {\n    this.terms = terms || [];\n    this.coeff = coeff;\n    this.map = map; //careful! all maps are the same object\n\n    this.sum = new core.Frac(0);\n    this.image = undefined;\n  }\n\n  ;\n\n  MVTerm.prototype.updateCount = function () {\n    this.count = this.count || 0;\n\n    for (var i = 0; i < this.terms.length; i++) {\n      if (!this.terms[i].equals(0)) this.count++;\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.getVars = function () {\n    var vars = [];\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var term = this.terms[i],\n          rev_map = this.getRevMap();\n      if (!term.equals(0)) vars.push(this.rev_map[i]);\n    }\n\n    return vars.join(' ');\n  };\n\n  MVTerm.prototype.len = function () {\n    if (typeof this.count === 'undefined') {\n      this.updateCount();\n    }\n\n    return this.count;\n  };\n\n  MVTerm.prototype.toSymbol = function (rev_map) {\n    rev_map = rev_map || this.getRevMap();\n    var symbol = new Symbol(this.coeff);\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var v = rev_map[i],\n          t = this.terms[i];\n      if (t.equals(0) || v === CONST_HASH) continue;\n      var mapped = new Symbol(v);\n      mapped.power = t;\n      symbol = _.multiply(symbol, mapped);\n    }\n\n    return symbol;\n  };\n\n  MVTerm.prototype.getRevMap = function () {\n    if (this.rev_map) return this.rev_map;\n    var o = {};\n\n    for (var x in this.map) o[this.map[x]] = x;\n\n    this.rev_map = o;\n    return o;\n  };\n\n  MVTerm.prototype.generateImage = function () {\n    this.image = this.terms.join(' ');\n    return this;\n  }, MVTerm.prototype.getImg = function () {\n    if (!this.image) this.generateImage();\n    return this.image;\n  }, MVTerm.prototype.fill = function () {\n    var l = this.map.length;\n\n    for (var i = 0; i < l; i++) {\n      if (typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);else {\n        this.sum = this.sum.add(this.terms[i]);\n      }\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.divide = function (mvterm) {\n    var c = this.coeff.divide(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.multiply = function (mvterm) {\n    var c = this.coeff.multiply(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.isZero = function () {\n    return this.coeff.equals(0);\n  };\n\n  MVTerm.prototype.toString = function () {\n    return '{ coeff: ' + this.coeff.toString() + ', terms: [' + this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\n  };\n\n  core.Utils.toMapObj = function (arr) {\n    var c = 0,\n        o = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      var v = arr[i];\n\n      if (typeof o[v] === 'undefined') {\n        o[v] = c;\n        c++;\n      }\n    }\n\n    o.length = c;\n    return o;\n  };\n\n  core.Utils.filledArray = function (v, n, clss) {\n    var a = [];\n\n    while (n--) {\n      a[n] = clss ? new clss(v) : v;\n    }\n\n    return a;\n  };\n\n  core.Utils.arrSum = function (arr) {\n    var sum = 0,\n        l = arr.length;\n\n    for (var i = 0; i < l; i++) sum += arr[i];\n\n    return sum;\n  };\n  /**\r\n   * Determines if 2 arrays have intersecting elements.\r\n   * @param {Array} a\r\n   * @param {Array} b\r\n   * @returns {Boolean} True if a and b have intersecting elements.\r\n   */\n\n\n  core.Utils.haveIntersection = function (a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n\n    return a.some(function (e) {\n      return b.indexOf(e) > -1;\n    });\n  };\n  /**\r\n   * Substitutes out functions as variables so they can be used in regular algorithms\r\n   * @param {Symbol} symbol\r\n   * @param {Object} map\r\n   * @returns {String} The expression string\r\n   */\n\n\n  core.Utils.subFunctions = function (symbol, map) {\n    map = map || {};\n    var subbed = [];\n    symbol.each(function (x) {\n      if (x.group === FN || x.previousGroup === FN) {\n        //we need a new variable name so why not use one of the existing\n        var val = core.Utils.text(x, 'hash'),\n            tvar = map[val];\n\n        if (!tvar) {\n          //generate a unique enough name\n          var t = x.fname + keys(map).length;\n          map[val] = t;\n          subbed.push(x.altVar(t));\n        } else subbed.push(x.altVar(tvar));\n      } else if (x.group === CB || x.group === PL || x.group === CP) {\n        subbed.push(core.Utils.subFunctions(x, map));\n      } else subbed.push(x.text());\n    });\n    if (symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\n    ;\n    if (symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n    return symbol.text();\n  };\n\n  core.Utils.getFunctionsSubs = function (map) {\n    var subs = {}; //prepare substitutions\n\n    for (var x in map) subs[map[x]] = _.parse(x);\n\n    return subs;\n  };\n\n  var __ = core.Algebra = {\n    version: '1.4.5',\n    init: function () {}(),\n    proots: function (symbol, decp) {\n      //the roots will be rounded up to 7 decimal places.\n      //if this causes trouble you can explicitly pass in a different number of places\n      //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n      decp = decp || 7;\n      var zeros = 0;\n      var known_roots = [];\n\n      var get_roots = function (rarr, powers, max) {\n        var roots = calcroots(rarr, powers, max).concat(known_roots);\n\n        for (var i = 0; i < zeros; i++) roots.unshift(0);\n\n        return roots;\n      };\n\n      if (symbol instanceof Symbol && symbol.isPoly()) {\n        symbol.distributeMultiplier(); //make it so the symbol has a constants as the lowest term\n\n        if (symbol.group === PL) {\n          var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n          var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n          symbol = _.expand(_.divide(symbol, lowest_symbol));\n          known_roots.push(0); //add zero since this is a known root\n        }\n\n        if (symbol.group === core.groups.S) {\n          return [0];\n        } else if (symbol.group === core.groups.PL) {\n          var powers = keys(symbol.symbols),\n              minpower = core.Utils.arrayMin(powers),\n              symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\n        }\n\n        var variable = keys(symbol.symbols).sort().pop(),\n            sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\n            g = sym.group,\n            powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n            rarr = [],\n            max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n        // Prepare the data\n\n        for (var i = 1; i <= max; i++) {\n          var c = 0; //if there is no power then the hole must be filled with a zero\n\n          if (powers.indexOf(i + '') !== -1) {\n            if (g === S) {\n              c = sym.multiplier;\n            } else {\n              c = sym.symbols[i].multiplier;\n            }\n          } // Insert the coeffient but from the front\n\n\n          rarr.unshift(c);\n        }\n\n        rarr.push(symbol.symbols[CONST_HASH].multiplier);\n        if (sym.group === S) rarr[0] = sym.multiplier; //the symbol maybe of group CP with one variable\n\n        return get_roots(rarr, powers, max);\n      } else if (core.Utils.isArray(symbol)) {\n        var parr = symbol;\n        var rarr = [],\n            powers = [],\n            last_power = 0;\n\n        for (var i = 0; i < parr.length; i++) {\n          var coeff = parr[i][0],\n              pow = parr[i][1],\n              d = pow - last_power - 1; //insert the zeros\n\n          for (var j = 0; j < d; j++) rarr.unshift(0);\n\n          rarr.unshift(coeff);\n          if (pow !== 0) powers.push(pow);\n          last_power = pow;\n        }\n\n        var max = Math.max.apply(undefined, powers);\n        return get_roots(rarr, powers, max);\n      } else {\n        throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n      }\n\n      function calcroots(rarr, powers, max) {\n        var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n        // Make a clone of the coefficients before appending the max power\n\n        var p = rarr.slice(0); // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n\n        rarr.unshift(max);\n\n        if (max > MAXDEGREE) {\n          throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n        }\n\n        var zeroi = [],\n            // Vector of imaginary components of roots\n        degreePar = {}; // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n\n        degreePar.Degree = max;\n\n        for (i = 0; i < max; i++) {\n          zeroi.push(0);\n        }\n\n        var zeror = zeroi.slice(0); // Vector of real components of roots\n        // Find the roots\n        //--> Begin Jenkins-Traub\n\n        /*\r\n         * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n        */\n\n        function QuadSD_ak1(NN, u, v, p, q, iPar) {\n          // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n          // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n          q[0] = iPar.b = p[0];\n          q[1] = iPar.a = -(u * iPar.b) + p[1];\n\n          for (var i = 2; i < NN; i++) {\n            q[i] = -(u * iPar.a + v * iPar.b) + p[i];\n            iPar.b = iPar.a;\n            iPar.a = q[i];\n          }\n\n          return;\n        }\n\n        function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\n          // This routine calculates scalar quantities used to compute the next K polynomial and\n          // new estimates of the quadratic coefficients.\n          // calcSC -\tinteger variable set here indicating how the calculations are normalized\n          // to avoid overflow.\n          // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n          // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n          var sdPar = new Object(),\n              // TYPE = 3 indicates the quadratic is almost a factor of K\n          dumFlag = 3; // Synthetic division of K by the quadratic 1, u, v\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(N, u, v, K, qk, sdPar);\n          iPar.c = sdPar.a;\n          iPar.d = sdPar.b;\n\n          if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {\n            if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;\n          }\n\n          iPar.h = v * b;\n\n          if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {\n            // TYPE = 2 indicates that all formulas are divided by d\n            dumFlag = 2;\n            iPar.e = a / iPar.d;\n            iPar.f = iPar.c / iPar.d;\n            iPar.g = u * b;\n            iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);\n            iPar.a1 = -a + iPar.f * b;\n            iPar.a7 = iPar.h + (iPar.f + u) * a;\n          } else {\n            // TYPE = 1 indicates that all formulas are divided by c;\n            dumFlag = 1;\n            iPar.e = a / iPar.c;\n            iPar.f = iPar.d / iPar.c;\n            iPar.g = iPar.e * u;\n            iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;\n            iPar.a1 = -(a * (iPar.d / iPar.c)) + b;\n            iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;\n          }\n\n          return dumFlag;\n        }\n\n        function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\n          // Computes the next K polynomials using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n          var temp;\n\n          if (tFlag == 3) {\n            // Use unscaled form of the recurrence\n            K[1] = K[0] = 0.0;\n\n            for (var i = 2; i < N; i++) {\n              K[i] = qk[i - 2];\n            }\n\n            return;\n          }\n\n          temp = tFlag == 1 ? b : a;\n\n          if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {\n            // Use scaled form of the recurrence\n            iPar.a7 /= iPar.a1;\n            iPar.a3 /= iPar.a1;\n            K[0] = qp[0];\n            K[1] = -(qp[0] * iPar.a7) + qp[1];\n\n            for (var i = 2; i < N; i++) K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\n          } else {\n            // If a1 is nearly zero, then use a special form of the recurrence\n            K[0] = 0.0;\n            K[1] = -(qp[0] * iPar.a7);\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\n            }\n          }\n\n          return;\n        }\n\n        function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\n          // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n          // iPar.a = uu, iPar.b = vv\n          var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n          iPar.b = iPar.a = 0.0; // The quadratic is zeroed\n\n          if (tFlag != 3) {\n            if (tFlag != 2) {\n              a4 = a + u * b + h * f;\n              a5 = c + (u + v * f) * d;\n            } else {\n              a4 = (a + g) * f + h;\n              a5 = (f + u) * c + v * d;\n            } // Evaluate new quadratic coefficients\n\n\n            b1 = -(K[N - 1] / p[N]);\n            b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\n            c1 = v * b2 * a1;\n            c2 = b1 * a7;\n            c3 = b1 * b1 * a3;\n            c4 = -(c2 + c3) + c1;\n            temp = -c4 + a5 + b1 * a4;\n\n            if (temp != 0.0) {\n              iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\n              iPar.b = v * (1.0 + c4 / temp);\n            }\n          }\n\n          return;\n        }\n\n        function Quad_ak1(a, b1, c, iPar) {\n          // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n          // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n          // zeros are real and both zeros are complex. The smaller real zero is found directly from\n          // the product of the zeros c/a.\n          // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n          var b, d, e;\n          iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n\n          if (a == 0) {\n            iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;\n            return;\n          }\n\n          if (c == 0) {\n            iPar.lr = -(b1 / a);\n            return;\n          } // Compute discriminant avoiding overflow\n\n\n          b = b1 / 2.0;\n\n          if (Math.abs(b) < Math.abs(c)) {\n            e = c >= 0 ? a : -a;\n            e = -e + b * (b / Math.abs(c));\n            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\n          } else {\n            e = -(a / b * (c / b)) + 1.0;\n            d = Math.sqrt(Math.abs(e)) * Math.abs(b);\n          }\n\n          if (e >= 0) {\n            // Real zeros\n            d = b >= 0 ? -d : d;\n            iPar.lr = (-b + d) / a;\n            iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;\n          } else {\n            // Complex conjugate zeros\n            iPar.lr = iPar.sr = -(b / a);\n            iPar.si = Math.abs(d / a);\n            iPar.li = -iPar.si;\n          }\n\n          return;\n        }\n\n        function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\n          // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n          // zeros are equimodular or nearly so.\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n          // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n          // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n          var qPar = new Object(),\n              ee,\n              mp,\n              omp,\n              relstp,\n              t,\n              u,\n              ui,\n              v,\n              vi,\n              zm,\n              i,\n              j = 0,\n              tFlag,\n              triedFlag = 0; // Integer variables\n\n          iPar.NZ = 0; // Number of zeros found\n\n          u = uu; // uu and vv are coefficients of the starting quadratic\n\n          v = vv;\n\n          do {\n            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n            Quad_ak1(1.0, u, v, qPar);\n            iPar.szr = qPar.sr;\n            iPar.szi = qPar.si;\n            iPar.lzr = qPar.lr;\n            iPar.lzi = qPar.li; // Return if roots of the quadratic are real and not close to multiple or nearly\n            // equal and of opposite sign.\n\n            if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break; // Evaluate polynomial by quadratic synthetic division\n\n            QuadSD_ak1(NN, u, v, p, qp, sdPar);\n            mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b); // Compute a rigorous bound on the rounding error in evaluating p\n\n            zm = Math.sqrt(Math.abs(v));\n            ee = 2.0 * Math.abs(qp[0]);\n            t = -(iPar.szr * sdPar.b);\n\n            for (i = 1; i < N; i++) {\n              ee = ee * zm + Math.abs(qp[i]);\n            }\n\n            ee = ee * zm + Math.abs(t + sdPar.a);\n            ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON; // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n\n            if (mp <= 20.0 * ee) {\n              iPar.NZ = 2;\n              break;\n            }\n\n            j++; // Stop iteration after 20 steps\n\n            if (j > 20) break;\n\n            if (j >= 2) {\n              if (relstp <= 0.01 && mp >= omp && !triedFlag) {\n                // A cluster appears to be stalling the convergence. Five fixed shift\n                // steps are taken with a u, v close to the cluster.\n                relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);\n                u -= u * relstp;\n                v += v * relstp;\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n\n                for (i = 0; i < 5; i++) {\n                  tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                  nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                }\n\n                triedFlag = 1;\n                j = 0;\n              }\n            }\n\n            omp = mp; // Calculate next K polynomial and new u and v\n\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vi = sdPar.b; // If vi is zero, the iteration is not converging\n\n            if (vi != 0) {\n              relstp = Math.abs((-v + vi) / vi);\n              u = ui;\n              v = vi;\n            }\n          } while (vi != 0);\n\n          return;\n        }\n\n        function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\n          // Variable-shift H-polynomial iteration for a real zero\n          // sss\t- starting iterate = sdPar.a\n          // NZ\t\t- number of zeros found = iPar.NZ\n          // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n          var ee,\n              kv,\n              mp,\n              ms,\n              omp,\n              pv,\n              s,\n              t,\n              dumFlag,\n              i,\n              j,\n              nm1 = N - 1; // Integer variables\n\n          iPar.NZ = j = dumFlag = 0;\n          s = sdPar.a;\n\n          for (;;) {\n            pv = p[0]; // Evaluate p at s\n\n            qp[0] = pv;\n\n            for (i = 1; i < NN; i++) {\n              qp[i] = pv = pv * s + p[i];\n            }\n\n            mp = Math.abs(pv); // Compute a rigorous bound on the error in evaluating p\n\n            ms = Math.abs(s);\n            ee = 0.5 * Math.abs(qp[0]);\n\n            for (i = 1; i < NN; i++) {\n              ee = ee * ms + Math.abs(qp[i]);\n            } // Iteration has converged sufficiently if the polynomial value is less than\n            // 20 times this bound\n\n\n            if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\n              iPar.NZ = 1;\n              iPar.szr = s;\n              iPar.szi = 0.0;\n              break;\n            }\n\n            j++; // Stop iteration after 10 steps\n\n            if (j > 10) break;\n\n            if (j >= 2) {\n              if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {\n                // A cluster of zeros near the real axis has been encountered.\n                // Return with iFlag set to initiate a quadratic iteration.\n                dumFlag = 1;\n                iPar.a = s;\n                break;\n              } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n\n            } //End if (j >= 2)\n            // Return if the polynomial value has increased significantly\n\n\n            omp = mp; // Compute t, the next polynomial and the new iterate\n\n            qk[0] = kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              qk[i] = kv = kv * s + K[i];\n            }\n\n            if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\n              // Use the scaled form of the recurrence if the value of K at s is non-zero\n              t = -(pv / kv);\n              K[0] = qp[0];\n\n              for (i = 1; i < N; i++) {\n                K[i] = t * qk[i - 1] + qp[i];\n              }\n            } else {\n              // Use unscaled form\n              K[0] = 0.0;\n\n              for (i = 1; i < N; i++) K[i] = qk[i - 1];\n            }\n\n            kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              kv = kv * s + K[i];\n            }\n\n            t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;\n            s += t;\n          }\n\n          return dumFlag;\n        }\n\n        function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\n          // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n          // quadratic case. Initiates one of the variable shift iterations and returns with the\n          // number of zeros found.\n          // L2\tlimit of fixed shift steps\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // NZ\tnumber of zeros found\n          var sdPar = new Object(),\n              // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n          calcPar = new Object(),\n              // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n          qk = new Array(MDP1),\n              svk = new Array(MDP1),\n              a,\n              b,\n              betas,\n              betav,\n              oss,\n              ots,\n              otv,\n              ovv,\n              s,\n              ss,\n              ts,\n              tss,\n              tv,\n              tvv,\n              ui,\n              vi,\n              vv,\n              fflag,\n              i,\n              iFlag = 1,\n              j,\n              spass,\n              stry,\n              tFlag,\n              vpass,\n              vtry; // Integer variables\n\n          iPar.NZ = 0;\n          betav = betas = 0.25;\n          oss = sr;\n          ovv = v; //Evaluate polynomial by synthetic division\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(NN, u, v, p, qp, sdPar);\n          a = sdPar.a;\n          b = sdPar.b;\n          calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n          for (j = 0; j < L2; j++) {\n            fflag = 1; // Calculate next K polynomial and estimate v\n\n            nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk); // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n            // sdPar.a = ui, sdPar.b = vi\n\n            newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vv = vi = sdPar.b; // Estimate s\n\n            ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;\n            ts = tv = 1.0;\n\n            if (j != 0 && tFlag != 3) {\n              // Compute relative measures of convergence of s and v sequences\n              tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;\n              ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts; // If decreasing, multiply the two most recent convergence measures\n\n              tvv = tv < otv ? tv * otv : 1.0;\n              tss = ts < ots ? ts * ots : 1.0; // Compare with convergence criteria\n\n              vpass = tvv < betav ? 1 : 0;\n              spass = tss < betas ? 1 : 0;\n\n              if (spass || vpass) {\n                // At least one sequence has passed the convergence test.\n                // Store variables before iterating\n                for (i = 0; i < N; i++) {\n                  svk[i] = K[i];\n                }\n\n                s = ss; // Choose iteration according to the fastest converging sequence\n\n                stry = vtry = 0;\n\n                for (;;) {\n                  if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {\n                    ; // Do nothing. Provides a quick \"short circuit\".\n                  } else {\n                    QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                    a = sdPar.a;\n                    b = sdPar.b;\n                    if (iPar.NZ > 0) return; // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    iFlag = vtry = 1;\n                    betav *= 0.25; // Try linear iteration if it has not been tried and the s sequence is converging\n\n                    if (stry || !spass) {\n                      iFlag = 0;\n                    } else {\n                      for (i = 0; i < N; i++) K[i] = svk[i];\n                    }\n                  } //fflag = 0;\n\n\n                  if (iFlag != 0) {\n                    // Use sdPar for passing in s instead of defining a brand-new variable.\n                    // sdPar.a = s\n                    sdPar.a = s;\n                    iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                    s = sdPar.a;\n                    if (iPar.NZ > 0) return; // Linear iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    stry = 1;\n                    betas *= 0.25;\n\n                    if (iFlag != 0) {\n                      // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                      ui = -(s + s);\n                      vi = s * s;\n                      continue;\n                    }\n                  } // Restore variables\n\n\n                  for (i = 0; i < N; i++) K[i] = svk[i]; // Try quadratic iteration if it has not been tried and the v sequence is converging\n\n\n                  if (!vpass || vtry) break; // Break out of infinite for loop\n                } // Re-compute qp and scalar values to continue the second stage\n\n\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                a = sdPar.a;\n                b = sdPar.b;\n                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n              }\n            }\n\n            ovv = vv;\n            oss = ss;\n            otv = tv;\n            ots = ts;\n          }\n\n          return;\n        }\n\n        function rpSolve(degPar, p, zeror, zeroi) {\n          var N = degPar.Degree,\n              RADFAC = 3.14159265358979323846 / 180,\n              // Degrees-to-radians conversion factor = PI/180\n          LB2 = Math.LN2,\n              // Dummy variable to avoid re-calculating this value in loop below\n          MDP1 = degPar.Degree + 1,\n              K = new Array(MDP1),\n              pt = new Array(MDP1),\n              qp = new Array(MDP1),\n              temp = new Array(MDP1),\n              // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n          qPar = new Object(),\n              // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n          Fxshfr_Par = new Object(),\n              bnd,\n              DBL_EPSILON,\n              df,\n              dx,\n              factor,\n              ff,\n              moduli_max,\n              moduli_min,\n              sc,\n              x,\n              xm,\n              aa,\n              bb,\n              cc,\n              sr,\n              t,\n              u,\n              xxx,\n              j,\n              jj,\n              l,\n              NM1,\n              NN,\n              zerok; // Integer variables\n          // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n          // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n\n          aa = 1.0;\n\n          do {\n            DBL_EPSILON = aa;\n            aa /= 2;\n            bb = 1.0 + aa;\n          } while (bb > 1.0);\n\n          var LO = Number.MIN_VALUE / DBL_EPSILON,\n              cosr = Math.cos(94.0 * RADFAC),\n              // = -0.069756474\n          sinr = Math.sin(94.0 * RADFAC),\n              // = 0.99756405\n          xx = Math.sqrt(0.5),\n              // = 0.70710678\n          yy = -xx;\n          Fxshfr_Par.NZ = j = 0;\n          Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0; // Remove zeros at the origin, if any\n\n          while (p[N] == 0) {\n            zeror[j] = zeroi[j] = 0;\n            N--;\n            j++;\n          }\n\n          NN = N + 1; // >>>>> Begin Main Loop <<<<<\n\n          while (N >= 1) {\n            // Main loop\n            // Start the algorithm for one zero\n            if (N <= 2) {\n              // Calculate the final zero or pair of zeros\n              if (N < 2) {\n                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\n                zeroi[degPar.Degree - 1] = 0;\n              } else {\n                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n                Quad_ak1(p[0], p[1], p[2], qPar);\n                zeror[degPar.Degree - 2] = qPar.sr;\n                zeroi[degPar.Degree - 2] = qPar.si;\n                zeror[degPar.Degree - 1] = qPar.lr;\n                zeroi[degPar.Degree - 1] = qPar.li;\n              }\n\n              break;\n            } // Find the largest and smallest moduli of the coefficients\n\n\n            moduli_max = 0.0;\n            moduli_min = Number.MAX_VALUE;\n\n            for (i = 0; i < NN; i++) {\n              x = Math.abs(p[i]);\n              if (x > moduli_max) moduli_max = x;\n              if (x != 0 && x < moduli_min) moduli_min = x;\n            } // Scale if there are large or very small coefficients\n            // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n            // is done to avoid overflow and to avoid undetected underflow interfering with the\n            // convergence criterion.\n            // The factor is a power of the base.\n\n\n            sc = LO / moduli_min;\n\n            if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && Number.MAX_VALUE / sc >= moduli_max) {\n              sc = sc == 0 ? Number.MIN_VALUE : sc;\n              l = Math.floor(Math.log(sc) / LB2 + 0.5);\n              factor = Math.pow(2.0, l);\n\n              if (factor != 1.0) {\n                for (i = 0; i < NN; i++) p[i] *= factor;\n              }\n            } // Compute lower bound on moduli of zeros\n\n\n            for (var i = 0; i < NN; i++) pt[i] = Math.abs(p[i]);\n\n            pt[N] = -pt[N];\n            NM1 = N - 1; // Compute upper estimate of bound\n\n            x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\n\n            if (pt[NM1] != 0) {\n              // If Newton step at the origin is better, use it\n              xm = -pt[N] / pt[NM1];\n              x = xm < x ? xm : x;\n            } // Chop the interval (0, x) until ff <= 0\n\n\n            xm = x;\n\n            do {\n              x = xm;\n              xm = 0.1 * x;\n              ff = pt[0];\n\n              for (var i = 1; i < NN; i++) {\n                ff = ff * xm + pt[i];\n              }\n            } while (ff > 0); // End do-while loop\n\n\n            dx = x; // Do Newton iteration until x converges to two decimal places\n\n            do {\n              df = ff = pt[0];\n\n              for (var i = 1; i < N; i++) {\n                ff = x * ff + pt[i];\n                df = x * df + ff;\n              } // End for i\n\n\n              ff = x * ff + pt[N];\n              dx = ff / df;\n              x -= dx;\n            } while (Math.abs(dx / x) > 0.005); // End do-while loop\n\n\n            bnd = x; // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n\n            for (var i = 1; i < N; i++) K[i] = (N - i) * p[i] / N;\n\n            K[0] = p[0];\n            aa = p[N];\n            bb = p[NM1];\n            zerok = K[NM1] == 0 ? 1 : 0;\n\n            for (jj = 0; jj < 5; jj++) {\n              cc = K[NM1];\n\n              if (zerok) {\n                // Use unscaled form of recurrence\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = K[j - 1];\n                } // End for i\n\n\n                K[0] = 0;\n                zerok = K[NM1] == 0 ? 1 : 0;\n              } else {\n                // Used scaled form of recurrence if value of K at 0 is nonzero\n                t = -aa / cc;\n\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = t * K[j - 1] + p[j];\n                } // End for i\n\n\n                K[0] = p[0];\n                zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;\n              }\n            } // Save K for restarts with new shifts\n\n\n            for (var i = 0; i < N; i++) temp[i] = K[i]; // Loop to select the quadratic corresponding to each new shift\n\n\n            for (jj = 1; jj <= 20; jj++) {\n              // Quadratic corresponds to a double shift to a non-real point and its\n              // complex conjugate. The point has modulus BND and amplitude rotated\n              // by 94 degrees from the previous shift.\n              xxx = -(sinr * yy) + cosr * xx;\n              yy = sinr * xx + cosr * yy;\n              xx = xxx;\n              sr = bnd * xx;\n              u = -(2.0 * sr); // Second stage calculation, fixed quadratic\n\n              Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n\n              if (Fxshfr_Par.NZ != 0) {\n                // The second stage jumps directly to one of the third stage iterations and\n                // returns here if successful. Deflate the polynomial, store the zero or\n                // zeros, and return to the main algorithm.\n                j = degPar.Degree - N;\n                zeror[j] = Fxshfr_Par.szr;\n                zeroi[j] = Fxshfr_Par.szi;\n                NN = NN - Fxshfr_Par.NZ;\n                N = NN - 1;\n\n                for (var i = 0; i < NN; i++) p[i] = qp[i];\n\n                if (Fxshfr_Par.NZ != 1) {\n                  zeror[j + 1] = Fxshfr_Par.lzr;\n                  zeroi[j + 1] = Fxshfr_Par.lzi;\n                }\n\n                break;\n              } else {\n                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                for (var i = 0; i < N; i++) {\n                  K[i] = temp[i];\n                }\n              }\n            } // Return with failure if no convergence with 20 shifts\n\n\n            if (jj > 20) {\n              degPar.Degree -= N;\n              break;\n            }\n          } // >>>>> End Main Loop <<<<<\n\n\n          return;\n        } //--> End Jenkins-Traub\n\n\n        rpSolve(degreePar, p, zeror, zeroi);\n        var l = zeroi.length; //format the output\n\n        for (i = 0; i < l; i++) {\n          // We round the imaginary part to avoid having something crazy like 5.67e-16.\n          var img = round(zeroi[i], decp + 8),\n              real = round(zeror[i], decp + 8); // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n          // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n          // the original otherwise the rounding was worth it.\n\n          real = decp - String(real).length > 2 ? real : zeror[i];\n          var sign = img < 0 ? '-' : ''; // Remove the zeroes\n\n          if (real === 0) {\n            real = '';\n          }\n\n          if (img === 0) {\n            img = '';\n          } // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n\n\n          img = Math.abs(img) === 1 ? sign + 'i' : img ? img + '*i' : '';\n          var num = real && img ? real + '+' + img : real + img;\n          zeror[i] = num.replace(/\\+\\-/g, '-');\n        }\n\n        return zeror;\n      }\n    },\n    roots: function (symbol) {\n      var roots = __.proots(symbol).map(function (x) {\n        return _.parse(x);\n      });\n\n      return core.Vector.fromArray(roots);\n    },\n    froot: function (f, guess, dx) {\n      var newtonraph = function (xn) {\n        var mesh = 1e-12,\n            // If the derivative was already provided then don't recalculate.\n        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n            // If the function was passed in as a function then don't recalculate.\n        fn = f instanceof Function ? f : core.Utils.build(f),\n            max = 10000,\n            done = false,\n            safety = 0;\n\n        while (!done) {\n          var x = xn - fn(xn) / df(xn); //absolute values for both x & xn ensures that we indeed have the radius    \n\n          var r = Math.abs(x) - Math.abs(xn),\n              delta = Math.abs(r);\n          xn = x;\n          if (delta < mesh) done = true;else if (safety > max) {\n            xn = null;\n            done = true;\n          }\n          safety++;\n        }\n\n        return xn;\n      };\n\n      return newtonraph(Number(guess));\n    },\n    quad: function (a, b, c) {\n      var q = function (a, b, c, sign) {\n        return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\n      };\n\n      return [q(a, b, c, 1), q(a, b, c, -1)];\n    },\n    sumProd: function (a, b) {\n      return __.quad(-b, a, -1).map(function (x) {\n        return x.invert();\n      });\n    },\n    coeffs: function (symbol, wrt, coeffs) {\n      wrt = String(wrt);\n      symbol = _.expand(symbol);\n      coeffs = coeffs || [new Symbol(0)]; //we cannot get coeffs for group EX\n\n      if (symbol.group === EX && symbol.contains(wrt, true)) _.error('Unable to get coefficients using expression ' + symbol.toString());\n      var vars = variables(symbol);\n\n      if (vars.length <= 1 && vars[0] === wrt) {\n        var a = new Polynomial(symbol).coeffs.map(function (x) {\n          return new Symbol(x);\n        });\n\n        for (var i = 0, l = a.length; i < l; i++) {\n          var coeff = a[i],\n              e = coeffs[i];\n          if (e) coeff = _.add(e, coeff);\n          coeffs[i] = coeff; //transfer it all over\n        }\n      } else {\n        if (!wrt) _.error('Polynomial contains more than one variable. Please specify which variable is to be used!'); //if the variable isn't part of this polynomial then we're looking at x^0\n\n        if (vars.indexOf(wrt) === -1) {\n          coeffs[0] = _.add(symbol, coeffs[0]);\n        } else {\n          coeffs = coeffs || [new Symbol(0)];\n\n          if (symbol.group === CB) {\n            var s = symbol.symbols[wrt];\n            if (!s) _.error('Expression is not a polynomial!');\n            var p = Number(s.power);\n            coeff = _.divide(symbol.clone(), s.clone());\n            if (coeff.contains(wrt, true) || p < 0 || !isInt(p)) _.error('Expression is not a polynomial!');\n            var e = coeffs[p];\n            if (e) coeff = _.add(e, coeff);\n            coeffs[p] = coeff;\n          } else if (symbol.group === CP) {\n            symbol.each(function (x) {\n              __.coeffs(x.clone(), wrt, coeffs);\n            }, true);\n          }\n        }\n      } //fill holes\n\n\n      for (var i = 0, l = coeffs.length; i < l; i++) if (typeof coeffs[i] === 'undefined') coeffs[i] = new Symbol(0);\n\n      return coeffs;\n    },\n\n    /**\r\n     * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n     * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n     * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n     * @param {Symbol} e\r\n     * @param {String} for_variable\r\n     * @param {Array} powers\r\n     * @returns {Array} An array of the powers\r\n     */\n    //assumes you've already verified that it's a polynomial\n    polyPowers: function (e, for_variable, powers) {\n      powers = powers || [];\n      var g = g = e.group;\n\n      if (g === PL && for_variable === e.value) {\n        powers = powers.concat(keys(e.symbols));\n      } else if (g === CP) {\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s];\n          var g = symbol.group,\n              v = symbol.value;\n          if (g === S && for_variable === v) powers.push(symbol.power);else if (g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);else if (g === CB && symbol.contains(for_variable)) {\n            var t = symbol.symbols[for_variable];\n            if (t) powers.push(t.power);\n          } else if (g === N || for_variable !== v) powers.push(0);\n        }\n      } else if (g === CB && e.contains(for_variable)) {\n        powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n      }\n\n      return core.Utils.arrayUnique(powers).sort();\n    },\n    //The factor object\n    Factor: {\n      //splits the symbol in symbol and constant\n      split: function (symbol) {\n        var c = new Symbol(1); //the constants part\n\n        var s = new Symbol(1); //the symbolic part\n\n        __.Factor.factor(symbol, new Factors()).each(function (x) {\n          var t = _.parse(x);\n\n          if (x.isConstant(true)) {\n            c = _.multiply(c, t);\n          } else {\n            s = _.multiply(s, t);\n          }\n        });\n\n        return [c, s];\n      },\n      mix: function (o, include_negatives) {\n        var factors = keys(o);\n        var l = factors.length;\n        var m = []; //create a row which we'r going to be mixing\n\n        for (var i = 0; i < l; i++) {\n          var factor = factors[i],\n              p = o[factor];\n          var ll = m.length;\n\n          for (var j = 0; j < ll; j++) {\n            var t = m[j] * factor;\n            m.push(t);\n            if (include_negatives) m.push(-t);\n          }\n\n          for (var j = 1; j <= p; j++) m.push(Math.pow(factor, j));\n        }\n\n        return m;\n      },\n      //TODO: this method is to replace common factoring\n      common: function (symbol, factors) {\n        try {\n          if (symbol.group === CP) {\n            //this may have the unfortunate side effect of expanding and factoring again\n            //to only end up with the same result. \n            //TODO: try to avoid this\n            //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n            //has to contain the variable in order for it to be factorable\n            var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\n              return (b.length || 1) - (a.length || 1);\n            });\n\n            var map = {}; //create a map of common factors\n\n            var coeffs = [];\n\n            for (var i = 0; i < symbols.length; i++) {\n              var sym = symbols[i];\n              coeffs.push(sym.multiplier.clone());\n              sym.each(function (x) {\n                var p = Number(x.power); //This check exits since we have a symbolic power.\n                //For the future... think about removing this check and modify for symbolic powers\n\n                if (isNaN(p)) throw new Error('exiting'); //loop through the symbols and lump together common terms\n\n                if (x.value in map) {\n                  if (p < map[x.value][0]) map[x.value][0] = p;\n                  map[x.value][1].push(x);\n                } else map[x.value] = [p, [x]];\n              });\n            } //the factor\n\n\n            var factor = new Symbol(1);\n\n            for (var x in map) {\n              //if this factor is found in all terms since the length of \n              //matching variable terms matches the number of original terms\n              if (map[x][1].length === symbols.length) {\n                //generate a symbol and multiply into the factor\n                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n              }\n            } //get coefficient factor\n\n\n            var c = core.Math2.QGCD.apply(null, coeffs);\n\n            if (!c.equals(1)) {\n              factors.add(new Symbol(c));\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n              }\n            } //if we actuall found any factors\n\n\n            if (!factor.equals(1)) {\n              factors.add(factor);\n              symbol = new Symbol(0);\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      zeroes: function (symbol, factors) {\n        var exit = function () {\n          throw new core.exceptions.ValueLimitExceededError('Exiting');\n        };\n\n        try {\n          var vars, term, sum, p, e;\n          symbol = _.expand(symbol.clone());\n          e = symbol.toString();\n          vars = variables(symbol);\n          sum = new Symbol(0);\n          var terms = [];\n          var powers = []; //start setting each variable to zero\n\n          for (var i = 0, l = vars.length; i < vars.length; i++) {\n            var subs = {}; //we want to create a subs object with all but the current variable set to zero\n\n            for (var j = 0; j < l; j++) if (i !== j) //make sure we're not looking at the same variable\n              subs[vars[j]] = 0;\n\n            term = _.parse(e, subs);\n            var tp = term.power; //the temporary power has to be an integer as well\n\n            if (!isInt(tp)) exit();\n            terms.push(term);\n            powers.push(term.power);\n          } //get the gcd. This will be the p in (a^n+b^m)^p\n          //if the gcd equals 1 meaning n = m then we need a tie breakder\n\n\n          if (core.Utils.allSame(powers)) {\n            //get p given x number of terms\n            var n_terms = symbol.length; //the number of zeroes determines\n\n            var n_zeroes = terms.length;\n\n            if (n_zeroes === 2) {\n              p = new Frac(powers[0] / (n_terms - 1));\n            }\n\n            if (n_zeroes === 3) {\n              p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\n            }\n            /*\r\n            //get the lowest possible power\r\n            //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n            symbol.each(function(x) {\r\n                if(x.group === CB)\r\n                    x.each(function(y) {\r\n                        if(!p || y.power.lessThan(p))\r\n                            //p = Number(y.power);\r\n                            p = y.power;\r\n                    });\r\n                else if(!p || x.power.lessThan(p))\r\n                    //p = Number(x.power);\r\n                    p = x.power;\r\n            });\r\n            */\n\n          } else //p is just the gcd of the powers\n            p = core.Math2.QGCD.apply(null, powers); //if we don't have an integer then exit\n\n\n          if (!isInt(p)) exit(); //build the factor\n\n          for (var i = 0; i < terms.length; i++) {\n            var t = terms[i];\n            var n = t.power.clone().divide(p);\n            t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\n            t.power = p.clone();\n            sum = _.add(sum, t);\n          } //by now we have the factor of zeroes. We'll know if we got it right because \n          //we'll get a remainder of zero each time we divide by it\n\n\n          if (sum.group !== CP) return symbol; //nothing to do\n\n          while (true) {\n            var d = __.div(symbol.clone(), sum.clone());\n\n            if (d[1].equals(0)) {\n              symbol = d[0];\n              factors.add(sum.clone());\n              if (symbol.equals(1)) //we've reached 1 so done.\n                break;\n            } else break;\n          }\n        } catch (e) {}\n\n        ;\n        return symbol;\n      },\n      factor: function (symbol, factors) {\n        //some items cannot be factored any further so return those right away\n        if (symbol.group === FN) {\n          var arg = symbol.args[0];\n          if (arg.group === S && arg.isSimple()) return symbol;\n        } else if (symbol.group === S && symbol.isSimple()) return symbol; //expand the symbol to get it in a predictable form. If this step\n        //is skipped some factors are missed.\n\n\n        if (symbol.group === CP) {\n          var t = new Symbol(0);\n          symbol.each(function (x) {\n            if (x.group === CP && x.power.greaterThan(1) || x.group === CB) x = _.expand(x);\n            t = _.add(t, x);\n          });\n          t.power = symbol.power;\n          symbol = t;\n        }\n\n        if (symbol.group === FN && symbol.fname !== 'sqrt') symbol = core.Utils.evaluate(symbol); //make a copy of the symbol to return if something goes wrong\n\n        var untouched = symbol.clone();\n\n        try {\n          if (symbol.group === CB) {\n            var den_array, num_array, den, num, dfact, nfact; //grab the denominator and strip the multiplier and power. Store them in an array\n\n            den_array = __.Simplify.strip(symbol.getDenom());\n            num_array = __.Simplify.strip(symbol.getNum());\n            den = den_array.pop();\n            num = num_array.pop(); //if the numerator equals the symbol then we've hit the simplest form and then we're done\n\n            if (num.equals(symbol)) return symbol;\n            nfact = __.Factor.factor(num);\n            dfact = __.Factor.factor(den);\n            return _.divide(__.Simplify.unstrip(num_array, nfact), __.Simplify.unstrip(den_array, dfact));\n          }\n\n          if (symbol.group === S) return symbol; //absolutely nothing to do\n\n          if (symbol.isConstant()) {\n            if (symbol.equals(1)) return symbol.clone();\n            return core.Math2.factor(symbol);\n          }\n\n          var p = symbol.power.clone();\n\n          if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\n            var sign = p.sign();\n            symbol.toLinear();\n            factors = factors || new Factors();\n            var map = {};\n            symbol = _.parse(core.Utils.subFunctions(symbol, map));\n\n            if (keys(map).length > 0) {\n              //it might have functions\n              factors.preAdd = function (factor) {\n                return _.parse(factor, core.Utils.getFunctionsSubs(map));\n              };\n            } //strip the power\n\n\n            if (!symbol.isLinear()) {\n              factors.pFactor = symbol.power.toString();\n              symbol.toLinear();\n            }\n\n            var vars = variables(symbol); //bypass for imaginary. TODO: find a better solution\n\n            if (symbol.isImaginary()) {\n              vars.push(core.Settings.IMAGINARY);\n            }\n\n            var multiVar = vars.length > 1; //minor optimization. Seems to cut factor time by half in some cases.\n\n            if (multiVar) {\n              var all_S = true,\n                  all_unit = true;\n              symbol.each(function (x) {\n                if (x.group !== S) all_S = false;\n                if (!x.multiplier.equals(1)) all_unit = false;\n              });\n\n              if (all_S && all_unit) {\n                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n              }\n            } //factor the coefficients\n\n\n            var coeff_factors = new Factors();\n            symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n            coeff_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            }); //factor the power\n\n            var power_factors = new Factors();\n            symbol = __.Factor.powerFactor(symbol, power_factors);\n            power_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n\n            if (!multiVar) {\n              //pass in vars[0] for safety\n              var v = vars[0];\n              symbol = __.Factor.squareFree(symbol, factors, v);\n              var t_factors = new Factors();\n              symbol = __.Factor.trialAndError(symbol, t_factors, v);\n\n              for (var x in t_factors.factors) {\n                factors.add(_.pow(t_factors.factors[x], _.parse(p)));\n              }\n            } else {\n              symbol = __.Factor.mfactor(symbol, factors); //put back the sign of power\n\n              factors.each(function (x) {\n                if (sign < 0) x.power.negate();\n              });\n            } //last minute clean up\n\n\n            symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n            factors.add(_.pow(symbol, _.parse(p))); //                        //mayb we can factor some more. Let's give it a go\n            //                        if(factors.length > 1) {\n            //                            var _factors = new Factors();\n            //                            factors.each(function(x) {\n            //                                var t = new Factors();\n            //                                __.Factor.factor(x, t);\n            //                                t.each(function(y) {\n            //                                    _factors.add(y);\n            //                                });\n            //                            });\n            //                            factors = _factors;\n            //                        }\n\n            var retval = factors.toSymbol(); //maybe it can be factored some more\n\n            return retval;\n          }\n\n          return symbol;\n        } catch (e) {\n          //no need to stop the show because something went wrong :)\n          return untouched;\n        }\n      },\n      reduce: function (symbol, factors) {\n        if (symbol.group === CP && symbol.length === 2) {\n          var symbols = symbol.collectSymbols().sort(function (a, b) {\n            return b.multiplier - a.multiplier;\n          });\n\n          if (symbols[0].power.equals(symbols[1].power)) {\n            //x^n-a^n\n            var n = _.parse(symbols[0].power),\n                a = symbols[0].clone().toLinear(),\n                b = symbols[1].clone().toLinear(); //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n\n\n            factors.add(_.add(a.clone(), b.clone())); //flip the sign\n\n            b.negate(); //turn n into a number\n\n            var nn = Number(n); //the remainder\n\n            var result = new Symbol(0);\n\n            for (var i = 1; i <= nn; i++) {\n              var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                  bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n\n              result = _.add(result, _.multiply(aa, bb));\n            }\n\n            return result;\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Makes Symbol square free\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      squareFree: function (symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n        var poly = new Polynomial(symbol, variable);\n        var sqfr = poly.squareFree();\n        var p = sqfr[2]; //if we found a square then the p entry in the array will be non-unit\n\n        if (p !== 1) {\n          //make sure the remainder doesn't have factors\n          var t = sqfr[1].toSymbol();\n          t.power = t.power.multiply(new Frac(p)); //send the factor to be fatored to be sure it's completely factored\n\n          factors.add(__.Factor.factor(t));\n          return __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Factors the powers such that the lowest power is a constant\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      powerFactor: function (symbol, factors) {\n        if (symbol.group !== PL) return symbol; //only PL need apply\n\n        var d = core.Utils.arrayMin(keys(symbol.symbols));\n        var retval = new Symbol(0);\n\n        var q = _.parse(symbol.value + '^' + d);\n\n        symbol.each(function (x) {\n          x = _.divide(x, q.clone());\n          retval = _.add(retval, x);\n        });\n        factors.add(q);\n        return retval;\n      },\n\n      /**\r\n       * Removes GCD from coefficients\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      coeffFactor: function (symbol, factors) {\n        if (symbol.isComposite()) {\n          var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n\n          if (!gcd.equals(1)) {\n            symbol.each(function (x) {\n              if (x.isComposite()) {\n                x.each(function (y) {\n                  y.multiplier = y.multiplier.divide(gcd);\n                });\n              } else x.multiplier = x.multiplier.divide(gcd);\n            });\n          }\n\n          symbol.updateHash();\n          if (factors) factors.add(new Symbol(gcd));\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * The name says it all :)\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      trialAndError: function (symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n\n        var poly = new Polynomial(symbol, variable),\n            cnst = poly.coeffs[0],\n            cfactors = core.Math2.ifactor(cnst),\n            roots = __.proots(symbol);\n\n        for (var i = 0; i < roots.length; i++) {\n          var r = roots[i],\n              p = 1;\n\n          if (!isNaN(r)) {\n            //if it's a number\n            for (var x in cfactors) {\n              //check it's raised to a power\n              var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\n\n              if (isInt(n)) {\n                r = x; //x must be the root since n gave us a whole\n\n                p = n;\n                break;\n              }\n            }\n\n            var root = new Frac(r),\n                terms = [new Frac(root.num).negate()];\n            terms[p] = new Frac(root.den); //convert to Frac. The den is coeff of LT and the num is coeff of constant\n\n            var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                t = poly.divide(div);\n\n            if (t[1].equalsNumber(0)) {\n              //if it's zero we have a root and divide it out\n              poly = t[0];\n              factors.add(div.toSymbol());\n            }\n          }\n        }\n\n        if (!poly.equalsNumber(1)) {\n          poly = __.Factor.search(poly, factors);\n        }\n\n        return poly.toSymbol();\n      },\n      search: function (poly, factors, base) {\n        base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n\n        var v = poly.variable; //the polynmial variable name\n\n        /**\r\n         * Attempt to remove a root by division given a number by first creating\r\n         * a polynomial fromt he given information\r\n         * @param {int} c1 - coeffient for the constant\r\n         * @param {int} c2 - coefficient for the LT\r\n         * @param {int} n - the number to be used to construct the polynomial\r\n         * @param {int} p - the power at which to create the polynomial\r\n         * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n         */\n\n        var check = function (c1, c2, n, p) {\n          var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n\n          if (candidate && candidate.coeffs.length > 1) {\n            var t = poly.divide(candidate);\n\n            if (t[1].equalsNumber(0)) {\n              factors.add(candidate.toSymbol());\n              return [t[0], candidate];\n            }\n          }\n\n          return null;\n        };\n\n        var cnst = poly.coeffs[0],\n            cfactors = core.Math2.ifactor(cnst),\n            lc = poly.lc(),\n            ltfactors = core.Math2.ifactor(lc),\n            subbed = poly.sub(base),\n            nfactors = __.Factor.mix(core.Math2.ifactor(subbed), subbed < 0),\n            cp = Math.ceil(poly.coeffs.length / 2),\n            lc_is_neg = lc.lessThan(0),\n            cnst_is_neg = cnst.lessThan(0);\n\n        ltfactors['1'] = 1;\n        cfactors['1'] = 1;\n\n        while (cp--) {\n          for (var x in ltfactors) {\n            for (var y in cfactors) {\n              for (var i = 0; i < nfactors.length; i++) {\n                var factor_found = check(x, y, nfactors[i], cp);\n\n                if (factor_found) {\n                  poly = factor_found[0];\n                  if (!core.Utils.isPrime(poly.sub(base))) poly = __.Factor.search(poly, factors);\n                  return poly;\n                } else if (!factor_found) {\n                  if (lc_is_neg && cnst_is_neg) factor_found = check(-x, -y, nfactors[i], cp);else if (lc_is_neg) factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                  else if (cnst_is_neg) factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                }\n              }\n            }\n          }\n        }\n\n        return poly;\n      },\n\n      /**\r\n       * Equivalent of square free factor for multivariate polynomials\r\n       * @param {type} symbol\r\n       * @param {type} factors\r\n       * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n       */\n      mSqfrFactor: function (symbol, factors) {\n        if (symbol.group !== FN) {\n          var vars = variables(symbol).reverse();\n\n          for (var i = 0; i < vars.length; i++) {\n            do {\n              if (vars[i] === symbol.value) {\n                //the derivative tells us nothing since this symbol is already the factor\n                factors.add(symbol);\n                symbol = new Symbol(1);\n                continue;\n              }\n\n              var d = __.Factor.coeffFactor(core.Calculus.diff(symbol, vars[i]));\n\n              if (d.equals(0)) break;\n\n              var div = __.div(symbol, d.clone()),\n                  is_factor = div[1].equals(0);\n\n              if (div[0].isConstant()) {\n                factors.add(div[0]);\n                break;\n              }\n\n              if (is_factor) {\n                factors.add(div[0]);\n                symbol = d;\n              }\n            } while (is_factor);\n          }\n        }\n\n        return symbol;\n      },\n      //difference of squares factorization\n      sqdiff: function (symbol, factors) {\n        try {\n          var remove_square = function (x) {\n            return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n              return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n            }, true);\n          };\n\n          var separated = core.Utils.separate(symbol.clone());\n          var obj_array = []; //get the unique variables\n\n          for (var x in separated) {\n            if (x !== 'constants') {\n              obj_array.push(separated[x]);\n            }\n          }\n\n          obj_array.sort(function (a, b) {\n            return b.power - a.power;\n          }); //if we have the same number of variables as unique variables then we can apply the difference of squares\n\n          if (obj_array.length === 2) {\n            var a, b;\n            a = obj_array.pop();\n            b = obj_array.pop();\n\n            if (a.isComposite() && b.power.equals(2)) {\n              //remove the square from b\n              b = remove_square(b);\n\n              var f = __.Factor.factor(_.add(a, separated.constants));\n\n              if (f.power.equals(2)) {\n                f.toLinear();\n                factors.add(_.subtract(f.clone(), b.clone()));\n                factors.add(_.add(f, b));\n                symbol = new Symbol(1);\n              }\n            } else {\n              a = a.powSimp();\n              b = b.powSimp();\n\n              if ((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2)) {\n                if (a.multiplier.lessThan(0)) {\n                  var t = b;\n                  b = a;\n                  a = t;\n                }\n\n                if (a.multiplier.greaterThan(0)) {\n                  a = remove_square(a);\n                  b = remove_square(b);\n                }\n\n                factors.add(_.subtract(a.clone(), b.clone()));\n                factors.add(_.add(a, b));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      //factoring for multivariate\n      mfactor: function (symbol, factors) {\n        if (symbol.group === FN) {\n          if (symbol.fname === 'sqrt') {\n            var factors2 = new Factors(),\n                arg = __.Factor.common(symbol.args[0].clone(), factors2);\n\n            arg = __.Factor.coeffFactor(arg, factors2);\n            symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n            factors2.each(function (x) {\n              symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n            });\n          } else factors.add(symbol);\n        } else {\n          //symbol = __.Factor.common(symbol, factors);\n          symbol = __.Factor.mSqfrFactor(symbol, factors);\n          var vars = variables(symbol),\n              symbols = symbol.collectSymbols().map(function (x) {\n            return Symbol.unwrapSQRT(x);\n          }),\n              sorted = {},\n              maxes = {},\n              l = vars.length,\n              n = symbols.length; //take all the variables in the symbol and organize by variable name\n          //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n\n          for (var i = 0; i < l; i++) {\n            var v = vars[i];\n            sorted[v] = new Symbol(0);\n\n            for (var j = 0; j < n; j++) {\n              var s = symbols[j];\n\n              if (s.contains(v)) {\n                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                if (!maxes[v] || p < maxes[v]) maxes[v] = p;\n                sorted[v] = _.add(sorted[v], s.clone());\n              }\n            }\n          }\n\n          for (var x in sorted) {\n            var r = _.parse(x + '^' + maxes[x]);\n\n            var div = _.divide(sorted[x], r);\n\n            var new_factor = _.expand(div);\n\n            if (new_factor.equals(1)) break; //why divide by one. Just move \n\n            var divided = __.div(symbol.clone(), new_factor);\n\n            if (divided[0].equals(0)) {\n              //cant factor anymore\n              break;\n            }\n\n            var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n\n            if (divided[1].equals(0) && !neg_numeric_factor) {\n              //we found at least one factor\n              //factors.add(new_factor);\n              var d = __.div(symbol.clone(), divided[0].clone());\n\n              var r = d[0];\n              symbol = d[1]; //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n              //and we just return the symbol;\n              //If r equals zero then there's nothing left to do so we're done\n\n              if (r.equals(-1)) return symbol;\n              var factor = divided[0];\n\n              if (symbol.equals(factor)) {\n                var rem = __.Factor.reduce(factor, factors);\n\n                if (!symbol.equals(rem)) return __.Factor.mfactor(rem, factors);\n              } else {\n                factors.add(factor); //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n\n                if (symbol.equals(0)) return r;\n              }\n\n              if (r.isConstant('all')) {\n                factors.add(r);\n                return r;\n              }\n\n              return __.Factor.mfactor(r, factors);\n            }\n          }\n        } //difference of squares factorization\n\n\n        symbol = __.Factor.sqdiff(symbol, factors); //factors by fishing for zeroes\n\n        symbol = __.Factor.zeroes(symbol, factors);\n        return symbol;\n      }\n    },\n\n    /**\r\n     * Checks to see if a set of \"equations\" is linear. \r\n     * @param {type} set\r\n     * @returns {Boolean}\r\n     */\n    allLinear: function (set) {\n      var l = set.length;\n\n      for (var i = 0; i < l; i++) {\n        if (!__.isLinear(set[i])) return false;\n      }\n\n      return true;\n    },\n\n    /*\r\n     * Checks to see if the \"equation\" is linear\r\n     * @param {Symbol} e\r\n     * @returns {boolean}\r\n     */\n    isLinear: function (e) {\n      var status = false,\n          g = e.group;\n\n      if (g === PL || g === CP) {\n        status = true;\n\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s],\n              sg = symbol.group;\n\n          if (sg === FN || sg === EX) {\n            status = false;\n          }\n\n          if (sg === CB) {\n            //needs further checking since it might be imaginary\n            status = variables(symbol).length === 1;\n          } else {\n            if (sg === PL || sg === CP) status = __.isLinear(symbol);else {\n              if (symbol.group !== N && symbol.power.toString() !== '1') {\n                status = false;\n                break;\n              }\n            }\n          }\n        }\n      } else if (g === S && e.power === 1) status = true;\n\n      return status;\n    },\n    gcd: function () {\n      var args;\n      if (arguments.length === 1 && arguments[0] instanceof core.Vector) args = arguments[0].elements;else args = core.Utils.arguments2Array(arguments); //short-circuit early\n\n      if (args.length === 0) return new Symbol(1);else if (args.length === 1) return args[0];\n      var appeared = [],\n          evaluate = false;\n\n      for (var i = 0; i < args.length; i++) {\n        if (args[i].group === FN && args[i].fname === 'gcd') {\n          //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n          args = args.concat(arguments[i].args); //do not keep gcd in args\n\n          args.splice(i, 1);\n        } else {\n          //Look if there are any common variables such that\n          //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n          var vars = variables(args[i]);\n\n          if (core.Utils.haveIntersection(vars, appeared)) {\n            //Ok, there are common variables\n            evaluate = true;\n            break;\n          } else appeared = appeared.concat(vars);\n        }\n      } //appeared.length is 0 when all arguments are group N\n\n\n      if (evaluate || appeared.length === 0) {\n        //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n        if (args.every(function (symbol) {\n          return symbol.getDenom().equals(1);\n        })) {\n          var aggregate = args[0];\n\n          for (var i = 1; i < args.length; i++) {\n            aggregate = __.gcd_(args[i], aggregate);\n          }\n\n          return aggregate;\n        } else {\n          //gcd_ cannot handle denominators correctly\n          return _.divide(__.gcd.apply(null, args.map(function (symbol) {\n            return symbol.getNum();\n          })), __.lcm.apply(null, args.map(function (symbol) {\n            return symbol.getDenom();\n          })));\n        }\n      } else return _.symfunction('gcd', args);\n    },\n    gcd_: function (a, b) {\n      if (a.group === FN || a.group === P) a = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(a);\n      });\n      if (b.group === FN) b = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(b);\n      });\n\n      if (a.isConstant() && b.isConstant()) {\n        // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n        return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n      }\n\n      var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n\n      a = _.multiply(a.clone(), den.clone());\n      b = _.multiply(b.clone(), den.clone()); //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n\n      a = _.expand(a);\n      b = _.expand(b);\n\n      if (a.group === CB || b.group === CB) {\n        var q = _.divide(a.clone(), b.clone()); //get the quotient\n\n\n        var t = _.multiply(b.clone(), q.getDenom().invert()); //multiply by the denominator\n        //if they have a common factor then the result will not equal one \n\n\n        if (!t.equals(1)) return t;\n      } //just take the gcd of each component when either of them is in group EX\n\n\n      if (a.group === EX || b.group === EX) {\n        var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n\n        var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n\n        var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n\n        return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n      }\n\n      if (a.length < b.length) {\n        //swap'm\n        var t = a;\n        a = b;\n        b = t;\n      }\n\n      var vars_a = variables(a),\n          vars_b = variables(b);\n\n      if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {\n        a = new Polynomial(a);\n        b = new Polynomial(b);\n        return _.divide(a.gcd(b).toSymbol(), den);\n      } else {\n        //get the gcd of the multipiers\n        //get rid of gcd in coeffs\n        var multipliers = [];\n        a.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        b.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        var T;\n\n        while (!b.equals(0)) {\n          var t = b.clone();\n          a = a.clone();\n          T = __.div(a, t);\n          b = T[1];\n\n          if (T[0].equals(0)) {\n            //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n            return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n          }\n\n          a = t;\n        }\n\n        var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n\n        if (!gcd.equals(1)) {\n          a.each(function (x) {\n            x.multiplier = x.multiplier.divide(gcd);\n          });\n        } //return symbolic function for gcd in indeterminate form\n\n\n        if (a.equals(1) && !a.isConstant() && !b.isConstant()) return _.divide(_.symfunction('gcd', arguments), den);\n        return _.divide(a, den);\n      }\n    },\n    lcm: function () {\n      //https://math.stackexchange.com/a/319310\n      //generalization of the 2-variable formula of lcm\n      var args;\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof core.Vector) args = arguments[0].elements;else _.error('lcm expects either 1 vector or 2 or more arguments');\n      } else args = core.Utils.arguments2Array(arguments); //product of all arguments\n      //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n\n      var numer = args.reduce(function (prev, curr) {\n        return _.multiply(prev, curr.clone());\n      }, new Symbol(1)); //gcd of complementary terms\n\n      var denom_args = //https://stackoverflow.com/a/18223072\n      //take all complementary terms, e.g.\n      //[a,b,c] => [a*b, b*c, a*c]\n      //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n      function (input, size) {\n        var results = [],\n            result,\n            mask,\n            i,\n            total = Math.pow(2, input.length);\n\n        for (mask = size; mask < total; mask++) {\n          result = [];\n          i = input.length - 1;\n\n          do {\n            if ((mask & 1 << i) !== 0) {\n              result.push(input[i]);\n            }\n          } while (i--);\n\n          if (result.length == size) {\n            results.push(result);\n          }\n        }\n\n        return results; //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      }(arguments, arguments.length - 1).map(function (x) {\n        return x.reduce(function (prev, curr) {\n          return _.multiply(prev, curr.clone());\n        }, new Symbol(1));\n      }); //don't eat the gcd term if all arguments are symbols\n\n\n      if (args.every(function (x) {\n        return core.Utils.isVariableSymbol(x);\n      })) var denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));else var denom = __.gcd.apply(null, denom_args); //divide product of all arguments by gcd of complementary terms\n\n      return _.divide(numer, denom);\n    },\n\n    /**\r\n     * Divides one expression by another\r\n     * @param {Symbol} symbol1\r\n     * @param {Symbol} symbol2\r\n     * @returns {Array}\r\n     */\n    divide: function (symbol1, symbol2) {\n      var result, remainder, factored, den;\n      factored = core.Algebra.Factor.factor(symbol1.clone());\n      den = factored.getDenom();\n\n      if (!den.isConstant('all')) {\n        symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n      } else //reset the denominator since we're not dividing by it anymore\n        den = new Symbol(1);\n\n      result = __.div(symbol1, symbol2);\n      remainder = _.divide(result[1], symbol2);\n      return _.divide(_.add(result[0], remainder), den);\n    },\n    div: function (symbol1, symbol2) {\n      //division by constants\n      if (symbol2.isConstant()) {\n        symbol1.each(function (x) {\n          x.multiplier = x.multiplier.divide(symbol2.multiplier);\n        });\n        return [symbol1, new Symbol(0)];\n      } //so that factorized symbols don't affect the result\n\n\n      symbol1 = _.expand(symbol1);\n      symbol2 = _.expand(symbol2); //special case. May need revisiting\n\n      if (symbol1.group === S && symbol2.group === CP) {\n        var x = symbol1.value;\n        var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n\n        if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n          var k = Symbol.create(symbol1.multiplier);\n          return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n        }\n      }\n\n      if (symbol1.group === S && symbol2.group === S) {\n        var r = _.divide(symbol1.clone(), symbol2.clone());\n\n        if (r.isConstant()) //we have a whole\n          return [r, new Symbol(0)];\n        return [new Symbol(0), symbol1.clone()];\n      }\n\n      var symbol1_has_func = symbol1.hasFunc(),\n          symbol2_has_func = symbol2.hasFunc(),\n          parse_funcs = false; //substitute out functions so we can treat them as regular variables\n\n      if (symbol1_has_func || symbol2_has_func) {\n        parse_funcs = true;\n\n        var map = {},\n            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n            subs = core.Utils.getFunctionsSubs(map);\n      } //get a list of the variables\n\n\n      var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n          quot,\n          rem; //treat imaginary numbers as variables\n\n      if (symbol1.isImaginary() || symbol2.isImaginary()) {\n        vars.push(core.Settings.IMAGINARY);\n      }\n\n      if (vars.length === 1) {\n        var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n        quot = q[0].toSymbol();\n        rem = q[1].toSymbol();\n      } else {\n        vars.push(CONST_HASH); //this is for the numbers\n\n        var reconvert = function (arr) {\n          var symbol = new Symbol(0);\n\n          for (var i = 0; i < arr.length; i++) {\n            var x = arr[i].toSymbol();\n            symbol = _.add(symbol, x);\n          }\n\n          return symbol;\n        }; //Silly Martin. This is why you document. I don't remember now\n\n\n        var get_unique_max = function (term, any) {\n          var max = Math.max.apply(null, term.terms),\n              count = 0,\n              idx;\n\n          if (!any) {\n            for (var i = 0; i < term.terms.length; i++) {\n              if (term.terms[i].equals(max)) {\n                idx = i;\n                count++;\n              }\n\n              if (count > 1) return;\n            }\n          }\n\n          if (any) {\n            for (i = 0; i < term.terms.length; i++) if (term.terms[i].equals(max)) {\n              idx = i;\n              break;\n            }\n          }\n\n          return [max, idx, term];\n        }; //tries to find an LT in the dividend that will satisfy division\n\n\n        var get_det = function (s, lookat) {\n          lookat = lookat || 0;\n          var det = s[lookat],\n              l = s.length;\n          if (!det) return; //eliminate the first term if it doesn't apply\n\n          var umax = get_unique_max(det);\n\n          for (var i = lookat + 1; i < l; i++) {\n            var term = s[i],\n                is_equal = det.sum.equals(term.sum);\n\n            if (!is_equal && umax) {\n              break;\n            }\n\n            if (is_equal) {\n              //check the differences of their maxes. The one with the biggest difference governs\n              //e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n              var max1,\n                  max2,\n                  idx1,\n                  idx2,\n                  l2 = det.terms.length;\n\n              for (var j = 0; j < l2; j++) {\n                var item1 = det.terms[j],\n                    item2 = term.terms[j];\n\n                if (typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                  max1 = item1;\n                  idx1 = j;\n                }\n\n                if (typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                  max2 = item2;\n                  idx2 = j;\n                }\n              } //check their differences\n\n\n              var d1 = max1.subtract(term.terms[idx1]),\n                  d2 = max2.subtract(det.terms[idx2]);\n\n              if (d2 > d1) {\n                umax = [max2, idx2, term];\n                break;\n              }\n\n              if (d1 > d2) {\n                umax = [max1, idx1, det];\n                break;\n              }\n            } else {\n              //check if it's a suitable pick to determine the order\n              umax = get_unique_max(term); //if(umax) return umax;\n\n              if (umax) break;\n            }\n\n            umax = get_unique_max(term); //calculate a new unique max\n          } //if still no umax then any will do since we have a tie\n\n\n          if (!umax) return get_unique_max(s[0], true);\n          var e, idx;\n\n          for (var i = 0; i < s2.length; i++) {\n            var cterm = s2[i].terms; //confirm that this is a good match for the denominator\n\n            idx = umax[1];\n            if (idx === cterm.length - 1) return;\n            e = cterm[idx];\n            if (!e.equals(0)) break;\n          }\n\n          if (e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n          return umax;\n        };\n\n        var t_map = core.Utils.toMapObj(vars);\n\n        var init_sort = function (a, b) {\n          return b.sum.subtract(a.sum);\n        };\n\n        var is_larger = function (a, b) {\n          if (!a || !b) return false; //it's empty so...\n\n          for (var i = 0; i < a.terms.length; i++) {\n            if (a.terms[i].lessThan(b.terms[i])) return false;\n          }\n\n          return true;\n        };\n\n        var s1 = symbol1.tBase(t_map).sort(init_sort),\n            s2 = symbol2.tBase(t_map).sort(init_sort);\n        var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n\n        var det = get_det(target); //we'll begin by assuming that this will let us know which term \n\n        var quotient = [];\n\n        if (det) {\n          var lead_var = det[1];\n\n          var can_divide = function (a, b) {\n            if (a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n            return true;\n          };\n\n          var try_better_lead_var = function (s1, s2, lead_var) {\n            var checked = [];\n\n            for (var i = 0; i < s1.length; i++) {\n              var t = s1[i];\n\n              for (var j = 0; j < t.terms.length; j++) {\n                var cf = checked[j],\n                    tt = t.terms[j];\n                if (i === 0) checked[j] = tt; //add the terms for the first one\n                else if (cf && !cf.equals(tt)) checked[j] = undefined;\n              }\n            }\n\n            for (var i = 0; i < checked.length; i++) {\n              var t = checked[i];\n              if (t && !t.equals(0)) return i;\n            }\n\n            return lead_var;\n          };\n\n          var sf = function (a, b) {\n            var l1 = a.len(),\n                l2 = b.len();\n            var blv = b.terms[lead_var],\n                alv = a.terms[lead_var];\n            if (l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n            return blv.subtract(alv);\n          }; //check to see if there's a better lead_var\n\n\n          lead_var = try_better_lead_var(s1, s2, lead_var); //reorder both according to the max power\n\n          s1.sort(sf); //sort them both according to the leading variable power\n\n          s2.sort(sf); //try to adjust if den is larger\n\n          var fdt = s2[0],\n              fnt = s1[0];\n          var den = new MVTerm(new Frac(1), [], fnt.map);\n\n          if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\n            for (var i = 0; i < fnt.terms.length; i++) {\n              var d = fdt.terms[i].subtract(fnt.terms[i]);\n\n              if (!d.equals(0)) {\n                var nd = d.add(new Frac(1));\n                den.terms[i] = d;\n\n                for (var j = 0; j < s1.length; j++) {\n                  s1[j].terms[i] = s1[j].terms[i].add(nd);\n                }\n              } else den.terms[i] = new Frac(0);\n            }\n          }\n\n          var dividend_larger = is_larger(s1[0], s2[0]);\n\n          while (dividend_larger && can_divide(s1, s2)) {\n            var q = s1[0].divide(s2[0]);\n            quotient.push(q); //add what's divided to the quotient\n\n            s1.shift(); //the first one is guaranteed to be gone so remove from dividend\n\n            for (var i = 1; i < s2.length; i++) {\n              //loop through the denominator\n              var t = s2[i].multiply(q).generateImage(),\n                  l2 = s1.length; //if we're subtracting from 0\n\n              if (l2 === 0) {\n                t.coeff = t.coeff.neg();\n                s1.push(t);\n                s1.sort(sf);\n              }\n\n              for (var j = 0; j < l2; j++) {\n                var cur = s1[j];\n\n                if (cur.getImg() === t.getImg()) {\n                  cur.coeff = cur.coeff.subtract(t.coeff);\n\n                  if (cur.coeff.equals(0)) {\n                    core.Utils.remove(s1, j);\n                    j--; //adjust the iterator\n                  }\n\n                  break;\n                }\n\n                if (j === l2 - 1) {\n                  t.coeff = t.coeff.neg();\n                  s1.push(t);\n                  s1.sort(sf);\n                }\n              }\n            }\n\n            dividend_larger = is_larger(s1[0], s2[0]);\n\n            if (!dividend_larger && s1.length >= s2.length) {\n              //One more try since there might be a terms that is larger than the LT of the divisor\n              for (var i = 1; i < s1.length; i++) {\n                dividend_larger = is_larger(s1[i], s2[0]);\n\n                if (dividend_larger) {\n                  //take it from its current position and move it to the front\n                  s1.unshift(core.Utils.remove(s1, i));\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        quot = reconvert(quotient);\n        rem = reconvert(s1);\n\n        if (typeof den !== 'undefined') {\n          den = den.toSymbol();\n          quot = _.divide(quot, den.clone());\n          rem = _.divide(rem, den);\n        }\n      } //put back the functions\n\n\n      if (parse_funcs) {\n        quot = _.parse(quot.text(), subs);\n        rem = _.parse(rem.text(), subs);\n      }\n\n      return [quot, rem];\n    },\n    line: function (v1, v2, x) {\n      if (core.Utils.isArray(v1)) v1 = core.Utils.convertToVector(v1);\n      if (core.Utils.isArray(v2)) v2 = core.Utils.convertToVector(v2);\n      x = _.parse(x || 'x');\n      if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2)) _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\n\n      var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n          dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n          m = _.divide(dy, dx),\n          a = _.multiply(x, m.clone()),\n          b = _.multiply(v1.e(1).clone(), m);\n\n      return _.add(_.subtract(a, b), v1.e(2).clone());\n    },\n    PartFrac: {\n      createTemplate: function (den, denom_factors, f_array, v) {\n        //clean up the denominator function by factors so it reduces nicely\n        den = __.Factor.factor(den); //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n\n        den.each(function (x, key) {\n          if (x.group === FN && x.fname === '' && x.args[0].group === S) {\n            var y = x.args[0];\n\n            if (this.symbols) {\n              delete this.symbols[key];\n              this.symbols[y.value] = y;\n            } else {\n              den = x.args[0];\n            }\n          }\n        });\n        var factors, factors_vec, f, p, deg, degrees, m;\n        factors = denom_factors.collectFactors();\n        factors_vec = []; //a vector for the template\n\n        degrees = [];\n        m = new Symbol(1);\n\n        for (var i = 0; i < factors.length; i++) {\n          //loop through the factors\n          var factor = Symbol.unwrapPARENS(factors[i]); //if in he for P^n where P is polynomial and n = integer\n\n          if (factor.power.greaterThan(1)) {\n            p = Number(factor.power);\n            f = factor.clone().toLinear(); //remove the power so we have only the function\n\n            deg = Number(__.degree(f, v)); //get the degree of f\n            //expand the factor\n\n            for (var j = 0; j < p; j++) {\n              var efactor = _.pow(f.clone(), new Symbol(j + 1));\n\n              f_array.push(efactor.clone());\n\n              var d = _.divide(den.clone(), efactor.clone());\n\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n          }\n          /*\r\n          Possible bug.\r\n          Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n          else if(factor.isConstant('all')) {\r\n              m = _.multiply(m, factor);\r\n          }\r\n          */\n          else {\n              //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n              //but for now we note it on the symbol\n              deg = Number(__.degree(factor, v));\n              f_array.push(factor);\n\n              var d = _.divide(den.clone(), factor.clone());\n\n              d = _.expand(Symbol.unwrapPARENS(d));\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n        } //put back the constant\n\n\n        f_array = f_array.map(function (x) {\n          return _.multiply(x, m.clone());\n        });\n        return [f_array, factors_vec, degrees];\n      },\n      partfrac: function (symbol, v, as_array) {\n        var vars = variables(symbol);\n        v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n\n        try {\n          var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;\n          num = _.expand(symbol.getNum());\n          den = _.expand(symbol.getDenom().toUnitMultiplier()); //move the entire multipier to the numerator\n\n          num.multiplier = symbol.multiplier; //we only have a meaningful change if n factors > 1. This means that\n          //the returned group will be a CB\n          //collect the terms wrt the x\n\n          nterms = num.groupTerms(v); //divide out wholes if top is larger\n\n          if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n            div = __.div(num.clone(), _.expand(den.clone()));\n            r = div[0]; //remove the wholes\n\n            num = div[1]; //work with the remainder\n\n            nterms = num.groupTerms(v); //recalculate the nterms\n          } else r = new Symbol(0);\n\n          if (Number(__.degree(den, v)) === 1) {\n            var q = _.divide(num, den);\n\n            if (as_array) return [r, q];\n            return _.add(r, q);\n          } //first factor the denominator. This means that the strength of this\n          //algorithm depends on how well we can factor the denominator. \n\n\n          ofactors = __.Factor.factor(den); //create the template. This method will create the template for solving \n          //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n\n          template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n          tfactors = template[0]; //grab the factors\n\n          factors_vec = template[1]; //grab the factor vectors\n\n          degrees = template[2]; //grab the degrees\n          //make note of the powers of each term\n\n          powers = [nterms.length]; //create the dterms vector\n\n          dterms = [];\n          factors = [];\n          ks = [];\n          var factor, deg;\n          factors_vec.map(function (x, idx) {\n            factor = tfactors[idx];\n            deg = degrees[idx];\n\n            for (var i = 0; i < deg; i++) {\n              factors.push(factor.clone());\n              var k = Symbol.create(v, i);\n\n              var t = _.expand(_.multiply(x, k.clone())).groupTerms(v); //make a note of the power which corresponds to the length of the array\n\n\n              var p = t.length;\n              powers.push(p);\n              dterms.push(t);\n              ks.push(k.clone());\n            }\n          }); //get the max power\n\n          max = core.Utils.arrayMax(powers); //fill the holes and create a matrix\n\n          c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose(); //for each of the factors we do the same\n\n          M = new core.Matrix();\n\n          for (var i = 0; i < dterms.length; i++) {\n            M.elements.push(core.Utils.fillHoles(dterms[i], max));\n          } //solve the system of equations\n\n\n          var partials = _.multiply(M.transpose().invert(), c); //the results are backwards to reverse it\n          //partials.elements.reverse();\n          //convert it all back\n\n\n          var retval = as_array ? [r] : r;\n          partials.each(function (e, i) {\n            var term = _.multiply(ks[i], _.divide(e, factors[i]));\n\n            if (as_array) retval.push(term);else retval = _.add(retval, term);\n          }); //done\n\n          return retval;\n        } catch (e) {}\n\n        ;\n        return symbol;\n      }\n    },\n    degree: function (symbol, v, o) {\n      o = o || {\n        nd: [],\n        //numeric\n        sd: [],\n        //symbolic\n        depth: 0 //call depth\n\n      };\n\n      if (!v) {\n        var vars = variables(symbol); //The user must specify the variable for multivariate\n\n        if (vars.length > 1) throw new Error('You must specify the variable for multivariate polynomials!'); //if it's empty then we're dealing with a constant\n\n        if (vars.length === 0) return new Symbol(0); //assume the variable for univariate\n\n        v = _.parse(vars[0]);\n      } //store the group\n\n\n      var g = symbol.group; //we're going to trust the user and assume no EX. Calling isPoly \n      //would eliminate this but no sense in checking twice. \n\n      if (symbol.isComposite()) {\n        symbol = symbol.clone();\n        symbol.distributeExponent();\n        symbol.each(function (x) {\n          o.depth++; //mark a depth increase\n\n          __.degree(x, v, o);\n\n          o.depth--; //we're back\n        });\n      } else if (symbol.group === CB) {\n        symbol.each(function (x) {\n          o.depth++;\n\n          __.degree(x, v, o);\n\n          o.depth++;\n        });\n      } else if (g === EX && symbol.value === v.value) {\n        o.sd.push(symbol.power.clone());\n      } else if (g === S && symbol.value === v.value) {\n        o.nd.push(_.parse(symbol.power));\n      } else o.nd.push(new Symbol(0)); //get the max out of the array\n\n\n      var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n\n      if (o.depth === 0 && o.sd.length > 0) {\n        if (deg !== undefined) o.sd.unshift(deg);\n        return _.symfunction('max', o.sd);\n      }\n\n      if (!core.Utils.isSymbol(deg)) deg = _.parse(deg); //return the degree\n\n      return deg;\n    },\n\n    /**\r\n     * Attempts to complete the square of a polynomial\r\n     * @param {type} symbol\r\n     * @param {type} v\r\n     * @param {type} raw\r\n     * @throws {Error} \r\n     * @returns {Object|Symbol[]}\r\n     */\n    sqComplete: function (symbol, v, raw) {\n      if (!core.Utils.isSymbol(v)) v = _.parse(v);\n\n      var stop = function (msg) {\n        msg = msg || 'Stopping';\n        throw new core.exceptions.ValueLimitExceededError(msg);\n      }; //if not CP then nothing to do\n\n\n      if (!symbol.isPoly()) stop('Must be a polynomial!'); //declare vars\n\n      var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n      br = core.Utils.inBrackets; //make a copy\n\n      symbol = symbol.clone();\n      deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n      //must be in form ax^2 +/- bx +/- c\n\n      if (!deg.equals(2)) stop('Cannot complete square for degree ' + deg); //get the coeffs\n\n      coeffs = core.Algebra.coeffs(symbol, v);\n      a = coeffs[2]; //store the sign\n\n      sign = coeffs[1].sign(); //divide the linear term by two and square it\n\n      b = _.divide(coeffs[1], new Symbol(2)); //add the difference to the constant\n\n      c = _.pow(b.clone(), new Symbol(2));\n      if (raw) return [a, b, d];\n      sqrt_a = math.sqrt(a);\n      e = _.divide(math.sqrt(c), sqrt_a.clone()); //calculate d which is the constant\n\n      d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2))); //compute the square part\n\n      sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\n      return {\n        a: sym,\n        c: d,\n        f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n      };\n    },\n    Simplify: {\n      strip: function (symbol) {\n        var c = _.parse(symbol.multiplier);\n\n        symbol.toUnitMultiplier();\n\n        var p = _.parse(symbol.power);\n\n        symbol.toLinear();\n        return [c, p, symbol];\n      },\n      unstrip: function (cp, symbol) {\n        var c = cp[0];\n        var p = cp[1];\n        return _.pow(_.multiply(c, symbol), p);\n      },\n      complexSimp: function (num, den) {\n        var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n        r1 = num.realpart();\n        i1 = num.imagpart();\n        r2 = den.realpart();\n        i2 = den.imagpart(); //apply complex arithmatic rule\n\n        ac = _.multiply(r1.clone(), r2.clone());\n        bd = _.multiply(i1.clone(), i2.clone());\n        bc = _.multiply(r2.clone(), i1);\n        ad = _.multiply(r1, i2.clone());\n        cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n        return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n      },\n      trigSimp: function (symbol) {\n        symbol = symbol.clone(); //remove power and multiplier\n\n        var sym_array = __.Simplify.strip(symbol);\n\n        symbol = sym_array.pop(); //the default return value is the symbol\n\n        var retval = symbol.clone(); //rewrite the symbol\n\n        if (symbol.group === CP) {\n          var sym = new Symbol(0);\n          symbol.each(function (x) {\n            //rewrite the function\n            var tr = __.Simplify.trigSimp(x.fnTransform());\n\n            sym = _.add(sym, tr);\n          }, true); //put back the power and multiplier and return\n\n          retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n        } else if (symbol.group === CB) {\n          //try for tangent\n          var n = symbol.getNum();\n          var d = symbol.getDenom();\n\n          if (n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n          }\n\n          if (retval.group === CB) {\n            var t = new Symbol(1);\n            retval.each(function (x) {\n              if (x.fname === 'tan') {\n                x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n              }\n\n              t = _.multiply(t, x);\n            });\n            retval = t;\n          }\n        }\n\n        retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n        return retval;\n      },\n      fracSimp: function (symbol) {\n        //try a quick simplify of imaginary numbers\n        var den = symbol.getDenom();\n        var num = symbol.getNum();\n        if (num.isImaginary() && den.isImaginary()) symbol = __.Simplify.complexSimp(num, den);\n\n        if (symbol.isComposite()) {\n          var symbols = symbol.collectSymbols(); //assumption 1.\n          //since it's a composite, it has a length of at least 1\n\n          var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\n          a = symbols.pop(); //grab the first symbol\n          //loop through each term and make denominator common\n\n          while (symbols.length) {\n            b = symbols.pop(); //grab the second symbol\n\n            d1 = _.parse(a.getDenom());\n            d2 = _.parse(b.getDenom());\n            n1 = a.getNum();\n            n2 = b.getNum();\n            c = _.multiply(d1.clone(), d2.clone());\n            x = _.multiply(n1, d2);\n            y = _.multiply(n2, d1);\n            a = _.divide(_.add(x, y), c);\n          }\n\n          den = _.expand(a.getDenom());\n          num = _.expand(a.getNum()); //simplify imaginary\n\n          if (num.isImaginary() && den.isImaginary()) {\n            retval = __.Simplify.complexSimp(num, den);\n          } else {\n            retval = _.divide(num, den);\n          } //we've already hit the simplest form so return that\n\n\n          if (retval.equals(symbol)) return retval; //otherwise simplify it some more\n\n          return __.Simplify.simplify(retval);\n        }\n\n        return symbol;\n      },\n      simplify: function (symbol) {\n        //remove the multiplier to make calculation easier;\n        var sym_array = __.Simplify.strip(symbol);\n\n        symbol = sym_array.pop(); //remove gcd from denominator\n\n        symbol = __.Simplify.fracSimp(symbol); //nothing more to do\n\n        if (symbol.isConstant() || symbol.group === core.groups.S) {\n          sym_array.push(symbol);\n          return __.Simplify.unstrip(sym_array, symbol);\n        }\n\n        var simplified;\n        symbol = symbol.clone(); //make a copy\n        ////1. Try cos(x)^2+sin(x)^2\n\n        simplified = __.Simplify.trigSimp(symbol); //first go for the \"cheapest\" simplification which may eliminate \n        //your problems right away. factor -> evaluate. Remember\n        //that there's no need to expand since factor already does that\n\n        simplified = __.Factor.factor(simplified); //If the simplfied is a sum then we can make a few more simplifications\n        //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n\n        if (simplified.group === core.groups.CP && simplified.isLinear()) {\n          var r = new Symbol(0); //return the sum of simplifications\n\n          simplified.each(function (x) {\n            var s = __.Simplify.simplify(x);\n\n            r = _.add(r, s);\n          });\n          simplified = r;\n        } //place back multiplier and return\n\n\n        return __.Simplify.unstrip(sym_array, evaluate(simplified));\n      }\n    },\n    Classes: {\n      Polynomial: Polynomial,\n      Factors: Factors,\n      MVTerm: MVTerm\n    }\n  };\n\n  nerdamer.useAlgebraDiv = function () {\n    var divide = __.divideFn = _.divide;\n    var calls = 0; //keep track of how many calls were made\n\n    _.divide = function (a, b) {\n      calls++;\n      var ans;\n      if (calls === 1) //check if this is the first call. If it is use algebra divide\n        ans = core.Algebra.divide(a, b);else //otherwise use parser divide\n        ans = divide(a, b);\n      calls = 0; //reset the number of calls back to none\n\n      return ans;\n    };\n  };\n\n  nerdamer.useParserDiv = function () {\n    if (__.divideFn) _.divide = __.divideFn;\n    delete __.divideFn;\n  };\n\n  nerdamer.register([{\n    name: 'factor',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Factor.factor;\n    }\n  }, {\n    name: 'simplify',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Simplify.simplify;\n    }\n  }, {\n    name: 'gcd',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.gcd;\n    }\n  }, {\n    name: 'lcm',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.lcm;\n    }\n  }, {\n    name: 'roots',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.roots;\n    }\n  }, {\n    name: 'divide',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.divide;\n    }\n  }, {\n    name: 'div',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.div;\n    }\n  }, {\n    name: 'partfrac',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.PartFrac.partfrac;\n    }\n  }, {\n    name: 'deg',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.degree;\n    }\n  }, {\n    name: 'coeffs',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function () {\n        var coeffs = __.coeffs.apply(__, arguments);\n\n        return new core.Vector(coeffs);\n      };\n\n      return f;\n    }\n  }, {\n    name: 'line',\n    visible: true,\n    numargs: [2, 3],\n    build: function () {\n      return __.line;\n    }\n  }, {\n    name: 'sqcomp',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function (x, v) {\n        try {\n          v = v || variables(x)[0];\n\n          var sq = __.sqComplete(x.clone(), v);\n\n          return sq.f;\n        } catch (e) {\n          return x;\n        }\n      };\n\n      return f;\n    }\n  }]);\n  nerdamer.api();\n})();","map":null,"metadata":{},"sourceType":"script"}