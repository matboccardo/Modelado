{"ast":null,"code":"/**\n * Created by mauricio on 5/11/15.\n */\n'use strict';\n\nvar constants = require('../constants');\n\nvar Interval = require('../interval');\n\nvar rmath = require('../round-math');\n\nvar utils = require('./utils');\n\nvar arithmetic = require('./arithmetic');\n/**\n * @mixin misc\n */\n\n\nvar misc = {};\n/**\n * Computes e^x where e is the mathematical constant equal to the base of the\n * natural logarithm\n * @example\n * Interval.exp(\n *   Interval(-1, 1)\n * )  // Interval(0.3679, 2.7183)\n * @param {Interval} x\n * @return {Interval}\n */\n\nmisc.exp = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return Interval(rmath.expLo(x.lo), rmath.expHi(x.hi));\n};\n/**\n * Computes the natural logarithm of x\n * @example\n * Interval.log(\n *   Interval(1, Math.exp(3))\n * )  // Interval(0, 3)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\nmisc.log = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  var l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : rmath.logLo(x.lo);\n  return Interval(l, rmath.logHi(x.hi));\n};\n/**\n * Alias for {@link misc.log}\n * @function\n */\n\n\nmisc.ln = misc.log;\nmisc.LOG_EXP_10 = misc.log(Interval(10, 10));\n/**\n * Computes the logarithm base 10 of x\n * @example\n * Interval.log10(\n *   Interva(1, 1000)\n * )  // Interval(0, 3)\n * @param {Interval} x\n * @return {Interval}\n */\n\nmisc.log10 = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return arithmetic.div(misc.log(x), misc.LOG_EXP_10);\n};\n\nmisc.LOG_EXP_2 = misc.log(Interval(2, 2));\n/**\n * Computes the logarithm base 2 of x\n * @example\n * Interval.log10(\n *   Interva(1, 8)\n * )  // Interval(0, 3)\n * @param {Interval} x\n * @return {Interval}\n */\n\nmisc.log2 = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return arithmetic.div(misc.log(x), misc.LOG_EXP_2);\n};\n/**\n * Computes an interval that has all the values of x and y, note that it may be\n * possible that values that don't belong to either x or y are included in the\n * interval that represents the hull\n *\n * @example\n * Interval.hull(\n *   Interval(-1, 1),\n *   Interval(5, 7)\n * )  // Interval(-1, 7)\n * @example\n * Interval.hull(\n *   Interval(-1, 1),\n *   Interval.EMPTY\n * )  // Interval(-1, 1)\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.hull = function (x, y) {\n  var badX = utils.isEmpty(x);\n  var badY = utils.isEmpty(y);\n\n  if (badX && badY) {\n    return constants.EMPTY;\n  } else if (badX) {\n    return y.clone();\n  } else if (badY) {\n    return x.clone();\n  } else {\n    return Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));\n  }\n};\n/**\n * Computes an interval that has all the values that belong to both x and y\n *\n * @example\n * Interval.intersection(\n *   Interval(-1, 1),\n *   Interval(0, 7)\n * )  // Interval(0, 1)\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.intersection = function (x, y) {\n  if (utils.isEmpty(x) || utils.isEmpty(y)) {\n    return constants.EMPTY;\n  }\n\n  var lo = Math.max(x.lo, y.lo);\n  var hi = Math.min(x.hi, y.hi);\n\n  if (lo <= hi) {\n    return Interval(lo, hi);\n  }\n\n  return constants.EMPTY;\n};\n/**\n * Computes an interval that has all the values that belong to both x and y,\n * the difference with {@link misc.hull} is that x and y must overlap to\n * compute the union\n * @example\n * Interval.union(\n *   Interval(-1, 1),\n *   Interval(5, 7)\n * )  // throws error\n * @example\n * Interval.union(\n *   Interval(-1, 1),\n *   Interval(1, 7)\n * )  // Interval(-1, 7)\n * @throws {Error} When x and y don't overlap\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.union = function (x, y) {\n  if (!utils.intervalsOverlap(x, y)) {\n    throw Error('Interval#union: intervals do not overlap');\n  }\n\n  return Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));\n};\n/**\n * Computes the difference between `x` and `y`, i.e. an interval with all the\n * values of `x` that are not in `y`\n * @example\n * Interval.difference(\n *   Interval(3, 5),\n *   Interval(4, 6)\n * )  // Interval(3, prev(4))\n * @example\n * Interval.difference(\n *   Interval(0, 3),\n *   Interval(0, 1)\n * )  // Interval(next(1), 3)\n * @example\n * Interval.difference(\n *   Interval(0, 1),\n *   Interval.WHOLE\n * )  // Interval.EMPTY\n * @example\n * Interval.difference(\n *   Interval(-Infinity, 0),\n *   Interval.WHOLE\n * )  // Interval.EMPTY\n * @throws {Error} When the difference creates multiple intervals\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.difference = function (x, y) {\n  if (utils.isEmpty(x) || utils.isWhole(y)) {\n    return constants.EMPTY;\n  }\n\n  if (utils.intervalsOverlap(x, y)) {\n    if (x.lo < y.lo && y.hi < x.hi) {\n      // difference creates multiple subsets\n      throw Error('Interval.difference: difference creates multiple intervals');\n    } // handle corner cases first\n\n\n    if (y.lo <= x.lo && y.hi === Infinity || y.hi >= x.hi && y.lo === -Infinity) {\n      return constants.EMPTY;\n    } // NOTE: empty interval is handled automatically\n    // e.g.\n    //\n    //    n = difference([0,1], [0,1]) // n = Interval(next(1), 1) = EMPTY\n    //    isEmpty(n) === true\n    //\n\n\n    if (y.lo <= x.lo) {\n      return Interval().halfOpenLeft(y.hi, x.hi);\n    } // y.hi >= x.hi\n\n\n    return Interval().halfOpenRight(x.lo, y.lo);\n  }\n\n  return Interval.clone(x);\n};\n/**\n * Computes the distance between the endpoints of the interval i.e.\n * `x.hi - x.lo`\n * @example\n * Interval.width(\n *   Interval(1, 2)\n * )  // 1\n * @example\n * Interval.width(\n *   Interval(-1, 1)\n * )  // 2\n * @example\n * Interval.width(\n *   Interval(1, 1)\n * )  // next(0) ~5e-324\n * @example\n * Interval.width(\n *   Interval.EMPTY\n * )  // 0\n * @param {Interval} x\n * @returns {number}\n */\n\n\nmisc.width = function (x) {\n  if (utils.isEmpty(x)) {\n    return 0;\n  }\n\n  return rmath.subHi(x.hi, x.lo);\n};\n/**\n * Alias for {@link misc.width}\n * @function\n */\n\n\nmisc.wid = misc.width;\n/**\n * Computes the absolute value of `x`\n * @example\n * Interval.abs(\n *   Interval(2, 3)\n * )  // Interval(2, 3)\n * @example\n * Interval.abs(\n *   Interval(-2, 3)\n * )  // Interval(2, 3)\n * @example\n * Interval.abs(\n *   Interval(-3, -2)\n * )  // Interval(2, 3)\n * @example\n * Interval.abs(\n *   Interval(-3, 2)\n * )  // Interval(0, 3)\n * @param {Interval} x\n * @return {Interval}\n */\n\nmisc.abs = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  if (x.lo >= 0) {\n    return Interval.clone(x);\n  }\n\n  if (x.hi <= 0) {\n    return arithmetic.negative(x);\n  }\n\n  return Interval(0, Math.max(-x.lo, x.hi));\n};\n/**\n * Computes an interval with the maximum values for each endpoint based on `x`\n * and `y`\n * @example\n * Interval.max(\n *   Interval(0, 3),\n *   Interval(1, 2)\n * )  // Interval(1, 3)\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.max = function (x, y) {\n  var badX = utils.isEmpty(x);\n  var badY = utils.isEmpty(y);\n\n  if (badX && badY) {\n    return constants.EMPTY;\n  } else if (badX) {\n    return y.clone();\n  } else if (badY) {\n    return x.clone();\n  } else {\n    return Interval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));\n  }\n};\n/**\n * Computes an interval with the minimum values for each endpoint based on `x`\n * and `y`\n * @example\n * Interval.min(\n *   Interval(0, 3),\n *   Interval(1, 2)\n * )  // Interval(0, 2)\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\n\nmisc.min = function (x, y) {\n  var badX = utils.isEmpty(x);\n  var badY = utils.isEmpty(y);\n\n  if (badX && badY) {\n    return constants.EMPTY;\n  } else if (badX) {\n    return y.clone();\n  } else if (badY) {\n    return x.clone();\n  } else {\n    return Interval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));\n  }\n};\n/**\n * Creates an interval equal to `x`, equivalent to `Interval().set(x.lo, x.hi)`\n * @example\n * Interval.clone(\n *   Interval(1, 2)\n * )  // Interval(1, 2)\n * @example\n * Interval.clone(\n *   Interval.EMPTY\n * )  // Interval.EMPTY\n * @param {Interval} x\n * @return {Interval}\n */\n\n\nmisc.clone = function (x) {\n  // no bound checking\n  return Interval().set(x.lo, x.hi);\n};\n\nmodule.exports = misc;","map":null,"metadata":{},"sourceType":"script"}