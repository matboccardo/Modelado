{"ast":null,"code":"// token types\nvar tokenType = require('./token-type');\n\nvar ESCAPES = {\n  'n': '\\n',\n  'f': '\\f',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '\\'': '\\'',\n  '\"': '\"'\n};\nvar DELIMITERS = {\n  ',': true,\n  '(': true,\n  ')': true,\n  '[': true,\n  ']': true,\n  ';': true,\n  // unary\n  '~': true,\n  // factorial\n  '!': true,\n  // arithmetic operators\n  '+': true,\n  '-': true,\n  '*': true,\n  '/': true,\n  '%': true,\n  '^': true,\n  '**': true,\n  // python power like\n  // misc operators\n  '|': true,\n  // bitwise or\n  '&': true,\n  // bitwise and\n  '^|': true,\n  // bitwise xor\n  '=': true,\n  ':': true,\n  '?': true,\n  '||': true,\n  // logical or\n  '&&': true,\n  // logical and\n  'xor': true,\n  // logical xor\n  // relational\n  '==': true,\n  '!=': true,\n  '===': true,\n  '!==': true,\n  '<': true,\n  '>': true,\n  '>=': true,\n  '<=': true,\n  // shifts\n  '>>>': true,\n  '<<': true,\n  '>>': true // helpers\n\n};\n\nfunction isDigit(c) {\n  return c >= '0' && c <= '9';\n}\n\nfunction isIdentifier(c) {\n  return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '$' || c === '_';\n}\n\nfunction isWhitespace(c) {\n  return c === ' ' || c === '\\r' || c === '\\t' || c === '\\n' || c === '\\v' || c === '\\u00A0';\n}\n\nfunction isDelimiter(str) {\n  return DELIMITERS[str];\n}\n\nfunction isQuote(c) {\n  return c === '\\'' || c === '\"';\n} // lexer\n\n\nfunction Lexer() {}\n\nLexer.prototype.throwError = function (message, index) {\n  index = typeof index === 'undefined' ? this.index : index;\n  var error = new Error(message + ' at index ' + index);\n  error.index = index;\n  error.description = message;\n  throw error;\n};\n\nLexer.prototype.lex = function (text) {\n  this.text = text;\n  this.index = 0;\n  this.tokens = [];\n\n  while (this.index < this.text.length) {\n    // skip whitespaces\n    while (isWhitespace(this.peek())) {\n      this.consume();\n    }\n\n    var c = this.peek();\n    var c2 = c + this.peek(1);\n    var c3 = c2 + this.peek(2); // order\n    // - delimiter of 3 characters\n    // - delimiter of 2 characters\n    // - delimiter of 1 character\n    // - number\n    // - variables, functions and named operators\n\n    if (isDelimiter(c3)) {\n      this.tokens.push({\n        type: tokenType.DELIMITER,\n        value: c3\n      });\n      this.consume();\n      this.consume();\n      this.consume();\n    } else if (isDelimiter(c2)) {\n      this.tokens.push({\n        type: tokenType.DELIMITER,\n        value: c2\n      });\n      this.consume();\n      this.consume();\n    } else if (isDelimiter(c)) {\n      this.tokens.push({\n        type: tokenType.DELIMITER,\n        value: c\n      });\n      this.consume();\n    } else if (isDigit(c) || c === '.' && isDigit(this.peek(1))) {\n      this.tokens.push({\n        type: tokenType.NUMBER,\n        value: this.readNumber()\n      });\n    } else if (isQuote(c)) {\n      this.tokens.push({\n        type: tokenType.STRING,\n        value: this.readString()\n      });\n    } else if (isIdentifier(c)) {\n      this.tokens.push({\n        type: tokenType.SYMBOL,\n        value: this.readIdentifier()\n      });\n    } else {\n      this.throwError('unexpected character ' + c);\n    }\n  } // end token\n\n\n  this.tokens.push({\n    type: tokenType.EOF\n  });\n  return this.tokens;\n};\n\nLexer.prototype.peek = function (nth) {\n  nth = nth || 0;\n\n  if (this.index + nth >= this.text.length) {\n    return;\n  }\n\n  return this.text.charAt(this.index + nth);\n};\n\nLexer.prototype.consume = function () {\n  var current = this.peek();\n  this.index += 1;\n  return current;\n};\n\nLexer.prototype.readNumber = function () {\n  var number = '';\n\n  if (this.peek() === '.') {\n    number += this.consume();\n\n    if (!isDigit(this.peek())) {\n      this.throwError('number expected');\n    }\n  } else {\n    while (isDigit(this.peek())) {\n      number += this.consume();\n    }\n\n    if (this.peek() === '.') {\n      number += this.consume();\n    }\n  } // numbers after the decimal dot\n\n\n  while (isDigit(this.peek())) {\n    number += this.consume();\n  } // exponent if available\n\n\n  if (this.peek() === 'e' || this.peek() === 'E') {\n    number += this.consume();\n\n    if (!(isDigit(this.peek()) || this.peek() === '+' || this.peek() === '-')) {\n      this.throwError();\n    }\n\n    if (this.peek() === '+' || this.peek() === '-') {\n      number += this.consume();\n    }\n\n    if (!isDigit(this.peek())) {\n      this.throwError('number expected');\n    }\n\n    while (isDigit(this.peek())) {\n      number += this.consume();\n    }\n  }\n\n  return number;\n};\n\nLexer.prototype.readIdentifier = function () {\n  var text = '';\n\n  while (isIdentifier(this.peek()) || isDigit(this.peek())) {\n    text += this.consume();\n  }\n\n  return text;\n};\n\nLexer.prototype.readString = function () {\n  var quote = this.consume();\n  var string = '';\n  var escape;\n\n  while (true) {\n    var c = this.consume();\n\n    if (!c) {\n      this.throwError('string is not closed');\n    }\n\n    if (escape) {\n      if (c === 'u') {\n        var hex = this.text.substring(this.index + 1, this.index + 5);\n\n        if (!hex.match(/[\\da-f]{4}/i)) {\n          this.throwError('invalid unicode escape');\n        }\n\n        this.index += 4;\n        string += String.fromCharCode(parseInt(hex, 16));\n      } else {\n        var replacement = ESCAPES[c];\n\n        if (replacement) {\n          string += replacement;\n        } else {\n          string += c;\n        }\n      }\n\n      escape = false;\n    } else if (c === quote) {\n      break;\n    } else if (c === '\\\\') {\n      escape = true;\n    } else {\n      string += c;\n    }\n  }\n\n  return string;\n};\n\nmodule.exports = Lexer;","map":null,"metadata":{},"sourceType":"script"}