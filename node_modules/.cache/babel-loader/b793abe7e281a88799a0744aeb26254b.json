{"ast":null,"code":"'use strict';\n\nvar extend = require('extend');\n\nvar types = {\n  ArrayNode: require('./node/ArrayNode'),\n  AssignmentNode: require('./node/AssignmentNode'),\n  ConditionalNode: require('./node/ConditionalNode'),\n  ConstantNode: require('./node/ConstantNode'),\n  FunctionNode: require('./node/FunctionNode'),\n  OperatorNode: require('./node/OperatorNode'),\n  SymbolNode: require('./node/SymbolNode'),\n  UnaryNode: require('./node/UnaryNode')\n};\n\nvar Interpreter = function (owner, options) {\n  this.owner = owner;\n  this.options = extend({\n    factory: 'ns.factory',\n    raw: false,\n    rawArrayExpressionElements: true,\n    rawCallExpressionElements: false\n  }, options);\n};\n\nextend(Interpreter.prototype, types); // main method which decides which expression to call\n\nInterpreter.prototype.next = function (node) {\n  if (!(node.type in this)) {\n    throw new TypeError('the node type ' + node.type + ' is not implemented');\n  }\n\n  return this[node.type](node);\n};\n\nInterpreter.prototype.rawify = function (test, fn) {\n  var oldRaw = this.options.raw;\n\n  if (test) {\n    this.options.raw = true;\n  }\n\n  fn();\n\n  if (test) {\n    this.options.raw = oldRaw;\n  }\n};\n\nmodule.exports = Interpreter;","map":null,"metadata":{},"sourceType":"script"}