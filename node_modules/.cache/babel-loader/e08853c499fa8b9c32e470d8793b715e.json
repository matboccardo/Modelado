{"ast":null,"code":"/**\n * Created by mauricio on 5/11/15.\n */\n'use strict';\n\nvar isSafeInteger = require('is-safe-integer');\n\nvar Interval = require('../interval');\n\nvar rmath = require('../round-math');\n\nvar utils = require('./utils');\n\nvar arithmetic = require('./arithmetic');\n\nvar constants = require('../constants');\n/**\n * @mixin algebra\n */\n\n\nvar algebra = {};\n/**\n * Computes x mod y (x - k * y)\n * @example\n * Interval.fmod(\n *   Interval(5.3, 5.3),\n *   Interval(2, 2)\n * ) // Interval(1.3, 1.3)\n *\n * @example\n * Interval.fmod(\n *   Interval(5, 7),\n *   Interval(2, 3)\n * ) // Interval(2, 5)\n * // explanation: [5, 7] - [2, 3] * 1 = [2, 5]\n *\n * @param {Interval} x\n * @param {Interval} y\n * @return {Interval}\n */\n\nalgebra.fmod = function (x, y) {\n  if (utils.isEmpty(x) || utils.isEmpty(y)) {\n    return constants.EMPTY;\n  }\n\n  var yb = x.lo < 0 ? y.lo : y.hi;\n  var n = x.lo / yb;\n  if (n < 0) n = Math.ceil(n);else n = Math.floor(n); // x mod y = x - n * y\n\n  return arithmetic.sub(x, arithmetic.mul(y, Interval(n)));\n};\n/**\n * Computes 1 / x\n *\n * @example\n * Interval.multiplicativeInverse(\n *   Interval(2, 6)\n * )  // Interval(1/6, 1/2)\n * @example\n * Interval.multiplicativeInverse(\n *   Interval(-6, -2)\n * )  // Interval(-1/2, -1/6)\n * @param {Interval} x\n * @returns {Interval}\n */\n\n\nalgebra.multiplicativeInverse = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  if (utils.zeroIn(x)) {\n    if (x.lo !== 0) {\n      if (x.hi !== 0) {\n        // [negative, positive]\n        return constants.WHOLE;\n      } else {\n        // [negative, zero]\n        return Interval(Number.NEGATIVE_INFINITY, rmath.divHi(1, x.lo));\n      }\n    } else {\n      if (x.hi !== 0) {\n        // [zero, positive]\n        return Interval(rmath.divLo(1, x.hi), Number.POSITIVE_INFINITY);\n      } else {\n        // [zero, zero]\n        return constants.EMPTY;\n      }\n    }\n  } else {\n    // [positive, positive]\n    return Interval(rmath.divLo(1, x.hi), rmath.divHi(1, x.lo));\n  }\n};\n/**\n * Computes x^power given that `power` is an integer\n *\n * If `power` is an Interval it must be a singletonInterval i.e. x^x is not\n * supported yet\n *\n * If `power` is a rational number use {@link arithmetic.nthRoot} instead\n *\n * @example\n * // 2^{-2}\n * Interval.pow(\n *   Interval(2, 2),\n *   -2\n * )  // Interval(1/4, 1/4)\n * @example\n * // [2,3]^2\n * Interval.pow(\n *   Interval(2, 3),\n *   2\n * )  // Interval(4, 9)\n * @example\n * // [2,3]^0\n * Interval.pow(\n *   Interval(2, 3),\n *   0\n * )  // Interval(1, 1)\n * @example\n * // with a singleton interval\n * Interval.pow(\n *   Interval(2, 3),\n *   Interval(2)\n * )  // Interval(4, 9)\n * @param {Interval} x\n * @param {number|Interval} power A number of a singleton interval\n * @returns {Interval}\n */\n\n\nalgebra.pow = function (x, power) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  if (typeof power === 'object') {\n    if (!utils.isSingleton(power)) {\n      return constants.EMPTY;\n    }\n\n    power = power.lo;\n  }\n\n  if (power === 0) {\n    if (x.lo === 0 && x.hi === 0) {\n      // 0^0\n      return constants.EMPTY;\n    } else {\n      // x^0\n      return constants.ONE;\n    }\n  } else if (power < 0) {\n    // compute [1 / x]^-power if power is negative\n    return algebra.pow(algebra.multiplicativeInverse(x), -power);\n  } // power > 0\n\n\n  if (isSafeInteger(power)) {\n    // power is integer\n    if (x.hi < 0) {\n      // [negative, negative]\n      // assume that power is even so the operation will yield a positive interval\n      // if not then just switch the sign and order of the interval bounds\n      var yl = rmath.powLo(-x.hi, power);\n      var yh = rmath.powHi(-x.lo, power);\n\n      if (power & 1) {\n        // odd power\n        return Interval(-yh, -yl);\n      } else {\n        // even power\n        return Interval(yl, yh);\n      }\n    } else if (x.lo < 0) {\n      // [negative, positive]\n      if (power & 1) {\n        return Interval(-rmath.powLo(-x.lo, power), rmath.powHi(x.hi, power));\n      } else {\n        // even power means that any negative number will be zero (min value = 0)\n        // and the max value will be the max of x.lo^power, x.hi^power\n        return Interval(0, rmath.powHi(Math.max(-x.lo, x.hi), power));\n      }\n    } else {\n      // [positive, positive]\n      return Interval(rmath.powLo(x.lo, power), rmath.powHi(x.hi, power));\n    }\n  } else {\n    console.warn('power is not an integer, you should use nth-root instead, returning an empty interval');\n    return constants.EMPTY;\n  }\n};\n/**\n * Computes sqrt(x), alias for `nthRoot(x, 2)`\n * @example\n * Interval.sqrt(\n *   Interval(4, 9)\n * ) // Interval(prev(2), next(3))\n * @param {Interval} x\n * @returns {Interval}\n */\n\n\nalgebra.sqrt = function (x) {\n  return algebra.nthRoot(x, 2);\n};\n/**\n * Computes x^(1/n)\n *\n * @example\n * Interval.nthRoot(\n *   Interval(-27, -8),\n *   3\n * ) // Interval(-3, -2)\n * @param {Interval} x\n * @param {number|Interval} n A number or a singleton interval\n * @return {Interval}\n */\n\n\nalgebra.nthRoot = function (x, n) {\n  if (utils.isEmpty(x) || n < 0) {\n    // compute 1 / x^-power if power is negative\n    return constants.EMPTY;\n  } // singleton interval check\n\n\n  if (typeof n === 'object') {\n    if (!utils.isSingleton(n)) {\n      return constants.EMPTY;\n    }\n\n    n = n.lo;\n  }\n\n  var power = 1 / n;\n\n  if (x.hi < 0) {\n    // [negative, negative]\n    if (isSafeInteger(n) & (n & 1)) {\n      // when n is odd we can always take the nth root\n      var yl = rmath.powHi(-x.lo, power);\n      var yh = rmath.powLo(-x.hi, power);\n      return Interval(-yl, -yh);\n    } // n is not odd therefore there's no nth root\n\n\n    return Interval.EMPTY;\n  } else if (x.lo < 0) {\n    // [negative, positive]\n    var yp = rmath.powHi(x.hi, power);\n\n    if (isSafeInteger(n) & (n & 1)) {\n      // nth root of x.lo is possible (n is odd)\n      var yn = -rmath.powHi(-x.lo, power);\n      return Interval(yn, yp);\n    }\n\n    return Interval(0, yp);\n  } else {\n    // [positive, positive]\n    return Interval(rmath.powLo(x.lo, power), rmath.powHi(x.hi, power));\n  }\n};\n\nmodule.exports = algebra;","map":null,"metadata":{},"sourceType":"script"}