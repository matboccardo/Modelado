{"ast":null,"code":"/* global module */\n\n/*\r\n* Author : Martin Donk\r\n* Website : http://www.nerdamer.com\r\n* Email : martin.r.donk@gmail.com\r\n* Source : https://github.com/jiggzson/nerdamer\r\n*/\nif (typeof module !== 'undefined' && typeof nerdamer === 'undefined') {\n  nerdamer = require('./nerdamer.core.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Frac = core.Frac,\n      Settings = core.Settings,\n      isSymbol = core.Utils.isSymbol,\n      FN = core.groups.FN,\n      Symbol = core.Symbol,\n      text = core.Utils.text,\n      inBrackets = core.Utils.inBrackets,\n      isInt = core.Utils.isInt,\n      format = core.Utils.format,\n      even = core.Utils.even,\n      evaluate = core.Utils.evaluate,\n      N = core.groups.N,\n      S = core.groups.S,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      EX = core.groups.EX,\n      P = core.groups.P,\n      LOG = 'log',\n      EXP = 'exp',\n      ABS = 'abs',\n      SQRT = 'sqrt',\n      SIN = 'sin',\n      COS = 'cos',\n      TAN = 'tan',\n      SEC = 'sec',\n      CSC = 'csc',\n      COT = 'cot',\n      ASIN = 'asin',\n      ACOS = 'acos',\n      ATAN = 'atan',\n      ASEC = 'asec',\n      ACSC = 'acsc',\n      ACOT = 'acot',\n      SINH = 'sinh',\n      COSH = 'cosh',\n      TANH = 'tanh',\n      CSCH = 'csch',\n      SECH = 'sech',\n      COTH = 'coth',\n      ASECH = 'asech',\n      ACSCH = 'acsch',\n      ACOTH = 'acoth'; //custom errors\n\n  function NoIntegralFound(msg) {\n    this.message = msg || \"\";\n  }\n\n  NoIntegralFound.prototype = new Error(); //Preparations\n\n  Symbol.prototype.hasIntegral = function () {\n    return this.containsFunction('integrate');\n  }; //transforms a function\n\n\n  Symbol.prototype.fnTransform = function () {\n    if (this.group !== FN) return this;\n    var retval,\n        a = this.args[0];\n    var m = new Symbol(this.multiplier);\n    var sym = this.clone().toUnitMultiplier();\n\n    if (this.isLinear()) {\n      switch (this.fname) {\n        case SINH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n          break;\n\n        case TAN:\n          retval = _.parse(format('sin({0})/cos({0})', a));\n          break;\n\n        case CSC:\n          retval = _.parse(format('1/sin({0})', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('1/cos({0})', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.power.equals(2)) {\n      switch (this.fname) {\n        case SIN:\n          retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n          break;\n\n        case COS:\n          retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n          break;\n\n        case TAN:\n          //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n          retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case SINH:\n          retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.fname === SEC) {\n      retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === CSC) {\n      retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === TAN) {\n      if (this.power.lessThan(0)) {\n        retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n      } else {\n        retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n      }\n    } else if (this.fname === SIN && this.power.lessThan(0)) {\n      retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === COS && this.power.lessThan(0)) {\n      retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === SIN && this.power.equals(3)) {\n      retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n    } else if (this.fname === COS && this.power.equals(3)) {\n      retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n    } else retval = sym;\n\n    return _.multiply(retval, m);\n  };\n\n  core.Expression.prototype.hasIntegral = function () {\n    return this.symbol.hasIntegral();\n  };\n  /**\r\n   * Attempts to rewrite a symbol under one common denominator\r\n   * @param {Symbol} symbol \r\n   */\n\n\n  core.Utils.toCommonDenominator = function (symbol) {\n    //transform x/a+x -> (ax+x)/a\n    if (symbol.isComposite() && symbol.isLinear()) {\n      var m = new Symbol(symbol.multiplier);\n      var denominator = new Symbol(1);\n      var numerator = new Symbol(0);\n      symbol.each(function (x) {\n        denominator = _.multiply(denominator, x.getDenom());\n      }, true); //remove the denomitor in each term\n\n      symbol.each(function (x) {\n        var num = x.getNum();\n        var den = x.getDenom();\n\n        var factor = _.multiply(num, _.divide(denominator.clone(), den));\n\n        numerator = _.add(numerator, factor);\n      });\n\n      var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n\n      return retval;\n    }\n\n    return symbol;\n  }; //A function to check if a function name is an inverse trig function\n\n\n  core.Utils.in_inverse_trig = function (x) {\n    var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\n    return inv_trig_fns.indexOf(x) !== -1;\n  }; //A function to check if a function name is a trig function\n\n\n  core.Utils.in_trig = function (x) {\n    var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  core.Utils.in_htrig = function (x) {\n    var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  var all_functions = core.Utils.all_functions = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) if (arr[i].group !== FN) return false;\n\n    return true;\n  },\n      cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n  },\n      cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\n    //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n    //we technically know how to do this transform but more is needed for correct output\n    if (Number(symbol2.power) !== 1) return _.multiply(symbol1, symbol2);\n    var a;\n    a = symbol1.args[0];\n    return _.parse(format('(sin(2*({0})))/2', a));\n  },\n      sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n  },\n      trigTransform = core.Utils.trigTransform = function (arr) {\n    var map = {},\n        symbol,\n        t,\n        retval = new Symbol(1);\n\n    for (var i = 0, l = arr.length; i < l; i++) {\n      symbol = arr[i];\n\n      if (symbol.group === FN) {\n        var fname = symbol.fname;\n\n        if (fname === COS && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[SIN]);\n          } else {\n            t = cosAsinAtransform(symbol, map[SIN]);\n          }\n\n          delete map[SIN];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[COS]) {\n          if (map[COS].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[COS]);\n          } else {\n            t = cosAsinAtransform(symbol, map[COS]);\n          }\n\n          delete map[COS];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = sinAsinBtransform(symbol, map[SIN]);\n            delete map[SIN];\n          } else {\n            //This should actually be redundant code but let's put just in case\n            t = _.multiply(symbol, map[SIN]);\n            delete map[SIN];\n          }\n\n          retval = t;\n        } else map[fname] = symbol;\n      } else retval = _.multiply(retval, symbol);\n    } //put back the remaining functions\n\n\n    for (var x in map) retval = _.multiply(retval, map[x]);\n\n    return retval;\n  };\n\n  core.Settings.integration_depth = 10;\n\n  var __ = core.Calculus = {\n    version: '1.4.5',\n    sum: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        start = Number(start);\n        end = Number(end);\n        retval = core.Utils.block(modifier, function () {\n          var f = fn.text(),\n              subs = {\n            '~': true\n          },\n              //lock subs. Is this even being used?\n          retval = new core.Symbol(0);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n\n            var ans = _.parse(f, subs);\n\n            retval = _.add(retval, ans);\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('sum', arguments);\n      }\n\n      return retval;\n    },\n    product: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        retval = core.Utils.block(modifier, function () {\n          start = Number(start);\n          end = Number(end.multiplier);\n          var f = fn.text(),\n              subs = {},\n              retval = new core.Symbol(1);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            retval = _.multiply(retval, _.parse(f, subs));\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('product', arguments);\n      }\n\n      return retval;\n    },\n    diff: function (symbol, wrt, nth) {\n      if (core.Utils.isVector(symbol)) {\n        var vector = new core.Vector([]);\n        symbol.each(function (x) {\n          vector.elements.push(__.diff(x, wrt));\n        });\n        return vector;\n      }\n\n      var d = isSymbol(wrt) ? wrt.text() : wrt; //the nth derivative\n\n      nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n      if (d === undefined) d = core.Utils.variables(symbol)[0]; //unwrap sqrt\n\n      if (symbol.group === FN && symbol.fname === SQRT) {\n        var s = symbol.args[0],\n            sp = symbol.power.clone(); //these groups go to zero anyway so why waste time?\n\n        if (s.group !== N || s.group !== P) {\n          s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n          s.multiplier = s.multiplier.multiply(symbol.multiplier);\n        }\n\n        symbol = s;\n      }\n\n      if (symbol.group === FN && !isSymbol(symbol.power)) {\n        var a = derive(symbol);\n\n        var b = __.diff(symbol.args[0].clone(), d);\n\n        symbol = _.multiply(a, b); //chain rule\n      } else {\n        symbol = derive(symbol);\n      }\n\n      if (nth > 1) {\n        nth--;\n        symbol = __.diff(symbol, wrt, nth);\n      }\n\n      return symbol; // Equivalent to \"derivative of the outside\".\n\n      function polydiff(symbol) {\n        if (symbol.value === d || symbol.contains(d, true)) {\n          symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n          symbol.power = symbol.power.subtract(new Frac(1));\n\n          if (symbol.power.equals(0)) {\n            symbol = Symbol(symbol.multiplier);\n          }\n        }\n\n        return symbol;\n      }\n\n      ;\n\n      function derive(symbol) {\n        var g = symbol.group,\n            a,\n            b,\n            cp;\n\n        if (g === N || g === S && symbol.value !== d || g === P) {\n          symbol = Symbol(0);\n        } else if (g === S) {\n          symbol = polydiff(symbol);\n        } else if (g === CB) {\n          var m = symbol.multiplier.clone();\n          symbol.toUnitMultiplier();\n\n          var retval = _.multiply(product_rule(symbol), polydiff(symbol));\n\n          retval.multiplier = retval.multiplier.multiply(m);\n          return retval;\n        } else if (g === FN && symbol.power.equals(1)) {\n          // Table of known derivatives\n          switch (symbol.fname) {\n            case LOG:\n              cp = symbol.clone();\n              symbol = symbol.args[0].clone(); //get the arguments\n\n              symbol.power = symbol.power.negate();\n              symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\n              break;\n\n            case COS:\n              //cos -> -sin\n              symbol.fname = SIN;\n              symbol.multiplier.negate();\n              break;\n\n            case SIN:\n              //sin -> cos\n              symbol.fname = COS;\n              break;\n\n            case TAN:\n              //tan -> sec^2\n              symbol.fname = SEC;\n              symbol.power = new Frac(2);\n              break;\n\n            case SEC:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, TAN);\n              break;\n\n            case CSC:\n              symbol = qdiff(symbol, '-cot');\n              break;\n\n            case COT:\n              symbol.fname = CSC;\n              symbol.multiplier.negate();\n              symbol.power = new Frac(2);\n              break;\n\n            case ASIN:\n              symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ACOS:\n              symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ATAN:\n              symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ABS:\n              m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier(); //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n              //this should really be readdressed soon\n\n              b = symbol.args[0].clone();\n              b.toUnitMultiplier();\n              symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\n              symbol.multiplier = m;\n              break;\n\n            case 'parens':\n              //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n              //1*g'\n              symbol = Symbol(1);\n              break;\n\n            case 'cosh':\n              //cosh -> -sinh\n              symbol.fname = 'sinh';\n              break;\n\n            case 'sinh':\n              //sinh -> cosh\n              symbol.fname = 'cosh';\n              break;\n\n            case TANH:\n              //tanh -> sech^2\n              symbol.fname = SECH;\n              symbol.power = new Frac(2);\n              break;\n\n            case SECH:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, '-tanh');\n              break;\n\n            case CSCH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\n              break;\n\n            case COTH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-csch(' + arg + ')^2');\n              break;\n\n            case 'asinh':\n              symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'acosh':\n              symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'atanh':\n              symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ASECH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\n              break;\n\n            case ACOTH:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\n              break;\n\n            case ACSCH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\n              break;\n\n            case ASEC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACSC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACOT:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\n              break;\n\n            case 'S':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'C':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'Si':\n              var arg = symbol.args[0];\n              symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Shi':\n              var arg = symbol.args[0];\n              symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ci':\n              var arg = symbol.args[0];\n              symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Chi':\n              var arg = symbol.args[0];\n              symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ei':\n              var arg = symbol.args[0];\n              symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Li':\n              var arg = symbol.args[0];\n              symbol = _.parse('1/log(' + arg + ')');\n              break;\n\n            case 'erf':\n              symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\n              break;\n\n            case 'atan2':\n              var x_ = String(symbol.args[0]),\n                  y_ = String(symbol.args[1]);\n              symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\n              break;\n\n            case 'sign':\n              symbol = new Symbol(0);\n              break;\n\n            case 'log10':\n              symbol = _.parse('1/((' + symbol.args[0] + ')*log(10))');\n              break;\n\n            default:\n              symbol = _.symfunction('diff', [symbol, wrt]);\n          }\n        } else if (g === EX || g === FN && isSymbol(symbol.power)) {\n          var value;\n\n          if (g === EX) {\n            value = symbol.value;\n          } else if (g === FN && symbol.contains(d)) {\n            value = symbol.fname + inBrackets(text(symbol.args[0]));\n          } else {\n            value = symbol.value + inBrackets(text(symbol.args[0]));\n          }\n\n          a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\n          b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\n          symbol = _.multiply(symbol, b);\n        } else if (g === FN && !symbol.power.equals(1)) {\n          b = symbol.clone();\n          b.toLinear();\n          b.toUnitMultiplier();\n          symbol = _.multiply(polydiff(symbol.clone()), derive(b));\n        } else if (g === CP || g === PL) {\n          var result = new Symbol(0);\n\n          for (var x in symbol.symbols) {\n            result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n          }\n\n          symbol = _.multiply(polydiff(symbol.clone()), result);\n        }\n\n        symbol.updateHash();\n        return symbol;\n      }\n\n      ;\n\n      function qdiff(symbol, val, altVal) {\n        return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\n      }\n\n      ;\n\n      function product_rule(symbol) {\n        //grab all the symbols within the CB symbol\n        var symbols = symbol.collectSymbols(),\n            result = new Symbol(0),\n            l = symbols.length; //loop over all the symbols\n\n        for (var i = 0; i < l; i++) {\n          var df = __.diff(symbols[i].clone(), d);\n\n          for (var j = 0; j < l; j++) {\n            //skip the symbol of which we just pulled the derivative\n            if (i !== j) {\n              //multiply out the remaining symbols\n              df = _.multiply(df, symbols[j].clone());\n            }\n          } //add the derivative to the result\n\n\n          result = _.add(result, df);\n        }\n\n        return result; //done\n      }\n\n      ;\n    },\n    integration: {\n      u_substitution: function (symbols, dx) {\n        function try_combo(a, b, f) {\n          var q = f ? f(a, b) : _.divide(a.clone(), __.diff(b, dx));\n          if (!q.contains(dx, true)) return q;\n          return null;\n        }\n\n        function do_fn_sub(fname, arg) {\n          var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n\n          subbed = subbed.sub(new Symbol(u), arg);\n          subbed.updateHash();\n          return subbed;\n        }\n\n        var a = symbols[0].clone(),\n            b = symbols[1].clone(),\n            g1 = a.group,\n            g2 = b.group,\n            //may cause problems if person is using this already. Will need\n        //to find algorithm for detecting conflict\n        u = '__u__',\n            Q;\n\n        if (g1 === FN && g2 !== FN) {\n          //e.g. 2*x*cos(x^2)\n          var arg = a.args[0];\n          Q = try_combo(b, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(a.fname, arg));\n          Q = try_combo(b, a);\n\n          if (Q) {\n            return __.integration.poly_integrate(a);\n          }\n        } else if (g2 === FN && g1 !== FN) {\n          //e.g. 2*(x+1)*cos((x+1)^2\n          var arg = b.args[0];\n          Q = try_combo(a, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(b.fname, arg));\n        } else if (g1 === FN && g2 === FN) {\n          Q = try_combo(a.clone(), b.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(b.clone(), a.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n        } else if (g1 === EX && g2 !== EX) {\n          var p = a.power;\n          Q = try_combo(b, p.clone());\n\n          if (!Q) {\n            //one more try\n            var dc = __.integration.decompose_arg(p.clone(), dx); //consider the possibility of a^x^(n-1)*x^n dx\n\n\n            var xp = __.diff(dc[2].clone(), dx);\n\n            var dc2 = __.integration.decompose_arg(xp.clone(), dx); //if their powers equal, so if dx*p == b\n\n\n            if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n              var m = _.divide(dc[0].clone(), dc2[0].clone());\n\n              var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n\n              new_val = _.multiply(new_val, new Symbol(u));\n              return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n            }\n          }\n\n          var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n              retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n\n          return retval;\n        } else if (g2 === EX && g1 !== EX) {\n          var p = b.power;\n          Q = try_combo(a, p.clone());\n\n          var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n\n          return _.multiply(integrated.sub(new Symbol(u), p), Q);\n        } else if (a.isComposite() || b.isComposite()) {\n          var f = function (a, b) {\n            var A = core.Algebra.Factor.factor(a),\n                B = core.Algebra.Factor.factor(__.diff(b, dx));\n\n            var q = _.divide(A, B);\n\n            return q;\n          };\n\n          var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n              f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\n          Q = try_combo(f1.clone(), f2.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(f2.clone(), f1.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(a), Q);\n        }\n      },\n      //simple integration of a single polynomial x^(n+1)/(n+1)\n      poly_integrate: function (x) {\n        var p = x.power.toString(),\n            m = x.multiplier.toDecimal(),\n            s = x.toUnitMultiplier().toLinear();\n\n        if (Number(p) === -1) {\n          return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n        }\n\n        return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n      },\n      //If we're just spinning wheels we want to stop. This is why we \n      //wrap integration in a try catch block and call this to stop.\n      stop: function (msg) {\n        msg = msg || 'Unable to compute integral!';\n        core.Utils.warn(msg);\n        throw new NoIntegralFound(msg);\n      },\n      partial_fraction: function (input, dx, depth, opt) {\n        //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n        if (!isSymbol(dx)) dx = _.parse(dx);\n        var result, partial_fractions;\n        result = new Symbol(0);\n        partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n\n        if (partial_fractions.group === CB && partial_fractions.isLinear()) {\n          partial_fractions.each(function (x) {\n            result = _.add(result, __.integrate(x, dx, depth, opt));\n          });\n        } else {\n          result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n        }\n\n        return result;\n      },\n      get_udv: function (symbol) {\n        var parts = [[\n          /*L*/\n        ], [\n          /*I*/\n        ], [\n          /*A*/\n        ], [\n          /*T*/\n        ], [\n          /*E*/\n        ]]; //first we sort them \n\n        var setSymbol = function (x) {\n          var g = x.group;\n\n          if (g === FN) {\n            var fname = x.fname;\n            if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname)) parts[3].push(x);else if (core.Utils.in_inverse_trig(fname)) parts[1].push(x);else if (fname === LOG) parts[0].push(x);else {\n              __.integration.stop();\n            }\n          } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n            parts[2].push(x);\n          } else if (g === EX || x.isComposite() && !x.isLinear()) parts[4].push(x);else __.integration.stop();\n        };\n\n        if (symbol.group === CB) symbol.each(function (x) {\n          setSymbol(Symbol.unwrapSQRT(x, true));\n        });else setSymbol(symbol);\n        var u,\n            dv = new Symbol(1); //compile u and dv\n\n        for (var i = 0; i < 5; i++) {\n          var part = parts[i],\n              t,\n              l = part.length;\n\n          if (l > 0) {\n            if (l > 1) {\n              t = new Symbol(1);\n\n              for (var j = 0; j < l; j++) t = _.multiply(t, part[j].clone());\n            } else t = part[0].clone();\n\n            if (!u) {\n              u = t; //the first u encountered gets chosen\n\n              u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n            } else dv = _.multiply(dv, t); //everything else belongs to dv\n\n          }\n        }\n\n        return [u, dv];\n      },\n      trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\n        parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n        var b = parts[3],\n            ax = parts[2],\n            a = parts[0],\n            x = parts[1];\n\n        if (x.power.equals(2) && a.greaterThan(0)) {\n          //use tan(x)\n          var t = core.Utils.getU(symbol),\n              //get an appropriate u\n          u = _.parse(TAN + inBrackets(t)),\n              //u\n          du = _.parse(SEC + inBrackets(t) + '^2'),\n              //du\n          f = _.multiply(symbol.sub(x, u), du);\n\n          var integral = __.integrate(f, t, depth, opt).sub(u, x);\n\n          core.Utils.clearU(u);\n          return integral;\n        }\n      },\n      by_parts: function (symbol, dx, depth, o) {\n        o.previous = o.previous || [];\n        var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s; //first LIATE\n\n        udv = __.integration.get_udv(symbol);\n        u = udv[0];\n        dv = udv[1];\n        du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\n        c = du.clone().stripVar(dx); //strip any coefficients\n\n        du = _.divide(du, c.clone());\n        v = __.integrate(dv.clone(), dx, depth || 0);\n        vdu = _.multiply(v.clone(), du);\n        vdu_s = vdu.toString(); //currently only supports e^x*(some trig)\n\n        if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {\n          //We're going to exploit the fact that vdu can never be constant\n          //to work out way out of this cycle. We'll return the length of\n          //the this.previous array until we're back at level one\n          o.is_cyclic = true; //return the integral. \n\n          return new Symbol(1);\n        } else o.previous.push(vdu_s);\n\n        uv = _.multiply(u, v); //clear the multiplier so we're dealing with a bare integral\n\n        m = vdu.multiplier.clone();\n        vdu.toUnitMultiplier();\n        integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\n        integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n        retval = _.subtract(uv, integral_vdu); //we know that there cannot be constants so they're a holdover from a cyclic integral\n\n        if (o.is_cyclic) {\n          //start popping the previous stack so we know how deep in we are\n          o.previous.pop();\n\n          if (o.previous.length === 0) {\n            retval = _.expand(retval);\n            var rem = new Symbol(0);\n            retval.each(function (x) {\n              if (!x.contains(dx)) rem = _.add(rem, x.clone());\n            }); //get the actual uv\n\n            retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n          }\n        }\n\n        return retval;\n      },\n\n      /*\r\n       * dependents: [Solve, integrate]\r\n       */\n      decompose_arg: core.Utils.decompose_fn\n    },\n    //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n    integrate: function (original_symbol, dt, depth, opt) {\n      //assume integration wrt independent variable if expression only has one variable\n      if (!dt) {\n        var vars = core.Utils.variables(original_symbol);\n        if (vars.length === 1) dt = vars[0]; //defaults to x\n\n        dt = dt || 'x';\n      } //add support for integrating vectors\n\n\n      if (core.Utils.isVector(original_symbol)) {\n        var vector = new core.Vector([]);\n        original_symbol.each(function (x) {\n          vector.elements.push(__.integrate(x, dt));\n        });\n        return vector;\n      }\n\n      if (!isNaN(dt)) _.error('variable expected but received ' + dt); //get rid of constants right away\n\n      if (original_symbol.isConstant(true)) return _.multiply(original_symbol.clone(), _.parse(dt)); //configurations options for integral. This is needed for tracking extra options\n      //e.g. cyclic integrals or additional settings\n\n      opt = opt || {};\n      return core.Utils.block('PARSE2NUMBER', function () {\n        //make a note of the original symbol. Set only if undefined\n        depth = depth || 0;\n        var dx = isSymbol(dt) ? dt.toString() : dt,\n            //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\n            g = symbol.group,\n            retval;\n\n        try {\n          //We stop integration after x amount of recursive calls\n          if (++depth > core.Settings.integration_depth) __.integration.stop('Maximum depth reached. Exiting!'); //constants. We first eliminate anything that doesn't have dx. Everything after this has \n          //to have dx or else it would have been taken care of below\n\n          if (!symbol.contains(dx, true)) {\n            retval = _.multiply(symbol.clone(), _.parse(dx));\n          } //e.g. 2*x\n          else if (g === S) {\n              retval = __.integration.poly_integrate(symbol, dx, depth);\n            } else if (g === EX) {\n              //check the base\n              if (symbol.contains(dx) && symbol.previousGroup !== FN) {\n                //if the symbol also contains dx then we stop since we currently \n                //don't know what to do with it e.g. x^x\n                if (symbol.power.contains(dx)) __.integration.stop();else {\n                  var t = __.diff(symbol.clone().toLinear(), dx);\n\n                  if (t.contains(dx)) __.integration.stop(); //since at this point it's the base only then we do standard single poly integration\n                  //e.g. x^y\n\n                  retval = __.integration.poly_integrate(symbol, dx, depth);\n                }\n              } //e.g. a^x or 9^x\n              else {\n                  var a = __.diff(symbol.power.clone(), dx);\n\n                  if (a.contains(dx)) {\n                    var aa = a.stripVar(dx),\n                        x = _.divide(a.clone(), aa.clone());\n\n                    if (x.group === S && x.isLinear()) {\n                      aa.multiplier = aa.multiplier.divide(new Frac(2));\n                      return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                    } else __.integration.stop();\n                  }\n\n                  if (symbol.isE()) {\n                    if (a.isLinear()) retval = symbol;else {\n                      if (a.isE() && a.power.group === S && a.power.power.equals(1)) retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);else __.integration.stop();\n                    }\n                  } else {\n                    var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n\n                    retval = _.divide(symbol, d);\n                  }\n\n                  retval = _.divide(retval, a);\n                }\n            } else if (symbol.isComposite() && symbol.isLinear()) {\n              var m = _.parse(symbol.multiplier);\n\n              symbol.toUnitMultiplier();\n              retval = new Symbol(0);\n              symbol.each(function (x) {\n                retval = _.add(retval, __.integrate(x, dx, depth));\n              });\n              retval = _.multiply(m, retval);\n            } else if (g === CP) {\n              if (symbol.power.greaterThan(1)) symbol = _.expand(symbol);\n\n              if (symbol.power.equals(1)) {\n                retval = new Symbol(0);\n                symbol.each(function (x) {\n                  retval = _.add(retval, __.integrate(x, dx, depth));\n                }, true);\n              } else {\n                var p = Number(symbol.power),\n                    m = symbol.multiplier.clone(); //temporarily remove the multiplier\n\n                symbol.toUnitMultiplier();\n\n                var //below we consider the form ax+b\n                fn = symbol.clone().toLinear(),\n                    //get just the pure function without the power\n                decomp = __.integration.decompose_arg(fn, dx),\n                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n                b = decomp[3],\n                    ax = decomp[2],\n                    a = decomp[0],\n                    x = decomp[1];\n\n                if (p === -1 && x.group !== PL && x.power.equals(2)) {\n                  var b_is_positive = isInt(b) ? b > 0 : true; //we can now check for atan\n\n                  if (x.group === S && x.power.equals(2) && b_is_positive) {\n                    ////then we have atan\n                    //abs is redundants since the sign appears in both denom and num.\n                    var unwrapAbs = function (s) {\n                      var result = new Symbol(1);\n                      s.each(function (x) {\n                        result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                      });\n                      return result;\n                    };\n\n                    var A = a.clone(),\n                        B = b.clone();\n                    A = _.pow(A, new Symbol(1 / 2));\n                    B = _.pow(B, new Symbol(1 / 2)); //unwrap abs\n\n                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                        f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n\n                    retval = _.divide(f, d);\n                  } else if (x.group === S && x.isLinear()) {\n                    retval = _.divide(__.integration.poly_integrate(symbol), a);\n                  } else {\n                    //1/(x^4+1)\n                    if (x.power.equals(4)) {\n                      //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                      var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                      var br = inBrackets; //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\n                      //get quadratic factors\n\n                      A = _.parse(SQRT + br(a) + '*' + dx + '^2');\n                      B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                      C = _.parse(SQRT + br(b));\n                      f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                      f2 = _.add(_.subtract(A, B), C); //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\n\n                      D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\n                      E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx); //let F = 2b√2∜b\n\n                      F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4')); //calculate the factors\n\n                      L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                      L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                      retval = _.add(__.integrate(L1, dx, depth, opt), __.integrate(L2, dx, depth, opt));\n                    } else //let's try partial fractions\n                      retval = __.integration.partial_fraction(symbol, dx, depth);\n                  }\n                } else if (p === -1 / 2) {\n                  //detect asin and atan\n                  if (x.group === S && x.power.equals(2)) {\n                    if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                      a.negate(); //it's asin\n\n                      if (b.isConstant() && a.isConstant()) {\n                        var d = _.symfunction(SQRT, [a.clone()]),\n                            d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n\n                        retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                      } //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                      else {\n                          var sqrt_a = _.symfunction(SQRT, [a]),\n                              sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n\n                          retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                        }\n                    } else {\n                      /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                      __.integration.stop();\n                    }\n                  } else {\n                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                    __.integration.stop();\n                  }\n                } else {\n                  if (x.isLinear() && x.group !== PL) retval = _.divide(__.integration.poly_integrate(symbol), a);else if (x.power.equals(2) && a.greaterThan(0)) {\n                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv; //1/(a*x^2+b^2)^n\n                    //strip the value of b so b = 1\n\n                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\n\n                    sqb = _.parse(SQRT + inBrackets(b));\n                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                    bsqi = _.pow(b, new Symbol(symbol.power));\n                    uv = core.Utils.getU(symbol);\n                    u = _.multiply(aob, x.clone().toLinear());\n                    v = _.parse(ATAN + inBrackets(u)); //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                    //then the remaining sec will be (n-1)*2;\n\n                    var n = (Math.abs(symbol.power) - 1) * 2; //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n\n                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\n\n                    core.Utils.clearU(uv);\n                    return _.multiply(integral.sub(uv, v), bsqi);\n                  } else {\n                    if (symbol.group !== CB && !symbol.power.lessThan(0)) {\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    } else {\n                      var f = symbol.clone().toLinear();\n                      var factored = core.Algebra.Factor.factor(f);\n                      var was_factored = factored.toString() !== f.toString();\n\n                      if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\n                        try {\n                          var f1, fx, u, sq;\n                          sq = core.Algebra.sqComplete(f, dx);\n                          u = core.Utils.getU(f);\n                          f1 = sq.f.sub(sq.a, u);\n                          fx = _.pow(f1, _.parse(symbol.power));\n                          retval = __.integrate(fx, u).sub(u, sq.a);\n                        } catch (e) {\n                          __.integration.stop();\n                        }\n                      } else retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                    }\n                  }\n                }\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === FN) {\n              var arg = symbol.args[0],\n                  m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier();\n\n              var decomp = __.integration.decompose_arg(arg, dx); //easies way I can think of to get the coefficient and to make sure\n              //that the symbol is linear wrt dx. I'm not actually trying to get the \n              //derivative\n\n\n              var a = decomp[0],\n                  x = decomp[1],\n                  fname = symbol.fname; //log is a special case that can be handled with integration by parts\n\n              if (fname === LOG || fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear()) {\n                /*integration by parts */\n                var p = symbol.power.toString();\n                if (isInt(p)) depth = depth - p; //it needs more room to find the integral\n\n                retval = __.integration.by_parts(symbol, dx, depth, opt);\n              } else if (fname === TAN && symbol.power.lessThan(0)) {\n                //convert to cotangent\n                var sym = symbol.clone();\n                sym.power.negate();\n                sym.fname = COT;\n                return __.integrate(sym, dx, depth);\n              } else {\n                if (!a.contains(dx, true) && symbol.isLinear()) {\n                  //perform a deep search for safety\n                  //first handle the special cases \n                  if (fname === ABS) {\n                    //REVISIT **TODO**\n                    var x = _.divide(arg.clone(), a.clone());\n\n                    if (x.group === S && !x.power.lessThan(0)) {\n                      if (core.Utils.even(x.power)) {\n                        retval = __.integrate(arg, dx, depth);\n                      } else {\n                        var integrated = __.integrate(x, dx, depth);\n\n                        integrated.power = integrated.power.subtract(new Frac(1));\n                        retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                      }\n                    } else __.integration.stop();\n                  } else {\n                    var ag = symbol.args[0].group,\n                        decomposed = __.integration.decompose_arg(arg, dx);\n\n                    if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc()) __.integration.stop();\n                    /**TODO**/\n                    //ASIN, ACOS, ATAN\n\n                    switch (fname) {\n                      case COS:\n                        retval = _.symfunction(SIN, [arg]);\n                        break;\n\n                      case SIN:\n                        retval = _.symfunction(COS, [arg]);\n                        retval.negate();\n                        break;\n\n                      case TAN:\n                        retval = _.parse(format('log(sec({0}))', arg));\n                        break;\n\n                      case SEC:\n                        retval = _.parse(format('log(tan({0})+sec({0}))', arg));\n                        break;\n\n                      case CSC:\n                        retval = _.parse(format('-log(csc({0})+cot({0}))', arg));\n                        break;\n\n                      case COT:\n                        retval = _.parse(format('log(sin({0}))', arg));\n                        break;\n\n                      case SINH:\n                        retval = _.symfunction(COSH, [arg]);\n                        break;\n\n                      case COSH:\n                        retval = _.symfunction(SINH, [arg]);\n                        break;\n\n                      case TANH:\n                        retval = _.parse(format('log(cosh({0}))', arg));\n                        break;\n\n                      case ASEC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOT:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //inverse htrig\n\n                      case ASECH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSCH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOTH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //end inverse htrig\n                      //htrigh\n\n                      case SECH:\n                        retval = _.parse(format('atan(sinh({0}))', arg));\n                        break;\n\n                      case CSCH:\n                        retval = _.parse(format('log(tanh(({0})/2))', arg));\n                        break;\n\n                      case COTH:\n                        retval = _.parse(format('log(sinh({0}))', arg));\n                        break;\n                      //end htrig\n\n                      case EXP:\n                        retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                        break;\n\n                      case 'S':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                        break;\n\n                      case 'C':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                        break;\n\n                      case 'erf':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                        break;\n\n                      case 'sign':\n                        retval = _.multiply(symbol.clone(), arg.clone());\n                        break;\n\n                      default:\n                        __.integration.stop();\n\n                    }\n\n                    retval = _.divide(retval, a);\n                  }\n                } else if (x.isLinear()) {\n                  if (fname === COS || fname === SIN) {\n                    var p = Number(symbol.power); //check to see if it's negative and then just transform it to sec or csc\n\n                    if (p < 0) {\n                      symbol.fname = fname === SIN ? CSC : SEC;\n                      symbol.invert().updateHash();\n                      retval = __.integrate(symbol, dx, depth);\n                    } else {\n                      var arg = symbol.args[0],\n                          rd = symbol.clone(),\n                          //cos^(n-1)\n                      rd2 = symbol.clone(),\n                          //cos^(n-2)\n                      q = new Symbol((p - 1) / p),\n                          //\n                      na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n\n\n                      rd.power = rd.power.subtract(new Frac(1));\n                      rd2.power = rd2.power.subtract(new Frac(2));\n\n                      var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n\n                      if (fname === SIN) t.negate();\n                      retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                    }\n                  } //tan(x)^n or cot(x)^n\n                  else if (fname === TAN || fname === COT) {\n                      //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                      if (symbol.args[0].isLinear(dx)) {\n                        var n = symbol.power.subtract(new Frac(1)).toString(),\n                            r = symbol.clone().toUnitMultiplier(),\n                            w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.subtract(w, __.integrate(r, dx, depth));\n                      }\n                    } //sec(x)^n or csc(x)^n\n                    else if (fname === SEC || fname === CSC) {\n                        //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                        var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                            n2 = symbol.power.subtract(new Frac(2)).toString(),\n                            f2 = fname === SEC ? TAN : COT,\n                            r = symbol.clone().toUnitMultiplier(),\n                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                            w = _.parse(parse_str);\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\n                      } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                        retval = __.integrate(symbol.fnTransform(), dx, depth);\n                      } else __.integration.stop();\n                } else __.integration.stop();\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === PL) {\n              retval = __.integration.partial_fraction(symbol, dx, depth);\n            } else if (g === CB) {\n              //separate the coefficient since all we care about are symbols containing dx\n              var coeff = symbol.stripVar(dx); //now get only those that apply\n\n              var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n              //peform a correction for stripVar. This is a serious TODO!\n\n\n              if (coeff.contains(dx)) {\n                cfsymbol = _.multiply(cfsymbol, coeff);\n                coeff = new Symbol(1);\n              } //if we only have one symbol left then let's not waste time. Just pull the integral\n              //and let the chips fall where they may\n\n\n              if (cfsymbol.group !== CB) {\n                if (cfsymbol.equals(1)) {\n                  return __.integrate(_.expand(symbol), dx, depth);\n                } //only factor for multivariate which are polynomials\n\n\n                if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                  cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n                }\n\n                retval = __.integrate(cfsymbol, dx, depth);\n              } else {\n                //we collect the symbols and sort them descending group, descending power, descending alpabethically\n                var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\n                  if (a.group === b.group) {\n                    if (Number(a.power) === Number(b.power)) if (a < b) return 1; //I want sin first\n                    else return -1;\n                    return b.power - a.power; //descending power\n                  }\n\n                  return b.group - a.group; //descending groups\n                }).map(function (x) {\n                  var unwrapped = Symbol.unwrapSQRT(x, true);\n\n                  if (unwrapped.fname === EXP) {\n                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                  }\n\n                  return unwrapped;\n                });\n                var l = symbols.length;\n\n                if (symbol.power < 0) {\n                  if (l === 2) {\n                    return __.integrate(_.expand(symbol), dx, depth, opt);\n                  }\n                } //otherwise the denominator is one lumped together symbol \n                else {\n                    //generate an image for \n                    if (l === 2) {\n                      //try u substitution\n                      try {\n                        retval = __.integration.u_substitution(symbols, dx);\n                      } catch (e) {\n                        /* failed :`(*/\n                        ;\n                      }\n\n                      if (!retval) {\n                        //no success with u substitution so let's try known combinations\n                        //are they two functions\n                        var g1 = symbols[0].group,\n                            g2 = symbols[1].group,\n                            sym1 = symbols[0],\n                            sym2 = symbols[1],\n                            fn1 = sym1.fname,\n                            fn2 = sym2.fname; //reset the symbol minus the coeff\n\n                        symbol = _.multiply(sym1.clone(), sym2.clone());\n\n                        if (g1 === FN && g2 === FN) {\n                          if (fn1 === LOG || fn2 === LOG) {\n                            retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                          } else {\n                            symbols.sort(function (a, b) {\n                              return b.fname > a.fname;\n                            });\n                            var arg1 = sym1.args[0]; //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n\n                            if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S)) __.integration.stop();\n\n                            var decomp = __.integration.decompose_arg(arg1, dx);\n\n                            x = decomp[1], a = decomp[0];\n                            if (!x.isLinear()) //again... linear arguments only wrt x\n                              __.integration.stop(); //they have to have the same arguments and then we have cleared all the check to \n                            //make sure we can integrate FN & FN\n\n                            var arg2 = sym2.args[0]; //make sure that their argument matches\n\n                            if (arg1.equals(arg2)) {\n                              if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\n                                if (sym1.power.lessThan(0)) __.integration.stop(); //we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                                //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n\n                                if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\n                                  sym1.fname = TAN;\n                                  sym1.updateHash();\n                                  retval = __.integrate(sym1, dx, depth);\n                                } else {\n                                  if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                    //transform sin^(2*n) to (1-cos^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                    //transform cos^(2*n) to (1-sin^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else {\n                                    var p1_even = core.Utils.even(sym1.power),\n                                        p2_even = core.Utils.even(sym2.power);\n                                    retval = new Symbol(0);\n\n                                    if (!p1_even || !p2_even) {\n                                      var u, r, trans; //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                      //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n\n                                      if (!p1_even) {\n                                        //u = sin(x)\n                                        u = sym2;\n                                        r = sym1;\n                                      } else {\n                                        u = sym1;\n                                        r = sym2;\n                                      } //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n\n\n                                      var sign = u.fname === COS ? -1 : 1,\n                                          n = r.power,\n                                          //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                      //even powers afterwards which can be transformed\n                                      k = (n - 1) / 2,\n                                          //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                      trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\n                                          sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans))); //we can now just loop through and integrate each since it's now just a polynomial with functions\n\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                      });\n                                    } else {\n                                      //performs double angle transformation\n                                      var double_angle = function (symbol) {\n                                        var p = symbol.power,\n                                            k = p / 2,\n                                            e;\n                                        if (symbol.fname === COS) e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;else e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\n                                        return _.parse(e);\n                                      }; //they're both even so transform both using double angle identities and we'll just\n                                      //be able to integrate by the sum of integrals\n\n\n                                      var a = double_angle(sym1),\n                                          b = double_angle(sym2),\n                                          t = _.multiply(a, b);\n\n                                      var sym = _.expand(t);\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integrate(x, dx, depth));\n                                      });\n                                      return _.multiply(retval, coeff);\n                                    }\n                                  }\n                                }\n                              } //tan(x)*sec(x)^n \n                              else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\n                                  retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                                } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {\n                                  //remaining: tan(x)^3*sec(x)^6\n                                  if (sym1.isLinear() && sym2.isLinear()) {\n                                    retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                                  } else if (even(sym1.power)) {\n                                    var p = Number(sym1.power) / 2; //transform tangent\n\n                                    var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n\n                                    retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                                  } else __.integration.stop();\n                                } else if (fn1 === SEC && fn2 === COS) {\n                                  sym1.fname = COS;\n                                  sym1.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } else if (fn1 === SIN && fn2 === CSC) {\n                                  sym2.fname = SIN;\n                                  sym2.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } //tan/cos\n                                else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                                    var t = _.multiply(sym1.fnTransform(), sym2);\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  } else {\n                                    var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  }\n                            } //TODO: REVISIT AT SOME POINT\n                            else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                                var transformed = trigTransform(symbols);\n                                retval = __.integrate(_.expand(transformed), dx, depth);\n                              } else {\n                                __.integration.stop();\n                              }\n                          }\n                        } else if (g1 === FN && g2 === S) {\n                          var sym1_is_linear = sym1.isLinear();\n                          if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Ci', [sym1.args[0]]);else if (sym1.fname === COS && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Chi', [sym1.args[0]]);else if (sym1.fname === COSH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Si', [sym1.args[0]]);else if (sym1.fname === SIN && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Shi', [sym1.args[0]]);else if (sym1.fname === SINH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === LOG && sym2.power.equals(-1)) {\n                            //log(x)^n/x = log(x)^(n+1)/(n+1)\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else if (sym1.fname === 'erf') {\n                            if (sym2.power.equals(1)) {\n                              var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                                  a_ = dc[0],\n                                  x_ = dc[1],\n                                  arg = sym1.args[0].toString();\n\n                              retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg));\n                            }\n                          } else {\n                            //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else if (g1 === EX && g2 === S) {\n                          var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n\n                          if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                            retval = _.symfunction('Ei', [sym1.power.clone()]);\n                          } else if (fn1 === LOG && x.value === sym2.value) {\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        } else if (g1 === PL && g2 === S) {\n                          //first try to reduce the top\n                          if (sym2.value === sym1.value && sym1.power.equals(-1)) {\n                            //find the lowest power in the denominator\n                            var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols)); //get the lowest common value between denominator and numerator\n\n                            var pc = Math.min(pd, sym2.power); //reduce both denominator and numerator by that factor\n\n                            var factor = sym2.clone();\n                            factor.power = new Frac(pc);\n                            sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n\n                            var t = new Symbol(0);\n                            sym1.each(function (x) {\n                              t = _.add(t, _.divide(x.clone(), factor.clone()));\n                            });\n                            t.multiplier = sym1.multiplier;\n                            symbol = _.divide(sym2, t);\n                          }\n\n                          retval = __.integration.partial_fraction(symbol, dx, depth);\n                        } else if (g1 === CP && g2 === S) {\n                          var f = sym1.clone().toLinear(),\n                              f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1); //handle cases x^(2*n)/sqrt(1-x^2)\n\n                          if (sym1.power.equals(-1 / 2)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n\n                            var a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                              //if the substitution \n                              var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), _.pow(a.clone(), new Symbol(2)));\n\n                              c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n\n                              var dummy = _.parse('sin(u)');\n\n                              dummy.power = dummy.power.multiply(sym2.power);\n\n                              var integral = __.integrate(dummy, 'u', depth);\n\n                              var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\n\n                              retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                            } else if (p1 === -1 / 2) {\n                              var u_transform = function (f, u) {\n                                var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n\n                                if (!integral.hasIntegral()) return integral;\n                              };\n\n                              if (p2 === -1) {\n                                retval = u_transform(_.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(), 'sqrt(1-1/({0})^2)');\n                              } else if (p2 === -2) {\n                                //apply transformation to see if it matches asin(x)\n                                retval = u_transform(_.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(), 'sqrt(1-1/({0})^2)');\n                              }\n                            }\n                          } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\n                            retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {\n                            //sum of integrals\n                            var expanded = _.expand(sym1);\n\n                            retval = new Symbol(0);\n                            expanded.each(function (x) {\n                              if (x.group === PL) {\n                                x.each(function (y) {\n                                  retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                                });\n                              } else retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                            });\n                          } else if (sym1.power.lessThan(-2)) {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                fn = sym1.clone().toLinear();\n\n                            if (x.group !== PL && x.isLinear()) {\n                              var p = Number(sym2.power),\n                                  du = '_u_',\n                                  u = new Symbol(du),\n                                  //pull the integral with the subsitution\n                              U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                                  scope = {}; //generate a scope for resubbing the symbol\n\n\n                              scope[du] = fn;\n\n                              var U2 = _.parse(U, scope);\n\n                              retval = __.integrate(U2, dx, 0);\n                            } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\n                              //factor out coefficients\n                              var factors = new core.Algebra.Classes.Factors();\n                              sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                              var div = core.Algebra.divide(sym2, sym1); //it assumed that the result will be of group CB\n\n                              if (div.group !== CB) {\n                                retval = new Symbol(0);\n                                div.each(function (t) {\n                                  retval = _.add(retval, __.integrate(t, dx, depth));\n                                }); //put back the factors\n\n                                factors.each(function (factor) {\n                                  retval = _.divide(retval, factor);\n                                });\n                                retval = _.expand(retval);\n                              } else {\n                                //try something else\n                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                              }\n                            } else retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else {\n                            //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                            if (sym1.power.den.equals(2)) {\n                              //assume the function is in the form (a^2-b*x^n)^(m/2)\n                              var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                  //using the above definition\n                              a = dc[3],\n                                  x = dc[1],\n                                  b = dc[0],\n                                  bx = dc[2];\n\n                              if (x.power.equals(2) && b.lessThan(0)) {\n                                //if n is even && b is negative\n                                //make a equal 1 so we can do a trig sub\n                                if (!a.equals(1)) {\n                                  //divide a out of everything\n                                  //move a to the coeff\n                                  coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                                }\n\n                                var u = dx;\n\n                                var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\n                                    du = _.symfunction(COS, [new Symbol(u)]),\n                                    cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                                    X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                                    val = _.multiply(_.multiply(cosn, du), X),\n                                    integral = __.integrate(val, u, depth); //but remember that u = asin(sqrt(b)*a*x)\n\n\n                                retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                              } else {\n                                retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                              }\n                            } else if (f_is_linear) {\n                              retval = __.integration.partial_fraction(symbol, dx, depth);\n                            }\n                          }\n                        } else if (sym1.isComposite() && sym2.isComposite()) {\n                          //sum of integrals\n                          retval = new Symbol(0);\n\n                          if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                            //combine and pull the integral of each\n                            var sym = _.expand(symbol);\n\n                            sym.each(function (x) {\n                              retval = _.add(retval, __.integrate(x, dx, depth));\n                            }, true);\n                          } else {\n                            var p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (p1 < 0 && p2 > 0) {\n                              //swap\n                              var t = sym1;\n                              sym1 = sym2;\n                              sym2 = t;\n                            }\n\n                            if (p1 === -1 && p2 === -1) {\n                              retval = __.integration.partial_fraction(symbol, dx);\n                            } else {\n                              sym1.each(function (x) {\n                                var k = _.multiply(x, sym2.clone());\n\n                                var integral = __.integrate(k, dx, depth);\n\n                                retval = _.add(retval, integral);\n                              });\n                            }\n                          }\n                        } else if (g1 === CP && symbols[0].power.greaterThan(0)) {\n                          sym1 = _.expand(sym1);\n                          retval = new Symbol(0);\n                          sym1.each(function (x) {\n                            retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                          }, true);\n                        } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                          sym1 = sym1.fnTransform();\n                          retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                        } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                          if (g2 === FN && g1 === CP) {\n                            var t = sym1;\n                            sym1 = sym2;\n                            sym2 = t; //swap\n                          }\n\n                          var du, sym2_clone, p, q, sa, sb;\n                          du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                          sym2_clone = Symbol.unwrapSQRT(sym2, true);\n\n                          if (du.power.equals(sym2_clone.power)) {\n                            p = new Symbol(sym2.power);\n                            sa = du.clone().toLinear();\n                            sb = sym2.clone().toLinear();\n                            q = core.Algebra.divide(sa.toLinear(), sb);\n\n                            if (q.isConstant()) {\n                              var nq = _.pow(q, p.negate());\n\n                              retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                            }\n                          } else {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else {\n                          retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        }\n                      }\n                    } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\n                      var first = symbols[0];\n\n                      if (first.group === CP) {\n                        //TODO {support higher powers of x in the future}\n                        if (first.power.greaterThan(1)) first = _.expand(first);\n\n                        var r = _.multiply(symbols[1], symbols[2]);\n\n                        retval = new Symbol(0);\n                        first.each(function (x) {\n                          var t = _.multiply(x, r.clone());\n\n                          var intg = __.integrate(t, dx, depth);\n\n                          retval = _.add(retval, intg);\n                        }, true);\n                      } else {\n                        //try integration by parts although technically it will never work\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else if (all_functions(symbols)) {\n                      var t = new Symbol(1);\n\n                      for (var i = 0, l = symbols.length; i < l; i++) {\n                        t = _.multiply(t, symbols[i].fnTransform());\n                      }\n\n                      t = _.expand(t);\n                      retval = __.integrate(t, dx, depth);\n                    } else {\n                      //one more go\n                      var transformed = trigTransform(symbols);\n                      retval = __.integrate(_.expand(transformed), dx, depth);\n                    }\n                  }\n              }\n\n              retval = _.multiply(retval, coeff);\n            } //if an integral was found then we return it\n\n\n          if (retval) return retval;\n        } catch (error) {\n          //do nothing if it's a NoIntegralFound error otherwise let it bubble\n          if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) throw error;\n        } //no symbol found so we return the integral again\n\n\n        return _.symfunction('integrate', [original_symbol, dt]);\n      }, false);\n    },\n    defint: function (symbol, from, to, dx) {\n      dx = dx || 'x'; //make x the default variable of integration\n\n      var get_value = function (integral, vars, point) {\n        try {\n          return _.parse(integral, vars);\n        } catch (e) {\n          //it failed for some reason so return the limit\n          return __.Limit.limit(integral, dx, point);\n        }\n      };\n\n      var vars = core.Utils.variables(symbol),\n          integral = __.integrate(symbol, dx),\n          retval;\n\n      if (vars.length === 1) dx = vars[0];\n\n      if (!integral.hasIntegral()) {\n        var upper = {},\n            lower = {},\n            a,\n            b;\n        upper[dx] = to;\n        lower[dx] = from;\n        a = get_value(integral, upper, to, dx);\n        b = get_value(integral, lower, from, dx);\n        retval = _.subtract(a, b);\n      } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {\n        var f = core.Utils.build(symbol);\n        retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n      } else retval = _.symfunction('defint', [symbol, from, to, dx]);\n\n      return retval;\n    },\n    Limit: {\n      interval: function (start, end) {\n        return _.parse(format('[{0}, {1}]', start, end));\n      },\n      diverges: function () {\n        return __.Limit.interval('-Infinity', 'Infinity');\n      },\n      divide: function (f, g, x, lim) {\n        var fin = f.clone(),\n            gin = g.clone();\n\n        var isInfinity = function (L) {\n          if (core.Utils.isVector(L)) {\n            for (var i = 0; i < L.elements.length; i++) if (!L.elements[i].isInfinity) return false;\n\n            return true;\n          }\n\n          return L.isInfinity;\n        };\n\n        var equals = function (L, v) {\n          if (core.Utils.isVector(L)) {\n            return false;\n          }\n\n          return L.equals(v);\n        };\n\n        var retval;\n\n        do {\n          var lim1 = evaluate(__.Limit.limit(f, x, lim));\n          var lim2 = evaluate(__.Limit.limit(g, x, lim)); //if it's in indeterminate form apply L'Hospital's rule\n\n          var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0); //pull the derivatives\n\n          if (indeterminate) {\n            var ft = __.diff(f.clone(), x);\n\n            var gt = __.diff(g.clone(), x);\n\n            var t_symbol = _.expand(_.divide(ft, gt));\n\n            f = t_symbol.getNum();\n            g = t_symbol.getDenom();\n          }\n        } while (indeterminate);\n\n        if (lim1.isInfinity && lim2.equals(0)) retval = lim1;else if (lim1.equals(0) && lim2.isInfinity) retval = lim1;else if (lim1.isInfinity) {\n          retval = lim1;\n        } else if (lim2.isInfinity) {\n          retval = new Symbol(0);\n        } else {\n          //TODO: \n          //REMEMBER: \n          //- 1/cos(x)\n          //n/0 is still possible since we only checked for 0/0\n          if (lim2.equals(0)) {\n            retval = __.Limit.diverges();\n          } else retval = _.divide(lim1, lim2);\n        }\n        return retval;\n      },\n      rewriteToLog: function (symbol) {\n        var p = symbol.power.clone();\n        symbol.toLinear();\n        return _.pow(new Symbol('e'), _.multiply(p, _.symfunction('log', [symbol])));\n      },\n      getSubbed: function (f, x, lim) {\n        var retval; //1. rewrite EX with base e\n\n        if (f.group === EX) {\n          f = __.rewriteToLog(f);\n        } //2. try simple substitution\n\n\n        try {\n          retval = f.sub(x, lim);\n        } catch (e) {\n          //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n          retval = f;\n        }\n\n        return retval;\n      },\n      isInterval: function (limit) {\n        return core.Utils.isVector(limit);\n      },\n      isConvergent: function (limit) {\n        //it's not convergent if it lies on the interval -Infinity to Infinity\n        if ( //It lies on the interval -Infinity to Infinity\n        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit\n        limit.containsFunction('limit')) {\n          return false; //Then no\n        }\n\n        return true; //It is\n      },\n      limit: function (symbol, x, lim) {\n        //store the multiplier\n        var m = _.parse(symbol.multiplier); //strip the multiplier\n\n\n        symbol.toUnitMultiplier();\n\n        try {\n          //https://en.wikipedia.org/wiki/List_of_limits\n          var retval; //we try the simplest option first where c is some limit\n          //lim a as x->c = a where c \n\n          if (symbol.isConstant(true)) {\n            retval = symbol;\n          } else {\n            var point = {};\n            point[x] = lim; //lim x as x->c = c where c\n\n            try {\n              //evaluate the function at the given limit\n              var t = _.parse(symbol.sub(x, lim), point); //a constant or infinity is known so we're done\n\n\n              if (t.isConstant(true) || t.isInfinity) retval = t;\n            } catch (e) {\n              /*Nothing. Maybe we tried to divide by zero.*/\n            }\n\n            ;\n\n            if (!retval) {\n              //split the symbol in the numerator and the denominator\n              var num = symbol.getNum();\n              var den = symbol.getDenom();\n\n              if (den.isConstant(true)) {\n                //We still don't have a limit so we generate tests.\n                if (symbol.group === EX) {\n                  //https://en.wikipedia.org/wiki/List_of_limits\n                  //Speed boost for exponentials by detecting patterns\n                  var f = symbol.clone().toLinear();\n                  var p = symbol.power.clone();\n\n                  var _num = f.getNum();\n\n                  var _den = f.getDenom();\n\n                  var fn = core.Utils.decompose_fn(_den, x, true); //start detection of pattern (x/(x+1))^x\n\n                  if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                    retval = _.parse(format('(1/e^({0}))', fn.b));\n                  } else {\n                    var symbol_ = __.Limit.rewriteToLog(symbol.clone()); //get the base\n\n\n                    var pow = symbol_.power.clone();\n                    var base = symbol_.clone().toLinear();\n\n                    var lim_base = __.Limit.limit(base, x, lim);\n\n                    var lim_pow = __.Limit.limit(pow, x, lim);\n\n                    retval = _.pow(lim_base, lim_pow);\n                  }\n                } else if (symbol.group === FN && symbol.args.length === 1) {\n                  //Squeeze theorem lim f(g(x)) = lim f(lim g))\n                  var arg = __.Limit.limit(symbol.args[0], x, lim);\n\n                  if (core.Utils.isVector(arg)) {\n                    //get the limit over that interval\n                    retval = arg.map(function (e) {\n                      var clone = symbol.clone();\n                      clone.args[0] = e;\n                      return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim);\n                    });\n                    return _.multiply(m, retval);\n                  } //if the argument is constant then we're done\n                  else if (arg.isConstant(true)) {\n                      var evaluates; //double check that it evaluates\n\n                      var trial = _.symfunction(symbol.fname, [arg]); //trial evaluation\n\n\n                      try {\n                        evaluate(trial);\n                        evaluates = true;\n                      } catch (e) {\n                        evaluates = false;\n                      }\n                    }\n\n                  if (evaluates) {\n                    retval = trial;\n                  } else {\n                    //if the limit converges. We'll deal with non-convergent ones later\n                    if (__.Limit.isConvergent(arg)) {\n                      if (symbol.fname === LOG) {\n                        switch (arg.toString()) {\n                          //lim -> 0\n                          case '0':\n                            retval = Symbol.infinity().negate();\n                            break;\n\n                          case 'Infinity':\n                            retval = Symbol.infinity();\n                            break;\n\n                          case '-Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                        }\n                      } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                        retval = __.Limit.interval(-1, 1);\n                      } else if (symbol.fname === TAN) {\n                        var s_arg = symbol.args[0];\n                        var n = s_arg.getNum();\n                        var d = s_arg.getDenom();\n                        var pi = n.toUnitMultiplier();\n\n                        if (lim.isInfinity || pi.equals('pi') && d.equals(2)) {\n                          retval = divergent();\n                        }\n                      } else if (symbol.fname === Settings.FACTORIAL) {\n                        if (arg.isInfinity) return Symbol.infinity();\n                      }\n                    }\n                  }\n                } else if (symbol.group === S) {\n                  if (symbol.power > 0) //these functions always converge to the limit\n                    return _.parse(symbol, point);else {\n                    //we're dealing with 1/x^n but remember that infinity has already been dealt\n                    //with by substitution\n                    if (core.Utils.even(symbol.power)) {\n                      //even powers converge to infinity\n                      retval = Symbol.infinity();\n                    } else {\n                      //odd ones don't\n                      retval = __.Limit.diverges();\n                    }\n                  }\n                } else if (symbol.group === CB) {\n                  symbol = _.expand(symbol); //if the group no longer is CB then feed it back to this function\n\n                  if (symbol.group !== CB) {\n                    retval = __.Limit.limit(symbol, x, lim);\n                  } else {\n                    var lim1, lim2; //loop through all the symbols\n                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\n                      return a.group - b.group;\n                    });\n                    var f = symbols.pop(); //calculate the first limit so we can keep going down the list\n\n                    lim1 = evaluate(__.Limit.limit(f, x, lim)); //reduces all the limits one at a time\n\n                    while (symbols.length) {\n                      //get the second limit\n                      var g = symbols.pop(); //get the limit of g\n\n                      lim2 = evaluate(__.Limit.limit(g, x, lim)); //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n\n                      if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {\n                        //invert the symbol\n                        g.invert();\n                        lim1 = __.Limit.divide(f, g, x, lim);\n                      } else {\n                        //lim f*g = (lim f)*(lim g)\n                        lim1 = _.multiply(lim1, lim2); //let f*g equal f and h equal g \n\n                        f = _.multiply(f, g);\n                      }\n                    } //Done, lim1 is the limit we're looking for     \n\n\n                    retval = lim1;\n                  }\n                } else if (symbol.isComposite()) {\n                  var original = symbol.clone();\n\n                  var _lim;\n\n                  if (!symbol.isLinear()) symbol = _.expand(symbol); //Apply lim f+g = (lim f)+(lim g)\n\n                  retval = new Symbol(0);\n                  symbol.each(function (sym) {\n                    //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n                    try {\n                      _lim = __.Limit.limit(sym, x, lim);\n                    } catch (e) {\n                      _lim = __.Limit.diverges();\n                    }\n\n                    try {\n                      retval = _.add(retval, _lim);\n                    } catch (e) {\n                      //rewrite the function to have a common denominator. \n                      //TODO: This is soooo slow at the moment.\n                      symbol = core.Utils.toCommonDenominator(original);\n                      retval = __.Limit.limit(symbol, x, lim);\n                    }\n                  });\n                }\n              } else {\n                retval = __.Limit.divide(num, den, x, lim);\n              }\n            }\n          } //if we still don't have a solution\n\n\n          if (!retval) //return it symbolically\n            retval = _.symfunction('limit', arguments);\n        } catch (e) {\n          //if all else fails return the symbolic function\n          retval = _.symfunction('limit', arguments);\n        }\n\n        return _.multiply(m, retval);\n      }\n    },\n    Fresnel: {\n      S: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('S', arguments);\n      },\n      C: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('C', arguments);\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'diff',\n    visible: true,\n    numargs: [1, 3],\n    build: function () {\n      return __.diff;\n    }\n  }, {\n    name: 'sum',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.sum;\n    }\n  }, {\n    name: 'product',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.product;\n    }\n  }, {\n    name: 'integrate',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.integrate;\n    }\n  }, {\n    name: 'defint',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.defint;\n    }\n  }, {\n    name: 'S',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.S;\n    }\n  }, {\n    name: 'C',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.C;\n    }\n  }, {\n    name: 'limit',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.Limit.limit;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.api();\n})();","map":null,"metadata":{},"sourceType":"script"}