{"ast":null,"code":"// Created by mauricio on 4/27/15.\n'use strict';\n\nvar utils = require('./operations/utils');\n\nvar round = require('./round-math');\n\nmodule.exports = Interval;\n/**\n * Constructor for closed intervals representing all the values inside (and\n * including) `lo` and `hi` e.g. `[lo, hi]`\n *\n * NOTE: If `lo > hi` then the constructor will return an empty interval\n *\n * @class\n * @mixes arithmetic\n * @mixes algebra\n * @mixes misc\n * @mixes relational\n * @mixes trigonometric\n * @mixes utils\n * @mixes constants\n *\n * @see #bounded\n * @see #boundedSingleton\n *\n * @example\n * new Interval(1, 2)  // {lo: 1, hi: 2}\n * @example\n * // function invocation without new is also supported\n * Interval(1, 2)   // {lo: 1, hi: 2}\n * @example\n * // with numbers\n * Interval(1, 2)   // {lo: 1, hi: 2}\n * Interval(1)      // {lo: 1, hi: 1}\n * @example\n * // with an array\n * Interval([1, 2]) // {lo: 1, hi: 2}\n * @example\n * // singleton intervals\n * var x = Interval(1)\n * var y = Interval(2)\n * Interval(x, y)   // {lo: 1, hi: 2}\n * @example\n * // when `lo > hi` it returns an empty interval\n * Interval(2, 1)   // {lo: Infinity, hi: -Infinity}\n * @example\n * // bounded interval\n * Interval().bounded(1, 2)  // { lo: 0.9999999999999999, hi: 2.0000000000000004 }\n * @example\n * // singleton bounded interval\n * Interval().boundedSingleton(2)  // {lo: 1.9999999999999998, hi: 2.0000000000000004}\n * @example\n * // half open and open intervals\n * // [2, 3]\n * Interval(2, 3)                     // {lo: 2, hi: 3}\n * // (2, 3]\n * Interval().halfOpenLeft(2, 3)      // {lo: 2.0000000000000004, hi: 3}\n * // [2, 3)\n * Interval().halfOpenRight(2, 3)     // {lo: 2, hi: 2.9999999999999996}\n * // (2, 3)\n * Interval().open(2, 3)              // {lo: 2.0000000000000004, hi: 2.9999999999999996}\n *\n * @param {number|array|Interval} lo The left endpoint of the interval if it's a\n * number or a singleton interval, if it's an array then an interval will be\n * built out of the elements of the array\n * @param {number|Interval} [hi] The right endpoint of the interval if it's a\n * number or a singleton interval, if omitted then a singleton interval will be\n * built out of `lo`\n */\n\nfunction Interval(lo, hi) {\n  if (!(this instanceof Interval)) {\n    return new Interval(lo, hi);\n  }\n\n  if (typeof lo !== 'undefined' && typeof hi !== 'undefined') {\n    // possible cases:\n    // - Interval(1, 2)\n    // - Interval(Interval(1, 1), Interval(2, 2))     // singletons are required\n    if (utils.isInterval(lo)) {\n      if (!utils.isSingleton(lo)) {\n        throw new TypeError('Interval: interval `lo` must be a singleton');\n      }\n\n      lo = lo.lo;\n    }\n\n    if (utils.isInterval(hi)) {\n      if (!utils.isSingleton(hi)) {\n        throw TypeError('Interval: interval `hi` must be a singleton');\n      }\n\n      hi = hi.hi;\n    }\n  } else if (typeof lo !== 'undefined') {\n    // possible cases:\n    // - Interval(1)\n    // - Interval([1, 2])\n    // - Interval([Interval(1, 1), Interval(2, 2)])\n    if (Array.isArray(lo)) {\n      return Interval(lo[0], lo[1]);\n    }\n\n    return Interval(lo, lo);\n  } else {\n    // possible cases:\n    // - Interval()\n    lo = hi = 0;\n  }\n  /**\n   * The left endpoint of the interval\n   * @type {number}\n   */\n\n\n  this.lo = undefined;\n  /**\n   * The right endpoint of the interval\n   * @type {number}\n   */\n\n  this.hi = undefined;\n  this.assign(lo, hi);\n}\n\nInterval.factory = Interval;\n/**\n * Sets `this.lo` and `this.hi` to a single value `v`\n *\n * @param {number} v\n * @return {Interval} The calling interval i.e. `this`\n */\n\nInterval.prototype.singleton = function (v) {\n  return this.set(v, v);\n};\n/**\n * Sets new endpoints to this interval, the left endpoint is equal to the\n * previous IEEE floating point value of `lo` and the right endpoint\n * is equal to the next IEEE floating point\n * value of `hi`, it's assumed that `lo <= hi`\n * @example\n * var x = Interval().bounded(1, 2)\n * x.lo < 1 // true, x.lo === 0.9999999999999999\n * x.hi > 2 // true, x.hi === 2.0000000000000004\n * @example\n * // the correct representation of 1/3\n * var x = Interval().bounded(1/3, 1/3)\n * x.lo < 1/3 // true\n * x.hi > 1/3 // true\n * // however the floating point representation of 1/3 is less than the real 1/3\n * // therefore the left endpoint could be 1/3 instead of the previous value of\n * var next = Interval.round.safeNext\n * var x = Interval().set(1/3, next(1/3))\n * // x now represents 1/3 correctly\n * @param {number} lo\n * @param {number} hi\n * @return {Interval} The calling interval i.e. `this`\n */\n\n\nInterval.prototype.bounded = function (lo, hi) {\n  return this.set(round.prev(lo), round.next(hi));\n};\n/**\n * Equivalent to `Interval().bounded(v, v)`\n * @param {number} v\n * @return {Interval} The calling interval i.e. `this`\n */\n\n\nInterval.prototype.boundedSingleton = function (v) {\n  return this.bounded(v, v);\n};\n/**\n * Sets new endpoints for this interval, this method bypasses any\n * checks on the type of arguments\n *\n * @param {Number} lo The left endpoint of the interval\n * @param {Number} hi The right endpoint of the interval\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.set = function (lo, hi) {\n  this.lo = lo;\n  this.hi = hi;\n  return this;\n};\n/**\n * Sets new endpoints for this interval checking that both arguments exist\n * and that are valid numbers, additionally if `lo > hi` the interval is set to\n * an empty interval\n *\n * @param {Number} lo The left endpoint of the interval\n * @param {Number} hi The right endpoint of the interval\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.assign = function (lo, hi) {\n  if (typeof lo !== 'number' || typeof hi !== 'number') {\n    throw TypeError('Interval#assign: arguments must be numbers');\n  }\n\n  if (isNaN(lo) || isNaN(hi) || lo > hi) {\n    return this.setEmpty();\n  }\n\n  return this.set(lo, hi);\n};\n/**\n * Sets the endpoints of this interval to `[∞, -∞]` effectively representing\n * no values\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.setEmpty = function () {\n  return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);\n};\n/**\n * Sets the endpoints of this interval to `[-∞, ∞]` effectively representing all\n * the possible real values\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.setWhole = function () {\n  return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n};\n/**\n * Sets the endpoints of this interval to the open interval `(lo, hi)`\n *\n * NOTE: `Interval.round.disable` has no effect on this method\n *\n * @example\n * // (2, 3)\n * Interval().open(2, 3)  // {lo: 2.0000000000000004, hi: 2.9999999999999996}\n * @param {number} lo\n * @param {number} hi\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.open = function (lo, hi) {\n  return this.assign(round.safeNext(lo), round.safePrev(hi));\n};\n/**\n * Sets the endpoints of this interval to the half open interval `(lo, hi]`\n *\n * NOTE: `Interval.round.disable` has no effect on this method\n *\n * @example\n * // (2, 3]\n * Interval().halfOpenLeft(2, 3)  // {lo: 2.0000000000000004, hi: 3}\n * @param {number} lo\n * @param {number} hi\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.halfOpenLeft = function (lo, hi) {\n  return this.assign(round.safeNext(lo), hi);\n};\n/**\n * Sets the endpoints of this interval to the half open interval `[lo, hi)`\n *\n * NOTE: `Interval.round.disable` has no effect on this method\n *\n * @example\n * // [2, 3)\n * Interval.halfOpenRight(2, 3)     // {lo: 2, hi: 2.9999999999999996}\n * @param {number} lo\n * @param {number} hi\n * @return {Interval} The calling interval\n */\n\n\nInterval.prototype.halfOpenRight = function (lo, hi) {\n  return this.assign(lo, round.safePrev(hi));\n};\n/**\n * Array representation of this interval\n * @return {array}\n */\n\n\nInterval.prototype.toArray = function () {\n  return [this.lo, this.hi];\n};\n/**\n * Creates an interval equal to the calling one\n * @see Interval.clone\n * @name Interval.prototype\n * @example\n * var x = Interval(2, 3)\n * x.clone()    // Interval(2, 3)\n * @return {Interval}\n */\n\n\nInterval.prototype.clone = function () {\n  return Interval().set(this.lo, this.hi);\n};","map":null,"metadata":{},"sourceType":"script"}