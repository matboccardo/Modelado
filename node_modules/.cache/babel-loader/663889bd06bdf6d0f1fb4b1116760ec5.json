{"ast":null,"code":"import { round, uniqBy } from 'loadsh';\n\nconst nerdamer = require('nerdamer/all');\n\nvar algebrite = require('algebrite'); // devuelve el nombre de la trayectoria dependiendo en p y q.\n\n\nexport const getNodeNameByPoint = point => {\n  const p = point.p,\n        q = point.q;\n\n  if (q < 0) {\n    return {\n      text: 'Silla',\n      id: 1\n    };\n  }\n\n  if (q === 0 && p === 0) {\n    return {\n      text: 'Subte',\n      id: 2\n    };\n  }\n\n  if (q === 0 && p > 0) {\n    return {\n      text: 'Infinitos puntos de equilibrio atractores',\n      id: 3\n    };\n  }\n\n  if (q === 0 && p < 0) {\n    return {\n      text: 'Infinitos puntos de equilibrio repulsores',\n      id: 4\n    };\n  }\n\n  if (q > 0 && p === 0) {\n    return {\n      text: 'Centro',\n      id: 5\n    };\n  }\n\n  if (p > 0 && Math.abs(q - Math.pow(p, 2) / 4) < 0.00001) {\n    return {\n      text: 'Nodo atractor degenerado',\n      id: 6\n    };\n  }\n\n  if (p < 0 && Math.abs(q - Math.pow(p, 2) / 4) < 0.00001) {\n    return {\n      text: 'Nodo repulsor degenerado',\n      id: 7\n    };\n  }\n\n  if (p < 0 && q > round(Math.pow(p, 2) / 4, 10)) {\n    return {\n      text: 'Foco repulsor',\n      id: 8\n    };\n  }\n\n  if (p > 0 && q > round(Math.pow(p, 2) / 4, 10)) {\n    return {\n      text: 'Foco atractor',\n      id: 9\n    };\n  }\n\n  if (p > 0) {\n    return {\n      text: 'Nodos atractores',\n      id: 10\n    };\n  }\n\n  if (p < 0) {\n    return {\n      text: 'Nodos repulsores',\n      id: 11\n    };\n  }\n};\nexport const evaluate = (expression, resolveFor) => {\n  return parseFloat(nerdamer(expression).evaluate(resolveFor).toDecimal());\n}; // devuelve los puntos en el mapa que realments nos importa\n\nexport const findPoints = (func, p, q) => {\n  if (!func || !p || !q) return [];\n  const points = [];\n  tryToSolve(func.toString()).map(x => points.push(x));\n  tryToSolve(q.toString()).map(x => points.push(x));\n  tryToSolve(p.toString()).filter(x => evaluate(q, {\n    a: x\n  }) >= 0).map(x => points.push(x));\n  return points;\n}; // devuelve solo raizes reales\n\nconst tryToSolve = equation => {\n  try {\n    const Xequation = equation.replace(/a/g, 'x');\n\n    switch (parseInt(algebrite.deg(Xequation).toString())) {\n      //constante\n      case 0:\n        return [];\n      //polinomio de grado 1\n\n      case 1:\n        return [eval(algebrite.roots(Xequation).toString())];\n      //de mayor grado\n\n      default:\n        return uniqBy(algebrite.nroots(Xequation).tensor.elem.filter(filterIrrational).map(x => x.d));\n    }\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n};\n\nconst filterIrrational = number => !number.toString().includes('i') ? number : undefined; // Generamos 200 puntos para dibujar la curva\n\n\nexport const getPoints = (pValue, qValue) => {\n  const points = [];\n\n  for (let i = -10; i < 10; i = i + 0.05) {\n    let p = evaluate(pValue, {\n      a: i\n    });\n    let q = evaluate(qValue, {\n      a: i\n    });\n    points.push([p, q]);\n  }\n\n  return points;\n};","map":{"version":3,"sources":["C:\\Users\\L1000246\\Desktop\\Modelado2\\Modelado\\src\\helpers\\helper.js"],"names":["round","uniqBy","nerdamer","require","algebrite","getNodeNameByPoint","point","p","q","text","id","Math","abs","pow","evaluate","expression","resolveFor","parseFloat","toDecimal","findPoints","func","points","tryToSolve","toString","map","x","push","filter","a","equation","Xequation","replace","parseInt","deg","eval","roots","nroots","tensor","elem","filterIrrational","d","e","console","log","number","includes","undefined","getPoints","pValue","qValue","i"],"mappings":"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","sourcesContent":["import { round, uniqBy } from 'loadsh';\r\nconst nerdamer = require('nerdamer/all');\r\nvar algebrite = require('algebrite');\r\n\r\n// devuelve el nombre de la trayectoria dependiendo en p y q.\r\nexport const getNodeNameByPoint = (point) => {\r\n    const { p, q } = point;\r\n    if (q < 0){\r\n        return {text:'Silla', id:1};\r\n    }\r\n\r\n    if(q === 0 && p === 0){\r\n        return {text: 'Subte', id:2};\r\n    }\r\n\r\n    if(q === 0 && p > 0){\r\n        return {text: 'Infinitos puntos de equilibrio atractores', id:3};\r\n    }\r\n\r\n    if(q === 0 && p < 0){\r\n        return {text: 'Infinitos puntos de equilibrio repulsores', id:4};\r\n    }\r\n\r\n    if(q > 0 && p === 0){\r\n        return {text: 'Centro', id:5};\r\n    }\r\n\r\n    if(p > 0 && Math.abs(q - Math.pow(p,2)/4) < 0.00001){\r\n        return {text: 'Nodo atractor degenerado', id:6};\r\n    }\r\n\r\n    if(p < 0 && Math.abs(q - Math.pow(p,2)/4) < 0.00001){\r\n        return {text: 'Nodo repulsor degenerado', id:7};\r\n    }\r\n\r\n    if(p < 0 && q > round(Math.pow(p,2)/4,10)){\r\n        return {text: 'Foco repulsor', id:8};\r\n    }\r\n\r\n    if(p > 0 && q > round(Math.pow(p,2)/4,10)){\r\n        return {text: 'Foco atractor', id:9};\r\n    }\r\n\r\n    if(p > 0){\r\n        return {text: 'Nodos atractores', id:10};\r\n    }\r\n\r\n    if(p < 0){\r\n        return {text: 'Nodos repulsores', id:11};\r\n    }\r\n};\r\n\r\nexport const evaluate = (expression,resolveFor) => {\r\n    return parseFloat(nerdamer(expression).evaluate(resolveFor).toDecimal());\r\n} \r\n\r\n// devuelve los puntos en el mapa que realments nos importa\r\nexport const findPoints = (func, p, q) => {\r\n    if(!func || !p || !q) return [];\r\n    const points = [];\r\n    tryToSolve(func.toString()).map(x => points.push(x));\r\n    tryToSolve(q.toString())\r\n        .map(x => points.push(x));\r\n    tryToSolve(p.toString())\r\n        .filter(x => evaluate(q,{a:x}) >= 0)\r\n        .map(x => points.push(x));\r\n    return points;\r\n}\r\n\r\n// devuelve solo raizes reales\r\nconst tryToSolve = (equation) => {\r\n    try{\r\n        const Xequation = equation.replace(/a/g,'x');\r\n        switch (parseInt(algebrite.deg(Xequation).toString())){\r\n            //constante\r\n            case 0:\r\n                return [];\r\n            //polinomio de grado 1\r\n            case 1:\r\n                return [eval(algebrite.roots(Xequation).toString())];\r\n            //de mayor grado\r\n            default:\r\n                return uniqBy(algebrite.nroots(Xequation).tensor.elem.filter(filterIrrational).map(x => x.d));\r\n        }\r\n    }\r\n    catch(e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n}\r\n\r\nconst filterIrrational = (number) => (\r\n    !number.toString().includes('i') ? number : undefined\r\n);\r\n\r\n// Generamos 200 puntos para dibujar la curva\r\nexport const getPoints = (pValue, qValue) => {\r\n    const points = [];\r\n    for(let i=-10;i<10;i=i+0.05){\r\n        let p = evaluate(pValue,{a:i});\r\n        let q = evaluate(qValue,{a:i});\r\n        points.push([p,q]);\r\n    }\r\n    return points;\r\n}"]},"metadata":{},"sourceType":"module"}