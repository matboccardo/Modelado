{"ast":null,"code":"/**\n * Created by mauricio on 5/10/15.\n */\n'use strict';\n\nvar constants = require('../constants');\n\nvar Interval = require('../interval');\n\nvar rmath = require('../round-math');\n\nvar utils = require('./utils');\n\nvar misc = require('./misc');\n\nvar algebra = require('./algebra');\n\nvar arithmetic = require('./arithmetic');\n/**\n * @mixin trigonometric\n */\n\n\nvar trigonometric = {}; // checks if an interval is\n//\n// - [-Infinity, -Infinity]\n// - [Infinity, Infinity]\n//\n\nfunction onlyInfinity(x) {\n  return !isFinite(x.lo) && x.lo === x.hi;\n} // moves interval 2PI * k to the right until both\n// bounds are positive\n\n\nfunction handleNegative(interval) {\n  if (interval.lo < 0) {\n    if (interval.lo === -Infinity) {\n      interval.lo = 0;\n      interval.hi = Infinity;\n    } else {\n      var n = Math.ceil(-interval.lo / constants.PI_TWICE_LOW);\n      interval.lo += constants.PI_TWICE_LOW * n;\n      interval.hi += constants.PI_TWICE_LOW * n;\n    }\n  }\n\n  return interval;\n}\n/**\n * Computes the cosine of `x`\n * @example\n * Interval.cos(\n *   Interval(0, 0)\n * ) // Interval(1, 1)\n * @example\n * Interval.cos(\n *   Interval(0, Math.PI / 2)\n * ) // Interval(0, 1)\n * @example\n * Interval.cos(\n *   Interval(3 * Math.PI / 2, 3 * Math.PI)\n * ) // Interval(-1, 1)\n * @example\n * Interval.cos(\n *   Interval(-Infinity, x)\n * )\n * // Interval(-1, 1) if x > -Infinity\n * // Interval.EMPTY otherwise\n * @example\n * Interval.cos(\n *   Interval(x, Infinity)\n * )\n * // Interval(-1, 1) if x < Infinity\n * // Interval.EMPTY otherwise\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.cos = function (x) {\n  var rlo, rhi;\n\n  if (utils.isEmpty(x) || onlyInfinity(x)) {\n    return constants.EMPTY;\n  } // create a clone of `x` because the clone is going to be modified\n\n\n  var cache = Interval();\n  cache.set(x.lo, x.hi);\n  handleNegative(cache);\n  var pi2 = constants.PI_TWICE;\n  var t = algebra.fmod(cache, pi2);\n\n  if (misc.width(t) >= pi2.lo) {\n    return Interval(-1, 1);\n  } // when t.lo > pi it's the same as\n  // -cos(t - pi)\n\n\n  if (t.lo >= constants.PI_HIGH) {\n    var cos = trigonometric.cos(arithmetic.sub(t, constants.PI));\n    return arithmetic.negative(cos);\n  }\n\n  var lo = t.lo;\n  var hi = t.hi;\n  rlo = rmath.cosLo(hi);\n  rhi = rmath.cosHi(lo); // it's ensured that t.lo < pi and that t.lo >= 0\n\n  if (hi <= constants.PI_LOW) {\n    // when t.hi < pi\n    // [cos(t.lo), cos(t.hi)]\n    return Interval(rlo, rhi);\n  } else if (hi <= pi2.lo) {\n    // when t.hi < 2pi\n    // [-1, max(cos(t.lo), cos(t.hi))]\n    return Interval(-1, Math.max(rlo, rhi));\n  } else {\n    // t.lo < pi and t.hi > 2pi\n    return Interval(-1, 1);\n  }\n};\n/**\n * Computes the sine of `x`\n * @example\n * Interval.sin(\n *   Interval(0, 0)\n * ) // Interval(0, 0)\n * @example\n * Interval.sin(\n *   Interval(0, Math.PI / 2)\n * ) // Interval(0, 1)\n * @example\n * Interval.sin(\n *   Interval(Math.PI / 2, Math.PI / 2)\n * ) // Interval(1, 1)\n * @example\n * Interval.sin(\n *   Interval(Math.PI / 2, -Math.PI / 2)\n * ) // Interval(-1, 1)\n * @example\n * Interval.sin(\n *   Interval(Math.PI, 3 * Math.PI / 2)\n * ) // Interval(-1, 0)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.sin = function (x) {\n  if (utils.isEmpty(x) || onlyInfinity(x)) {\n    return constants.EMPTY;\n  }\n\n  return trigonometric.cos(arithmetic.sub(x, constants.PI_HALF));\n};\n/**\n * Computes the tangent of `x`\n * @example\n * Interval.tan(\n *   Interval(-Math.PI / 4, Math.PI / 4)\n * ) // Interval(-1, 1)\n * @example\n * Interval.tan(\n *   Interval(0, Math.PI / 2)\n * ) // Interval.WHOLE\n * @example\n * Interval.tan(\n *   Interval(-Infinity, x)\n * )\n * // Interval.WHOLE if x > -Infinity\n * // Interval.EMPTY othewise\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.tan = function (x) {\n  if (utils.isEmpty(x) || onlyInfinity(x)) {\n    return constants.EMPTY;\n  } // create a clone of `x` because the clone is going to be modified\n\n\n  var cache = Interval();\n  cache.set(x.lo, x.hi);\n  handleNegative(cache);\n  var pi = constants.PI;\n  var t = algebra.fmod(cache, pi);\n\n  if (t.lo >= constants.PI_HALF_LOW) {\n    t = arithmetic.sub(t, pi);\n  }\n\n  if (t.lo <= -constants.PI_HALF_LOW || t.hi >= constants.PI_HALF_LOW) {\n    return constants.WHOLE;\n  }\n\n  return Interval(rmath.tanLo(t.lo), rmath.tanHi(t.hi));\n};\n/**\n * Computes the arcsine of `x`\n * @example\n * Interval.asin(\n *   Interval(-1.57079633, 1.57079633)\n * )  // Interval(-10, 10)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.asin = function (x) {\n  if (utils.isEmpty(x) || x.hi < -1 || x.lo > 1) {\n    return constants.EMPTY;\n  }\n\n  var lo = x.lo <= -1 ? -constants.PI_HALF_HIGH : rmath.asinLo(x.lo);\n  var hi = x.hi >= 1 ? constants.PI_HALF_HIGH : rmath.asinHi(x.hi);\n  return Interval(lo, hi);\n};\n/**\n * Computes the arccosine of `x`\n * @example\n * Interval.acos(\n *   Interval(0, 1)\n * )  // Interval(0, Math.PI / 2)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.acos = function (x) {\n  if (utils.isEmpty(x) || x.hi < -1 || x.lo > 1) {\n    return constants.EMPTY;\n  }\n\n  var lo = x.hi >= 1 ? 0 : rmath.acosLo(x.hi);\n  var hi = x.lo <= -1 ? constants.PI_HIGH : rmath.acosHi(x.lo);\n  return Interval(lo, hi);\n};\n/**\n * Computes the arctangent of `x`\n * @example\n * Interval.atan(\n *   Interval(-1, 1)\n * )  // Interval(-0.785398163, 0.785398163)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.atan = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return Interval(rmath.atanLo(x.lo), rmath.atanHi(x.hi));\n};\n/**\n * Computes the hyperbolic sine of `x`\n * @example\n * Interval.sinh(\n *   Interval(-2, 2)\n * )  // Interval(-3.6286040785, 3.6286040785)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.sinh = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return Interval(rmath.sinhLo(x.lo), rmath.sinhHi(x.hi));\n};\n/**\n * Computes the hyperbolic cosine of `x`\n * @example\n * Interval.cosh(\n *   Interval(-2, 2)\n * )  // Interval(1, 3.76219569108)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.cosh = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  if (x.hi < 0) {\n    return Interval(rmath.coshLo(x.hi), rmath.coshHi(x.lo));\n  } else if (x.lo >= 0) {\n    return Interval(rmath.coshLo(x.lo), rmath.coshHi(x.hi));\n  } else {\n    return Interval(1, rmath.coshHi(-x.lo > x.hi ? x.lo : x.hi));\n  }\n};\n/**\n * Computes the hyperbolic tangent of `x`\n * @example\n * Interval.tanh(\n *   Interval(-Infinity, Infinity)\n * )  // Interval(-1, 1)\n * @param {Interval} x\n * @return {Interval}\n */\n\n\ntrigonometric.tanh = function (x) {\n  if (utils.isEmpty(x)) {\n    return constants.EMPTY;\n  }\n\n  return Interval(rmath.tanhLo(x.lo), rmath.tanhHi(x.hi));\n};\n\nmodule.exports = trigonometric;","map":null,"metadata":{},"sourceType":"script"}