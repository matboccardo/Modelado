{"ast":null,"code":"// Created by mauricio on 4/27/15.\n'use strict';\n\nvar nextafter = require('nextafter');\n/**\n * @module interval-arithmetic/round-math\n */\n\n\nfunction identity(v) {\n  return v;\n}\n\nfunction prev(v) {\n  if (v === Infinity) {\n    return v;\n  }\n\n  return nextafter(v, -Infinity);\n}\n\nfunction next(v) {\n  if (v === -Infinity) {\n    return v;\n  }\n\n  return nextafter(v, Infinity);\n}\n/**\n * @alias module:interval-arithmetic/round-math\n */\n\n\nvar round = {\n  /**\n   * Computes the previous IEEE floating point representation of `v`\n   * @example\n   * Interval.round.safePrev(1)          // 0.9999999999999999\n   * Interval.round.safePrev(3)          // 2.9999999999999996\n   * Interval.round.safePrev(Infinity)   // Infinity\n   * @param {number} v\n   * @return {number}\n   * @function\n   */\n  safePrev: prev,\n\n  /**\n   * Computes the next IEEE floating point representation of `v`\n   * @example\n   * Interval.round.safeNext(1)          // 1.0000000000000002\n   * Interval.round.safeNext(3)          // 3.0000000000000004\n   * Interval.round.safeNext(-Infinity)  // -Infinity\n   * @param {number} v\n   * @return {number}\n   * @function\n   */\n  safeNext: next,\n  prev: prev,\n  next: next\n};\n\nround.addLo = function (x, y) {\n  return this.prev(x + y);\n};\n\nround.addHi = function (x, y) {\n  return this.next(x + y);\n};\n\nround.subLo = function (x, y) {\n  return this.prev(x - y);\n};\n\nround.subHi = function (x, y) {\n  return this.next(x - y);\n};\n\nround.mulLo = function (x, y) {\n  return this.prev(x * y);\n};\n\nround.mulHi = function (x, y) {\n  return this.next(x * y);\n};\n\nround.divLo = function (x, y) {\n  return this.prev(x / y);\n};\n\nround.divHi = function (x, y) {\n  return this.next(x / y);\n};\n\nfunction toInteger(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n\nround.intLo = function (x) {\n  return toInteger(this.prev(x));\n};\n\nround.intHi = function (x) {\n  return toInteger(this.next(x));\n};\n\nround.logLo = function (x) {\n  return this.prev(Math.log(x));\n};\n\nround.logHi = function (x) {\n  return this.next(Math.log(x));\n};\n\nround.expLo = function (x) {\n  return this.prev(Math.exp(x));\n};\n\nround.expHi = function (x) {\n  return this.next(Math.exp(x));\n};\n\nround.sinLo = function (x) {\n  return this.prev(Math.sin(x));\n};\n\nround.sinHi = function (x) {\n  return this.next(Math.sin(x));\n};\n\nround.cosLo = function (x) {\n  return this.prev(Math.cos(x));\n};\n\nround.cosHi = function (x) {\n  return this.next(Math.cos(x));\n};\n\nround.tanLo = function (x) {\n  return this.prev(Math.tan(x));\n};\n\nround.tanHi = function (x) {\n  return this.next(Math.tan(x));\n};\n\nround.asinLo = function (x) {\n  return this.prev(Math.asin(x));\n};\n\nround.asinHi = function (x) {\n  return this.next(Math.asin(x));\n};\n\nround.acosLo = function (x) {\n  return this.prev(Math.acos(x));\n};\n\nround.acosHi = function (x) {\n  return this.next(Math.acos(x));\n};\n\nround.atanLo = function (x) {\n  return this.prev(Math.atan(x));\n};\n\nround.atanHi = function (x) {\n  return this.next(Math.atan(x));\n}; // polyfill required for hyperbolic functions\n\n\nround.sinhLo = function (x) {\n  return this.prev(Math.sinh(x));\n};\n\nround.sinhHi = function (x) {\n  return this.next(Math.sinh(x));\n};\n\nround.coshLo = function (x) {\n  return this.prev(Math.cosh(x));\n};\n\nround.coshHi = function (x) {\n  return this.next(Math.cosh(x));\n};\n\nround.tanhLo = function (x) {\n  return this.prev(Math.tanh(x));\n};\n\nround.tanhHi = function (x) {\n  return this.next(Math.tanh(x));\n};\n/*\n * @ignore\n * ln(power) exponentiation of x\n * @param {number} x\n * @param {number} power\n * @returns {number}\n */\n\n\nround.powLo = function (x, power) {\n  if (power % 1 !== 0) {\n    // power has decimals\n    return this.prev(Math.pow(x, power));\n  }\n\n  var y = power & 1 ? x : 1;\n  power >>= 1;\n\n  while (power > 0) {\n    x = round.mulLo(x, x);\n\n    if (power & 1) {\n      y = round.mulLo(x, y);\n    }\n\n    power >>= 1;\n  }\n\n  return y;\n};\n/*\n * @ignore\n * ln(power) exponentiation of x\n * @param {number} x\n * @param {number} power\n * @returns {number}\n */\n\n\nround.powHi = function (x, power) {\n  if (power % 1 !== 0) {\n    // power has decimals\n    return this.next(Math.pow(x, power));\n  }\n\n  var y = power & 1 ? x : 1;\n  power >>= 1;\n\n  while (power > 0) {\n    x = round.mulHi(x, x);\n\n    if (power & 1) {\n      y = round.mulHi(x, y);\n    }\n\n    power >>= 1;\n  }\n\n  return y;\n};\n\nround.sqrtLo = function (x) {\n  return this.prev(Math.sqrt(x));\n};\n\nround.sqrtHi = function (x) {\n  return this.next(Math.sqrt(x));\n};\n/**\n * Most operations on intervals will cary the rounding error so that the\n * resulting interval correctly represents all the possible values, this feature\n * can be disabled by calling this method allowing a little boost in the\n * performance while operating on intervals\n *\n * @see module:interval-arithmetic/round-math.enable\n * @example\n * var x = Interval.add(\n *   Interval(1),\n *   Interval(1)\n * )\n * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}\n *\n * Interval.round.disable()\n * var y = Interval.add(\n *   Interval(1),\n *   Interval(1)\n * )\n * y // equal to {lo: 2, hi: 2}\n * @function\n */\n\n\nround.disable = function () {\n  this.next = this.prev = identity;\n};\n/**\n * Enables IEEE previous/next floating point wrapping of values (enabled by\n * default)\n * @see module:interval-arithmetic/round-math.disable\n * @example\n * var x = Interval.add(\n *   Interval(1),\n *   Interval(1)\n * )\n * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}\n *\n * Interval.round.disable()\n * var y = Interval.add(\n *   Interval(1),\n *   Interval(1)\n * )\n * y // equal to {lo: 2, hi: 2}\n *\n * Interval.round.enable()\n * var z = Interval.add(\n *   Interval(1),\n *   Interval(1)\n * )\n * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}\n * @function\n */\n\n\nround.enable = function () {\n  this.next = next;\n  this.prev = prev;\n};\n\nmodule.exports = round;","map":null,"metadata":{},"sourceType":"script"}