{"ast":null,"code":"'use strict';\n\nvar samplers = {\n  interval: require('interval-arithmetic-eval'),\n  builtIn: require('built-in-math-eval')\n};\n\nvar extend = require('extend');\n\nwindow.math && (samplers.builtIn = window.math.compile);\n\nfunction generateEvaluator(samplerName) {\n  function doCompile(expression) {\n    // compiles does the following\n    //\n    // when expression === string\n    //\n    //     gen = new require('math-codegen')\n    //     return gen.parse(expression).compile(Interval|BultInMath)\n    //\n    //     which is an object with the form\n    //\n    //     {\n    //       eval: function (scope) {\n    //         // math-codegen magic\n    //       }\n    //     }\n    //\n    // when expression === function\n    //\n    //    {\n    //      eval: expression\n    //    }\n    //\n    // othewise throw an error\n    if (typeof expression === 'string') {\n      var compile = samplers[samplerName];\n      return compile(expression);\n    } else if (typeof expression === 'function') {\n      return {\n        eval: expression\n      };\n    } else {\n      throw Error('expression must be a string or a function');\n    }\n  }\n\n  function compileIfPossible(meta, property) {\n    // compile the function using interval arithmetic, cache the result\n    // so that multiple calls with the same argument don't trigger the\n    // kinda expensive compilation process\n    var expression = meta[property];\n    var hiddenProperty = samplerName + '_Expression_' + property;\n    var hiddenCompiled = samplerName + '_Compiled_' + property;\n\n    if (expression !== meta[hiddenProperty]) {\n      meta[hiddenProperty] = expression;\n      meta[hiddenCompiled] = doCompile(expression);\n    }\n  }\n\n  function getCompiledExpression(meta, property) {\n    return meta[samplerName + '_Compiled_' + property];\n  }\n  /**\n   * Evaluates meta[property] with `variables`\n   *\n   * - Compiles meta[property] if it wasn't compiled already (also with cache\n   *   check)\n   * - Evaluates the resulting function with the merge of meta.scope and\n   *   `variables`\n   *\n   * @param {Object} meta\n   * @param {String} property\n   * @param {Object} variables\n   * @returns {Number|Array} The builtIn evaluator returns a number, the\n   * interval evaluator an array\n   */\n\n\n  function evaluate(meta, property, variables) {\n    // e.g.\n    //\n    //  meta: {\n    //    fn: 'x + 3',\n    //    scope: { y: 3 }\n    //  }\n    //  property: 'fn'\n    //  variables:  { x: 3 }\n    //\n    compileIfPossible(meta, property);\n    return getCompiledExpression(meta, property).eval(extend({}, meta.scope || {}, variables));\n  }\n\n  return evaluate;\n}\n\nmodule.exports.builtIn = generateEvaluator('builtIn');\nmodule.exports.interval = generateEvaluator('interval');","map":null,"metadata":{},"sourceType":"script"}