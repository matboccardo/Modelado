{"ast":null,"code":"var tokenType = require('./token-type');\n\nvar Lexer = require('./Lexer');\n\nvar ConstantNode = require('./node/ConstantNode');\n\nvar OperatorNode = require('./node/OperatorNode');\n\nvar UnaryNode = require('./node/UnaryNode');\n\nvar SymbolNode = require('./node/SymbolNode');\n\nvar FunctionNode = require('./node/FunctionNode');\n\nvar ArrayNode = require('./node/ArrayNode');\n\nvar ConditionalNode = require('./node/ConditionalNode');\n\nvar AssignmentNode = require('./node/AssignmentNode');\n\nvar BlockNode = require('./node/BlockNode');\n/**\n * Grammar DSL:\n *\n * program          : block (; block)*\n *\n * block            : assignment\n *\n * assignment       : ternary\n *                  | symbol `=` assignment\n *\n * ternary          : logicalOR\n *                  | logicalOR `?` ternary `:` ternary\n *\n * logicalOR        : logicalXOR\n *                  | logicalXOR (`||`,`or`) logicalOR\n *\n * logicalXOR       : logicalAND\n *                  : logicalAND `xor` logicalXOR\n *\n * logicalAND       : bitwiseOR\n *                  | bitwiseOR (`&&`,`and`) logicalAND\n *\n * bitwiseOR        : bitwiseXOR\n *                  | bitwiseXOR `|` bitwiseOR\n *\n * bitwiseXOR       : bitwiseAND\n *                  | bitwiseAND `^|` bitwiseXOR\n *\n * bitwiseAND       : relational\n *                  | relational `&` bitwiseAND\n *\n * relational       : shift\n *                  | shift (`!=` | `==` | `>` | '<' | '<=' |'>=') shift)\n *\n * shift            : additive\n *                  | additive (`>>` | `<<` | `>>>`) shift\n *\n * additive         : multiplicative\n *                  | multiplicative (`+` | `-`) additive\n *\n * multiplicative   : unary\n *                  | unary (`*` | `/` | `%`) unary\n *                  | unary symbol\n *\n * unary            : pow\n *                  | (`-` | `+` | `~`) unary\n *\n * pow              : factorial\n *                  | factorial (`^`, '**') unary\n *\n * factorial        : symbol\n *                  | symbol (`!`)\n *\n * symbol           : symbolToken\n *                  | symbolToken functionCall\n *                  | string\n *\n * functionCall     : `(` `)`\n *                  | `(` ternary (, ternary)* `)`\n *\n * string           : `'` (character)* `'`\n *                  : `\"` (character)* `\"`\n *                  | array\n *\n * array            : `[` `]`\n *                  | `[` assignment (, assignment)* `]`\n *                  | number\n *\n * number           : number-token\n *                  | parentheses\n *\n * parentheses      : `(` assignment `)`\n *                  : end\n *\n * end              : NULL\n *\n * @param {[type]} lexer [description]\n */\n\n\nfunction Parser() {\n  this.lexer = new Lexer();\n  this.tokens = null;\n}\n\nParser.prototype.current = function () {\n  return this.tokens[0];\n};\n\nParser.prototype.next = function () {\n  return this.tokens[1];\n};\n\nParser.prototype.peek = function () {\n  if (this.tokens.length) {\n    var first = this.tokens[0];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      if (first.value === arguments[i]) {\n        return true;\n      }\n    }\n  }\n};\n\nParser.prototype.consume = function (e) {\n  return this.tokens.shift();\n};\n\nParser.prototype.expect = function (e) {\n  if (!this.peek(e)) {\n    throw Error('expected ' + e);\n  }\n\n  return this.consume();\n};\n\nParser.prototype.isEOF = function () {\n  return this.current().type === tokenType.EOF;\n};\n\nParser.prototype.parse = function (text) {\n  this.tokens = this.lexer.lex(text);\n  return this.program();\n};\n\nParser.prototype.program = function () {\n  var blocks = [];\n\n  while (!this.isEOF()) {\n    blocks.push(this.assignment());\n\n    if (this.peek(';')) {\n      this.consume();\n    }\n  }\n\n  this.end();\n  return new BlockNode(blocks);\n};\n\nParser.prototype.assignment = function () {\n  var left = this.ternary();\n\n  if (left instanceof SymbolNode && this.peek('=')) {\n    this.consume();\n    return new AssignmentNode(left.name, this.assignment());\n  }\n\n  return left;\n};\n\nParser.prototype.ternary = function () {\n  var predicate = this.logicalOR();\n\n  if (this.peek('?')) {\n    this.consume();\n    var truthy = this.ternary();\n    this.expect(':');\n    var falsy = this.ternary();\n    return new ConditionalNode(predicate, truthy, falsy);\n  }\n\n  return predicate;\n};\n\nParser.prototype.logicalOR = function () {\n  var left = this.logicalXOR();\n\n  if (this.peek('||')) {\n    var op = this.consume();\n    var right = this.logicalOR();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.logicalXOR = function () {\n  var left = this.logicalAND();\n\n  if (this.current().value === 'xor') {\n    var op = this.consume();\n    var right = this.logicalXOR();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.logicalAND = function () {\n  var left = this.bitwiseOR();\n\n  if (this.peek('&&')) {\n    var op = this.consume();\n    var right = this.logicalAND();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.bitwiseOR = function () {\n  var left = this.bitwiseXOR();\n\n  if (this.peek('|')) {\n    var op = this.consume();\n    var right = this.bitwiseOR();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.bitwiseXOR = function () {\n  var left = this.bitwiseAND();\n\n  if (this.peek('^|')) {\n    var op = this.consume();\n    var right = this.bitwiseXOR();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.bitwiseAND = function () {\n  var left = this.relational();\n\n  if (this.peek('&')) {\n    var op = this.consume();\n    var right = this.bitwiseAND();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.relational = function () {\n  var left = this.shift();\n\n  if (this.peek('==', '===', '!=', '!==', '>=', '<=', '>', '<')) {\n    var op = this.consume();\n    var right = this.shift();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.shift = function () {\n  var left = this.additive();\n\n  if (this.peek('>>', '<<', '>>>')) {\n    var op = this.consume();\n    var right = this.shift();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.additive = function () {\n  var left = this.multiplicative();\n\n  while (this.peek('+', '-')) {\n    var op = this.consume();\n    left = new OperatorNode(op.value, [left, this.multiplicative()]);\n  }\n\n  return left;\n};\n\nParser.prototype.multiplicative = function () {\n  var op, right;\n  var left = this.unary();\n\n  while (this.peek('*', '/', '%')) {\n    op = this.consume();\n    left = new OperatorNode(op.value, [left, this.unary()]);\n  } // implicit multiplication\n  // - 2 x\n  // - 2(x)\n  // - (2)2\n\n\n  if (this.current().type === tokenType.SYMBOL || this.peek('(') || !(left.type instanceof ConstantNode) && this.current().type === tokenType.NUMBER) {\n    right = this.multiplicative();\n    return new OperatorNode('*', [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.unary = function () {\n  if (this.peek('-', '+', '~')) {\n    var op = this.consume();\n    var right = this.unary();\n    return new UnaryNode(op.value, right);\n  }\n\n  return this.pow();\n};\n\nParser.prototype.pow = function () {\n  var left = this.factorial();\n\n  if (this.peek('^', '**')) {\n    var op = this.consume();\n    var right = this.unary();\n    return new OperatorNode(op.value, [left, right]);\n  }\n\n  return left;\n};\n\nParser.prototype.factorial = function () {\n  var left = this.symbol();\n\n  if (this.peek('!')) {\n    var op = this.consume();\n    return new OperatorNode(op.value, [left]);\n  }\n\n  return left;\n};\n\nParser.prototype.symbol = function () {\n  var current = this.current();\n\n  if (current.type === tokenType.SYMBOL) {\n    var symbol = this.consume();\n    var node = this.functionCall(symbol);\n    return node;\n  }\n\n  return this.string();\n};\n\nParser.prototype.functionCall = function (symbolToken) {\n  var name = symbolToken.value;\n\n  if (this.peek('(')) {\n    this.consume();\n    var params = [];\n\n    while (!this.peek(')') && !this.isEOF()) {\n      params.push(this.assignment());\n\n      if (this.peek(',')) {\n        this.consume();\n      }\n    }\n\n    this.expect(')');\n    return new FunctionNode(name, params);\n  }\n\n  return new SymbolNode(name);\n};\n\nParser.prototype.string = function () {\n  if (this.current().type === tokenType.STRING) {\n    return new ConstantNode(this.consume().value, 'string');\n  }\n\n  return this.array();\n};\n\nParser.prototype.array = function () {\n  if (this.peek('[')) {\n    this.consume();\n    var params = [];\n\n    while (!this.peek(']') && !this.isEOF()) {\n      params.push(this.assignment());\n\n      if (this.peek(',')) {\n        this.consume();\n      }\n    }\n\n    this.expect(']');\n    return new ArrayNode(params);\n  }\n\n  return this.number();\n};\n\nParser.prototype.number = function () {\n  var token = this.current();\n\n  if (token.type === tokenType.NUMBER) {\n    return new ConstantNode(this.consume().value, 'number');\n  }\n\n  return this.parentheses();\n};\n\nParser.prototype.parentheses = function () {\n  var token = this.current();\n\n  if (token.value === '(') {\n    this.consume();\n    var left = this.assignment();\n    this.expect(')');\n    return left;\n  }\n\n  return this.end();\n};\n\nParser.prototype.end = function () {\n  var token = this.current();\n\n  if (token.type !== tokenType.EOF) {\n    throw Error('unexpected end of expression');\n  }\n};\n\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}