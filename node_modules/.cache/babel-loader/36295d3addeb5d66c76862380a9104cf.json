{"ast":null,"code":"//  Created by mauricio on 5/10/15.\n'use strict';\n/**\n * @mixin utils\n */\n\nvar utils = {};\n/**\n * Checks if `x` is an interval, `x` is an interval if it's an object which has\n * `x.lo` and `x.hi` defined and both are numbers\n * @example\n * Interval.isInterval(\n *   Interval()\n * ) // true\n * @example\n * Interval.isInterval(\n *   undefined\n * ) // false\n * @example\n * Interval.isInterval(\n *   {lo: 1, hi: 2}\n * ) // true\n * @param  {*} x\n * @return {Boolean} true if `x` is an interval\n */\n\nutils.isInterval = function (x) {\n  return typeof x === 'object' && typeof x.lo === 'number' && typeof x.hi === 'number';\n};\n/**\n * Checks if `x` is empty, it's empty when `x.lo > x.hi`\n * @example\n * Interval.isEmpty(\n *   Interval.EMPTY\n * ) // true\n * @example\n * Interval.isEmpty(\n *   Interval.WHOLE\n * ) // false\n * @example\n * Interval.isEmpty(\n *   // bypass empty interval check\n *   Interval().set(1, -1)\n * ) // true\n * @param {Interval} x\n * @returns {boolean}\n */\n\n\nutils.isEmpty = function (x) {\n  return x.lo > x.hi;\n};\n/**\n * Checks if an interval is a whole interval, that is an interval which covers\n * all the real numbers i.e. when `x.lo === -Infinity` and `x.hi === Infinity`\n * @example\n * Interval.isWhole(\n *   Interval.WHOLE\n * ) // true\n * @param {Interval} x\n * @returns {boolean}\n */\n\n\nutils.isWhole = function (x) {\n  return x.lo === -Infinity && x.hi === Infinity;\n};\n/**\n * Checks if the intervals `x` is a singleton (an interval representing a single\n * value) i.e. when `x.lo === x.hi`\n * @example\n * Interval.isSingleton(\n *  Interval(2, 2)\n * ) // true\n * @example\n * Interval.isSingleton(\n *  Interval(2)\n * ) // true\n * @param {Interval} x\n * @returns {boolean}\n */\n\n\nutils.isSingleton = function (x) {\n  return x.lo === x.hi;\n};\n/**\n * Checks if zero is included in the interval `x`\n * @example\n * Interval.zeroIn(\n *   Interval(-1, 1)\n * ) // true\n * @param {Interval} x\n * @returns {boolean}\n */\n\n\nutils.zeroIn = function (x) {\n  return utils.hasValue(x, 0);\n};\n/**\n * Checks if `value` is included in the interval `x`\n * @example\n * Interval.hasValue(\n *   Interval(-1, 1),\n *   0\n * ) // true\n * @example\n * Interval.hasValue(\n *   Interval(-1, 1),\n *   10\n * ) // false\n * @param {Interval} x\n * @param {number} value\n * @returns {boolean}\n */\n\n\nutils.hasValue = function (a, value) {\n  if (utils.isEmpty(a)) {\n    return false;\n  }\n\n  return a.lo <= value && value <= a.hi;\n};\n/**\n * Checks if `x` is a subset of `y`\n * @example\n * Interval.hasInteravl(\n *   Interval(0, 3),\n *   Interval(1, 2)\n * ) // true\n * @example\n * Interval.hasInteravl(\n *   Interval(0, 3),\n *   Interval(1, 4)\n * ) // false\n * @param {Interval} x\n * @param {Interval} y\n * @returns {boolean}\n */\n\n\nutils.hasInterval = function (x, y) {\n  if (utils.isEmpty(x)) {\n    return true;\n  }\n\n  return !utils.isEmpty(y) && y.lo <= x.lo && x.hi <= y.hi;\n};\n/**\n * Checks if the intervals `x`, `y` overlap i.e. if they share at least one\n * value\n * @example\n * Interval.intervalsOverlap(\n *   Interval(0, 3),\n *   Interval(1, 2)\n * ) // true\n * @example\n * Interval.intervalsOverlap(\n *   Interval(0, 2),\n *   Interval(1, 3)\n * ) // true\n * @example\n * Interval.intervalsOverlap(\n *   Interval(0, 2),\n *   Interval(2, 3)\n * ) // true\n * @example\n * Interval.intervalsOverlap(\n *   Interval(0, 1),\n *   Interval(2, 3)\n * ) // false\n * @param {Interval} x\n * @param {Interval} y\n * @returns {boolean}\n */\n\n\nutils.intervalsOverlap = function (x, y) {\n  if (utils.isEmpty(x) || utils.isEmpty(y)) {\n    return false;\n  }\n\n  return x.lo <= y.lo && y.lo <= x.hi || y.lo <= x.lo && x.lo <= y.hi;\n};\n\nmodule.exports = utils;","map":null,"metadata":{},"sourceType":"script"}