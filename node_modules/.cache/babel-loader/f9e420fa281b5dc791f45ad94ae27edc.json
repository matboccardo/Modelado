{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus');\n\n  require('./Algebra');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Symbol = core.Symbol,\n      format = core.Utils.format,\n      isVector = core.Utils.isVector,\n      isArray = core.Utils.isArray,\n      Vector = core.Vector,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      FN = core.groups.FN;\n  core.Settings.Laplace_integration_depth = 40;\n\n  Symbol.prototype.findFunction = function (fname) {\n    //this is what we're looking for\n    if (this.group === FN && this.fname === fname) return this.clone();\n    var found;\n    if (this.symbols) for (var x in this.symbols) {\n      found = this.symbols[x].findFunction(fname);\n      if (found) break;\n    }\n    return found;\n  };\n\n  var __ = core.Extra = {\n    version: '1.4.1',\n    //http://integral-table.com/downloads/LaplaceTable.pdf\n    //Laplace assumes all coefficients to be positive\n    LaPlace: {\n      //Using: integral_0^oo f(t)*e^(-s*t) dt\n      transform: function (symbol, t, s) {\n        t = t.toString(); //First try a lookup for a speed boost\n\n        symbol = Symbol.unwrapSQRT(symbol, true);\n        var retval,\n            coeff = symbol.stripVar(t),\n            g = symbol.group;\n        symbol = _.divide(symbol, coeff.clone());\n\n        if (symbol.isConstant() || !symbol.contains(t, true)) {\n          retval = _.parse(format('({0})/({1})', symbol, s));\n        } else if (g === S && core.Utils.isInt(symbol.power)) {\n          var n = String(symbol.power);\n          retval = _.parse(format('factorial({0})/({1})^({0}+1)', n, s));\n        } else if (symbol.group === S && symbol.power.equals(1 / 2)) {\n          retval = _.parse(format('sqrt(pi)/(2*({0})^(3/2))', s));\n        } else if (symbol.isComposite()) {\n          retval = new Symbol(0);\n          symbol.each(function (x) {\n            retval = _.add(retval, __.LaPlace.transform(x, t, s));\n          }, true);\n        } else if (symbol.isE() && (symbol.power.group === S || symbol.power.group === CB)) {\n          var a = symbol.power.stripVar(t);\n          retval = _.parse(format('1/(({1})-({0}))', a, s));\n        } else {\n          var fns = ['sin', 'cos', 'sinh', 'cosh']; //support for symbols in fns with arguments in the form a*t or n*t where a = symbolic and n = Number\n\n          if (symbol.group === FN && fns.indexOf(symbol.fname) !== -1 && (symbol.args[0].group === S || symbol.args[0].group === CB)) {\n            var a = symbol.args[0].stripVar(t);\n\n            switch (symbol.fname) {\n              case 'sin':\n                retval = _.parse(format('({0})/(({1})^2+({0})^2)', a, s));\n                break;\n\n              case 'cos':\n                retval = _.parse(format('({1})/(({1})^2+({0})^2)', a, s));\n                break;\n\n              case 'sinh':\n                retval = _.parse(format('({0})/(({1})^2-({0})^2)', a, s));\n                break;\n\n              case 'cosh':\n                retval = _.parse(format('({1})/(({1})^2-({0})^2)', a, s));\n                break;\n            }\n          } else {\n            //Try to integrate for a solution\n            //we need at least the Laplace integration depth\n            var depth_is_lower = core.Settings.integration_depth < core.Settings.Laplace_integration_depth;\n\n            if (depth_is_lower) {\n              var integration_depth = core.Settings.integration_depth; //save the depth\n\n              core.Settings.integration_depth = core.Settings.Laplace_integration_depth; //transforms need a little more room\n            }\n\n            core.Utils.block('PARSE2NUMBER', function () {\n              var u = t;\n              var sym = symbol.sub(t, u);\n\n              var integration_expr = _.parse('e^(-' + s + '*' + u + ')*' + sym);\n\n              retval = core.Calculus.integrate(integration_expr, u);\n              if (retval.hasIntegral()) _.error('Unable to compute transform');\n              retval = retval.sub(t, 0);\n              retval = _.expand(_.multiply(retval, new Symbol(-1)));\n              retval = retval.sub(u, t);\n            }, false);\n            retval = core.Utils.block('PARSE2NUMBER', function () {\n              return _.parse(retval);\n            }, true);\n            if (depth_is_lower) //put the integration depth as it was\n              core.Settings.integration_depth = integration_depth;\n          }\n        }\n\n        return _.multiply(retval, coeff);\n      },\n      inverse: function (symbol, s_, t) {\n        var input_symbol = symbol.clone();\n        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n          if (symbol.group === S || symbol.group === CB || symbol.group === CP) {\n            var finalize = function () {\n              //put back the numerator\n              retval = _.multiply(retval, num);\n              retval.multiplier = retval.multiplier.multiply(symbol.multiplier); //put back a\n\n              retval = _.divide(retval, f.a);\n            };\n\n            var num, den, s, retval, f, p, m, den_p, fe; //remove the multiplier\n\n            m = symbol.multiplier.clone();\n            symbol.toUnitMultiplier(); //get the numerator and denominator\n\n            num = symbol.getNum();\n            den = symbol.getDenom().toUnitMultiplier(); //TODO: Make it so factor doesn't destroy pi\n            //num = core.Algebra.Factor.factor(symbol.getNum());\n            //den = core.Algebra.Factor.factor(symbol.getDenom().invert(null, true));\n\n            if (den.group === CP) {\n              den_p = den.power.clone();\n              den.toLinear();\n            } else den_p = new core.Frac(1); //convert s to a string\n\n\n            s = s_.toString(); //split up the denominator if in the form ax+b\n\n            f = core.Utils.decompose_fn(den, s, true); //move the multiplier to the numerator\n\n            fe = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\n            num.multiplier = num.multiplier.multiply(m); //store the parts in variables for easy recognition \n            //check if in the form t^n where n = integer\n\n            if ((den.group === S || den.group === CB) && f.x.value === s && f.b.equals(0) && core.Utils.isInt(f.x.power)) {\n              var fact, p;\n              p = f.x.power - 1;\n              fact = core.Math2.factorial(p); //  n!/s^(n-1)\n\n              retval = _.divide(_.pow(t, new Symbol(p)), new Symbol(fact)); //wrap it up\n\n              finalize();\n            } else if (den.group === CP && den_p.equals(1)) {\n              // a/(b*s-c) -> ae^(-bt)\n              if (f.x.isLinear() && !num.contains(s)) {\n                t = _.divide(t, f.a.clone());\n                retval = _.pow(new Symbol('e'), _.multiply(t, f.b.negate())); //wrap it up\n\n                finalize();\n              } else {\n                if (f.x.group === S && f.x.power.equals(2)) {\n                  if (!num.contains(s)) {\n                    retval = _.parse(format('(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/sqrt(({2})*({3}))', t, num, f.a, f.b));\n                  } // a*s/(b*s^2+c^2)\n                  else {\n                      var a = new Symbol(1);\n\n                      if (num.group === CB) {\n                        var new_num = new Symbol(1);\n                        num.each(function (x) {\n                          if (x.contains(s)) new_num = _.multiply(new_num, x);else a = _.multiply(a, x);\n                        });\n                        num = new_num;\n                      } //we need more information about the denominator to decide\n\n\n                      var f2 = core.Utils.decompose_fn(num, s, true);\n                      var fn1, fn2, a_has_sin, b_has_cos, a_has_cos, b_has_sin;\n                      fn1 = f2.a;\n                      fn2 = f2.b;\n                      a_has_sin = fn1.containsFunction('sin');\n                      a_has_cos = fn1.containsFunction('cos');\n                      b_has_cos = fn2.containsFunction('cos');\n                      b_has_sin = fn2.containsFunction('sin');\n\n                      if (f2.x.value === s && f2.x.isLinear() && !(a_has_sin && b_has_cos || a_has_cos || b_has_sin)) {\n                        retval = _.parse(format('(({1})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})', t, f2.a, f.a, f.b));\n                      } else {\n                        if (a_has_sin && b_has_cos) {\n                          var sin, cos;\n                          sin = fn1.findFunction('sin');\n                          cos = fn2.findFunction('cos'); //who has the s?\n\n                          if (sin.args[0].equals(cos.args[0]) && !sin.args[0].contains(s)) {\n                            var b, c, d, e;\n                            b = _.divide(fn2, cos.toUnitMultiplier()).toString();\n                            c = sin.args[0].toString();\n                            d = f.b;\n                            e = _.divide(fn1, sin.toUnitMultiplier());\n                            exp = '(({1})*({2})*cos({3})*sin(sqrt({4})*({0})))/sqrt({4})+({1})*sin({3})*({5})*cos(sqrt({4})*({0}))';\n                            retval = _.parse(format(exp, t, a, b, c, d, e));\n                          }\n                        }\n                      }\n                    }\n                }\n              }\n            } else if (f.x.power.num && f.x.power.num.equals(3) && f.x.power.den.equals(2) && num.contains('sqrt(pi)') && !num.contains(s) && num.isLinear()) {\n              var b = _.divide(num.clone(), _.parse('sqrt(pi)'));\n\n              retval = _.parse(format('(2*({2})*sqrt({0}))/({1})', t, f.a, b, num));\n            } else if (den_p.equals(2) && f.x.power.equals(2)) {\n              var a, d, exp;\n\n              if (!num.contains(s)) {\n                a = _.divide(num, new Symbol(2));\n                exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({3})*sqrt(({2})*({3})))-(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*({3}))';\n                retval = _.parse(format(exp, t, a, f.a, f.b));\n              } else {\n                //decompose the numerator to check value of s\n                f2 = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\n\n                if (f2.x.isComposite()) {\n                  var s_terms = []; //first collect the factors e.g. (a)(bx)(cx^2+d)\n\n                  var symbols = num.collectSymbols(function (x) {\n                    x = Symbol.unwrapPARENS(x);\n                    var t = core.Utils.decompose_fn(x, s, true);\n                    t.symbol = x;\n                    return t;\n                  }). //then sort them by power hightest to lowest\n                  sort(function (a, b) {\n                    var p1, p2;\n                    p1 = a.x.value !== s ? 0 : a.x.power;\n                    p2 = b.x.value !== s ? 0 : b.x.power;\n                    return p2 - p1;\n                  });\n                  a = new Symbol(-1); //grab only the ones which have s\n\n                  for (var i = 0; i < symbols.length; i++) {\n                    var fc = symbols[i];\n                    if (fc.x.value === s) s_terms.push(fc);else a = _.multiply(a, fc.symbol);\n                  } //the following 2 assumptions are made\n                  //1. since the numerator was factored above then each s_term has a unique power\n                  //2. because the terms are sorted by descending powers then the first item \n                  //   has the highest power\n                  //we can now check for the next type s(s^2-a^2)/(s^2+a^2)^2\n\n\n                  if (s_terms[0].x.power.equals(2) && s_terms[1].x.power.equals(1) && s_terms[1].b.equals(0) && !s_terms[0].b.equals(0)) {\n                    b = s_terms[0].a.negate();\n                    exp = '-(({1})*({2})*({5})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))/' + '(2*({4})^2*sqrt(({4})*({5})))-(({1})*({3})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))' + '/(2*({4})*sqrt(({4})*({5})))+(({1})*({2})*cos((sqrt(({4})*({5}))*({0}))/({4})))/({4})^2';\n                    retval = _.parse(format(exp, t, a, b, s_terms[0].b, f.a, f.b));\n                  }\n                } else {\n                  if (f2.x.isLinear()) {\n                    a = _.divide(f2.a, new Symbol(2));\n                    exp = '(({1})*({0})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))';\n                    retval = _.parse(format(exp, t, a, f.a, f.b));\n                  } else if (f2.x.power.equals(2)) {\n                    if (f2.b.equals(0)) {\n                      a = _.divide(f2.a, new Symbol(2));\n                      exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\n                      retval = _.parse(format(exp, t, a, f.a, f.b));\n                    } else {\n                      a = _.divide(f2.a, new Symbol(2));\n                      d = f2.b.negate();\n                      exp = '-((({2})*({4})-2*({1})*({3}))*sin((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3})*sqrt(({2})*({3})))+' + '(({4})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3}))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\n                      retval = _.parse(format(exp, t, a, f.a, f.b, d));\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (!retval) retval = _.symfunction('ilt', [input_symbol, s_, t]);\n          return retval;\n        }, true);\n      }\n    },\n    Statistics: {\n      frequencyMap: function (arr) {\n        var map = {}; //get the frequency map\n\n        for (var i = 0, l = arr.length; i < l; i++) {\n          var e = arr[i],\n              key = e.toString();\n          if (!map[key]) //default it to zero\n            map[key] = 0;\n          map[key]++; //increment\n        }\n\n        return map;\n      },\n      sort: function (arr) {\n        return arr.sort(function (a, b) {\n          if (!a.isConstant() || !b.isConstant()) _.error('Unable to sort! All values must be numeric');\n          return a.multiplier.subtract(b.multiplier);\n        });\n      },\n      count: function (arr) {\n        return new Symbol(arr.length);\n      },\n      sum: function (arr, x_) {\n        var sum = new Symbol(0);\n\n        for (var i = 0, l = arr.length; i < l; i++) {\n          var xi = arr[i].clone();\n\n          if (x_) {\n            sum = _.add(_.pow(_.subtract(xi, x_.clone()), new Symbol(2)), sum);\n          } else sum = _.add(xi, sum);\n        }\n\n        return sum;\n      },\n      mean: function () {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.mean.apply(this, args[0].elements);\n        return _.divide(__.Statistics.sum(args), __.Statistics.count(args));\n      },\n      median: function () {\n        var args = [].slice.call(arguments),\n            retval; //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.median.apply(this, args[0].elements);\n\n        try {\n          var sorted = __.Statistics.sort(args);\n\n          var l = args.length;\n\n          if (core.Utils.even(l)) {\n            var mid = l / 2;\n            retval = __.Statistics.mean(sorted[mid - 1], sorted[mid]);\n          } else retval = sorted[Math.floor(l / 2)];\n        } catch (e) {\n          retval = _.symfunction('median', args);\n        }\n\n        return retval;\n      },\n      mode: function () {\n        var args = [].slice.call(arguments),\n            retval; //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.mode.apply(this, args[0].elements);\n\n        var map = __.Statistics.frequencyMap(args); //the mode of 1 item is that item as per issue #310 (verified by Happypig375). \n\n\n        if (core.Utils.keys(map).length === 1) retval = args[0];else {\n          //invert by arraning them according to their frequency\n          var inverse = {};\n\n          for (var x in map) {\n            var freq = map[x]; //check if it's in the inverse already\n\n            if (!(freq in inverse)) inverse[freq] = x;else {\n              var e = inverse[freq]; //if it's already an array then just add it\n\n              if (isArray(e)) e.push(x); //convert it to and array\n              else inverse[freq] = [x, inverse[freq]];\n            }\n          } //the keys now represent the maxes. We want the max of those keys\n\n\n          var max = inverse[Math.max.apply(null, core.Utils.keys(inverse))]; //check it's an array. If it is then map over the results and convert \n          //them to Symbol\n\n          if (isArray(max)) {\n            retval = _.symfunction('mode', max.sort());\n          } else retval = _.parse(max);\n        }\n        return retval;\n      },\n      gVariance: function (k, args) {\n        var x_ = __.Statistics.mean.apply(__.Statistics, args),\n            sum = __.Statistics.sum(args, x_);\n\n        return _.multiply(k, sum);\n      },\n      variance: function () {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.variance.apply(this, args[0].elements);\n\n        var k = _.divide(new Symbol(1), __.Statistics.count(args));\n\n        return __.Statistics.gVariance(k, args);\n      },\n      sampleVariance: function () {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.sampleVariance.apply(this, args[0].elements);\n\n        var k = _.divide(new Symbol(1), _.subtract(__.Statistics.count(args), new Symbol(1)));\n\n        return __.Statistics.gVariance(k, args);\n      },\n      standardDeviation: function () {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.standardDeviation.apply(this, args[0].elements);\n        return _.pow(__.Statistics.variance.apply(__.Statistics, args), new Symbol(1 / 2));\n      },\n      sampleStandardDeviation: function () {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.sampleStandardDeviation.apply(this, args[0].elements);\n        return _.pow(__.Statistics.sampleVariance.apply(__.Statistics, args), new Symbol(1 / 2));\n      },\n      zScore: function (x, mean, stdev) {\n        return _.divide(_.subtract(x, mean), stdev);\n      }\n    },\n    Units: {\n      table: {\n        foot: '12 inch',\n        meter: '100 cm',\n        decimeter: '10 cm'\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'laplace',\n    visible: true,\n    numargs: 3,\n    build: function () {\n      return __.LaPlace.transform;\n    }\n  }, {\n    name: 'ilt',\n    visible: true,\n    numargs: 3,\n    build: function () {\n      return __.LaPlace.inverse;\n    }\n  }, //statistical\n  {\n    name: 'mean',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.mean;\n    }\n  }, {\n    name: 'median',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.median;\n    }\n  }, {\n    name: 'mode',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.mode;\n    }\n  }, {\n    name: 'smpvar',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.sampleVariance;\n    }\n  }, {\n    name: 'variance',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.variance;\n    }\n  }, {\n    name: 'smpstdev',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.sampleStandardDeviation;\n    }\n  }, {\n    name: 'stdev',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.Statistics.standardDeviation;\n    }\n  }, {\n    name: 'zscore',\n    visible: true,\n    numargs: 3,\n    build: function () {\n      return __.Statistics.zScore;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.api();\n})();","map":null,"metadata":{},"sourceType":"script"}