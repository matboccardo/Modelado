{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  //handle imports\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      _A = core.Algebra,\n      _C = core.Calculus,\n      explode = _C.integration.decompose_arg,\n      evaluate = core.Utils.evaluate,\n      remove = core.Utils.remove,\n      format = core.Utils.format,\n      build = core.Utils.build,\n      Symbol = core.Symbol,\n      isSymbol = core.Utils.isSymbol,\n      variables = core.Utils.variables,\n      S = core.groups.S,\n      PL = core.groups.PL,\n      CB = core.groups.CB,\n      CP = core.groups.CP,\n      FN = core.groups.FN,\n      isArray = core.Utils.isArray; // The search radius for the roots\n\n  core.Settings.SOLVE_RADIUS = 1000; // The maximum number to fish for on each side of the zero\n\n  core.Settings.ROOTS_PER_SIDE = 10; // Covert the number to multiples of pi if possible\n\n  core.Settings.make_pi_conversions = true; // The step size\n\n  core.Settings.STEP_SIZE = 0.1; //the maximum iterations for Newton's method\n\n  core.Settings.MAX_NEWTON_ITERATIONS = 200; //the maximum number of time non-linear solve tries another jump point\n\n  core.Settings.MAX_NON_LINEAR_TRIES = 12; //the amount of iterations the function will start to jump at\n\n  core.Settings.NON_LINEAR_JUMP_AT = 50; //the size of the jump\n\n  core.Settings.NON_LINEAR_JUMP_SIZE = 100; //the original starting point for nonlinear solving\n\n  core.Settings.NON_LINEAR_START = 0.01;\n\n  core.Symbol.prototype.hasTrig = function () {\n    return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\n  };\n\n  core.Symbol.prototype.hasNegativeTerms = function () {\n    if (this.isComposite()) {\n      for (var x in this.symbols) {\n        var sym = this.symbols[x];\n        if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0)) return true;\n      }\n    }\n\n    return false;\n  };\n  /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n   * As such we can have this data type be supported completely outside of the core.\r\n   * This is an equation that has a left hand side and a right hand side\r\n   */\n\n\n  function Equation(lhs, rhs) {\n    if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY)) throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\n    this.LHS = lhs; //left hand side\n\n    this.RHS = rhs; //right and side\n  }\n\n  ; //UTILS ##!!\n\n  Equation.prototype = {\n    toString: function () {\n      return this.LHS.toString() + '=' + this.RHS.toString();\n    },\n    text: function (option) {\n      return this.LHS.text(option) + '=' + this.RHS.text(option);\n    },\n    toLHS: function () {\n      var eqn = this.removeDenom();\n      return _.expand(_.subtract(eqn.LHS, eqn.RHS));\n      ;\n    },\n    removeDenom: function () {\n      var a = this.LHS.clone();\n      var b = this.RHS.clone(); //remove the denominator on both sides\n\n      var den = _.multiply(a.getDenom(), b.getDenom());\n\n      a = _.expand(_.multiply(a, den.clone()));\n      b = _.expand(_.multiply(b, den)); //swap the groups\n\n      if (b.group === CP && b.group !== CP) {\n        var t = a;\n        a = b;\n        b = t; //swap\n      } //scan to eliminate denominators\n\n\n      if (a.group === CB) {\n        var t = new Symbol(a.multiplier),\n            newRHS = b.clone();\n        a.each(function (y) {\n          if (y.power.lessThan(0)) newRHS = _.divide(newRHS, y);else t = _.multiply(t, y);\n        });\n        a = t;\n        b = newRHS;\n      } else if (a.group === CP) {\n        //the logic: loop through each and if it has a denominator then multiply it out on both ends\n        //and then start over\n        for (var x in a.symbols) {\n          var sym = a.symbols[x];\n\n          if (sym.group === CB) {\n            for (var y in sym.symbols) {\n              var sym2 = sym.symbols[y];\n\n              if (sym2.power.lessThan(0)) {\n                return new Equation(_.expand(_.multiply(sym2.clone().toLinear(), a)), _.expand(_.multiply(sym2.clone().toLinear(), b)));\n              }\n            }\n          }\n        }\n      }\n\n      return new Equation(a, b);\n    },\n    clone: function () {\n      return new Equation(this.LHS.clone(), this.RHS.clone());\n    },\n    sub: function (x, y) {\n      var clone = this.clone();\n      clone.LHS = clone.LHS.sub(x.clone(), y.clone());\n      clone.RHS = clone.RHS.sub(x.clone(), y.clone());\n      return clone;\n    },\n    isZero: function () {\n      return core.Utils.evaluate(this.toLHS()).equals(0);\n    },\n    latex: function (option) {\n      return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\n    }\n  }; //overwrite the equals function\n\n  _.equals = function (a, b) {\n    return new Equation(a, b);\n  };\n\n  core.Expression.prototype.solveFor = function (x) {\n    return solve(core.Utils.isSymbol(this.symbol) ? this.symbol : this.symbol.toLHS(), x).map(function (x) {\n      return new core.Expression(x);\n    });\n  };\n\n  core.Expression.prototype.expand = function () {\n    if (this.symbol instanceof Equation) {\n      var clone = this.symbol.clone();\n      clone.RHS = _.expand(clone.RHS);\n      clone.LHS = _.expand(clone.LHS);\n      return new core.Expression(clone);\n    }\n\n    return new core.Expression(_.expand(this.symbol));\n  };\n\n  core.Expression.prototype.variables = function () {\n    if (this.symbol instanceof Equation) return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\n    return variables(this.symbol);\n  };\n\n  core.Matrix.jacobian = function (eqns, vars) {\n    var jacobian = new core.Matrix(); //get the variables if not supplied\n\n    if (!vars) {\n      vars = __.getSystemVariables(eqns);\n    }\n\n    vars.forEach(function (v, i) {\n      eqns.forEach(function (eq, j) {\n        var e = core.Calculus.diff(eq.clone(), v);\n        jacobian.set(j, i, e);\n      });\n    });\n    return jacobian;\n  };\n\n  core.Matrix.prototype.max = function () {\n    var max = new Symbol(0);\n    this.each(function (x) {\n      var e = x.abs();\n      if (e.gt(max)) max = e;\n    });\n    return max;\n  };\n\n  core.Matrix.cMatrix = function (value, vars) {\n    var m = new core.Matrix(); //make an initial guess\n\n    vars.forEach(function (v, i) {\n      m.set(i, 0, _.parse(value));\n    });\n    return m;\n  };\n\n  var setEq = function (a, b) {\n    return _.equals(a, b);\n  }; //link the Equation class back to the core\n\n\n  core.Equation = Equation; //Loops through an array and attempts to fails a test. Stops if manages to fail.\n\n  var checkAll = core.Utils.checkAll = function (args, test) {\n    for (var i = 0; i < args.length; i++) if (test(args[i])) return false;\n\n    return true;\n  }; //version solve\n\n\n  var __ = core.Solve = {\n    version: '2.0.2',\n    solutions: [],\n    solve: function (eq, variable) {\n      var solution = solve(eq, String(variable));\n      return new core.Vector(solution); //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\n    },\n\n    /**\r\n     * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n     * @param {Equation|String} eqn\r\n     * @returns {Symbol}\r\n     */\n    toLHS: function (eqn) {\n      if (isSymbol(eqn)) return eqn; //If it's an equation then call its toLHS function instead\n\n      if (!(eqn instanceof Equation)) {\n        var es = eqn.split('='); //convert falsey values to zero\n\n        es[1] = es[1] || '0';\n        eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\n      }\n\n      return eqn.toLHS();\n    },\n    getSystemVariables: function (eqns) {\n      vars = variables(eqns[0], null, null, true); //get all variables\n\n      for (var i = 1, l = eqns.length; i < l; i++) vars = vars.concat(variables(eqns[i])); //remove duplicates\n\n\n      vars = core.Utils.arrayUnique(vars).sort(); //done\n\n      return vars;\n    },\n    solveNonLinearSystem: function (eqns, tries, start) {\n      if (tries < 0) return []; //can't find a solution\n\n      start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start; //the maximum number of times to jump\n\n      var max_tries = core.Settings.MAX_NON_LINEAR_TRIES; //halfway through the tries\n\n      var halfway = Math.floor(max_tries / 2); //initialize the number of tries to 10 if not specified\n\n      tries = typeof tries === 'undefined' ? max_tries : tries; //a point at which we check to see if we're converging. By inspection it seems that we can\n      //use around 20 iterations to see if we're converging. If not then we retry a jump of x\n\n      var jump_at = core.Settings.NON_LINEAR_JUMP_AT; //we jump by this many points at each pivot point\n\n      var jump = core.Settings.NON_LINEAR_JUMP_SIZE; //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\n\n      var found = true;\n\n      var create_subs = function (vars, matrix) {\n        return vars.map(function (x, i) {\n          return Number(matrix.get(i, 0));\n        });\n      };\n\n      var vars = __.getSystemVariables(eqns);\n\n      var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\n        return build(x, vars);\n      }, true);\n      var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\n      var o, y, iters, xn1, norm, lnorm, xn, d;\n      var f_eqns = eqns.map(function (eq) {\n        return build(eq, vars);\n      });\n      var J = jacobian.map(function (e) {\n        return build(e, vars);\n      }, true); //initial values\n\n      xn1 = core.Matrix.cMatrix(0, vars);\n      ; //initialize the c matrix with something close to 0. \n\n      var c = core.Matrix.cMatrix(start, vars);\n      iters = 0; //start of algorithm\n\n      do {\n        //if we've reached the max iterations then exit\n        if (iters > max_iter) {\n          break;\n          found = false;\n        } //set the substitution object\n\n\n        o = create_subs(vars, c); //set xn\n\n        xn = c.clone(); //make all the substitutions for each of the equations\n\n        f_eqns.forEach(function (f, i) {\n          c.set(i, 0, f.apply(null, o));\n        });\n        var m = new core.Matrix();\n        J.each(function (fn, i, j) {\n          var ans = fn.apply(null, o);\n          m.set(i, j, ans);\n        });\n        m = m.invert(); //preform the elimination\n\n        y = _.multiply(m, c).negate(); //the callback is to avoid overflow in the coeffient denonimator\n        //it converts it to a decimal and then back to a fraction. Some precision\n        //is lost be it's better than overflow. \n\n        d = y.subtract(xn1, function (x) {\n          return _.parse(Number(x));\n        });\n        xn1 = xn.add(y, function (x) {\n          return _.parse(Number(x));\n        }); //move c is now xn1\n\n        c = xn1; //get the norm\n        //the expectation is that we're converging to some answer as this point regardless of where we start\n        //this may have to be adjusted at some point because of erroneous assumptions\n\n        if (iters >= jump_at) {\n          //check the norm. If the norm is greater than one then it's time to try another point\n          if (norm > 1) {\n            //reset the start point at halway\n            if (tries === halfway) start = 0;\n            var sign = tries > halfway ? 1 : -1; //which side are we incrementing\n            //we increment +n at one side and -n at the other. \n\n            n = tries % Math.floor(halfway) + 1; //adjust the start point\n\n            start += sign * n * jump; //call restart\n\n            return __.solveNonLinearSystem(eqns, --tries, start);\n          }\n        }\n\n        lnorm = norm;\n        iters++;\n        norm = d.max(); //exit early. Revisit if we get bugs\n\n        if (Number(norm) === Number(lnorm)) break;\n      } while (Number(norm) >= Number.EPSILON); //return a blank set if nothing was found;\n\n\n      if (!found) return []; //return c since that's the answer\n\n      return __.systemSolutions(c, vars, true, function (x) {\n        return core.Utils.round(Number(x), 14);\n      });\n    },\n    systemSolutions: function (result, vars, expand_result, callback) {\n      var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\n      result.each(function (e, idx) {\n        var solution = (expand_result ? _.expand(e) : e).valueOf();\n        if (callback) solution = callback.call(e, solution);\n        var variable = vars[idx];\n\n        if (core.Settings.SOLUTIONS_AS_OBJECT) {\n          solutions[variable] = solution;\n        } else solutions.push([variable, solution]);\n        /*NO*/\n\n      }); //done\n\n      return solutions;\n    },\n    //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\n    solveSystem: function (eqns, var_array) {\n      //check if a var_array was specified\n      //nerdamer.clearVars();// this deleted ALL variables: not what we want\n      //parse all the equations to LHS. Remember that they come in as strings\n      for (var i = 0; i < eqns.length; i++) eqns[i] = __.toLHS(eqns[i]);\n\n      var l = eqns.length,\n          m = new core.Matrix(),\n          c = new core.Matrix(),\n          expand_result = false,\n          vars;\n\n      if (typeof var_array === 'undefined') {\n        //check to make sure that all the equations are linear\n        if (!_A.allLinear(eqns)) return __.solveNonLinearSystem(eqns); //core.err('System must contain all linear equations!');\n\n        vars = __.getSystemVariables(eqns); // deletes only the variables of the linear equations in the nerdamer namespace\n\n        for (var i = 0; i < vars.length; i++) {\n          nerdamer.setVar(vars[i], \"delete\");\n        } // populate the matrix\n\n\n        for (var i = 0; i < l; i++) {\n          var e = eqns[i]; //store the expression\n\n          for (var j = 0; j < l; j++) {\n            var v = vars[j];\n            var coeffs = [];\n            e.each(function (x) {\n              if (x.contains(v)) {\n                coeffs = coeffs.concat(x.coeffs());\n              }\n            });\n            var cf = core.Utils.arraySum(coeffs);\n            m.set(i, j, cf);\n          } //strip the variables from the symbol so we're left with only the zeroth coefficient\n          //start with the symbol and remove each variable and its coefficient\n\n\n          var num = e.clone();\n          vars.map(function (e) {\n            num = num.stripVar(e);\n          });\n          c.set(i, 0, num.negate());\n        }\n      } else {\n        /**\r\n         * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n         * through each term and see if and check to see if it matches one of the variables.\r\n         * When a match is found we mark it. No other match should be found for that term. If it\r\n         * is we stop since it's not linear.\r\n         */\n        vars = var_array;\n        expand_result = true;\n\n        for (i = 0; i < l; i++) {\n          //prefill\n          c.set(i, 0, new Symbol(0));\n\n          var e = _.expand(eqns[i]).collectSymbols(); //expand and store\n          //go trough each of the variables\n\n\n          for (var j = 0; j < var_array.length; j++) {\n            m.set(i, j, new Symbol(0));\n            var v = var_array[j]; //go through the terms and sort the variables\n\n            for (var k = 0; k < e.length; k++) {\n              var term = e[k],\n                  check = false;\n\n              for (var z = 0; z < var_array.length; z++) {\n                //check to see if terms contain multiple variables\n                if (term.contains(var_array[z])) {\n                  if (check) core.err('Multiple variables found for term ' + term);\n                  check = true;\n                }\n              } //we made sure that every term contains one variable so it's safe to assume that if the\n              //variable is found then the remainder is the coefficient.\n\n\n              if (term.contains(v)) {\n                var tparts = explode(remove(e, k), v);\n                m.set(i, j, _.add(m.get(i, j), tparts[0]));\n              }\n            }\n          } //all the remaining terms go to the c matrix\n\n\n          for (k = 0; k < e.length; k++) {\n            c.set(i, 0, _.add(c.get(i, 0), e[k]));\n          }\n        } //consider case (a+b)*I+u\n\n      } //check if the system has a distinct solution\n\n\n      if (m.determinant().equals(0)) throw new core.exceptions.SolveError('System does not have a distinct solution'); // Use M^-1*c to solve system\n\n      m = m.invert();\n      var result = m.multiply(c); //correct the sign as per issue #410\n\n      if (core.Utils.isArray(var_array)) result.each(function (x) {\n        return x.negate();\n      });\n      return __.systemSolutions(result, vars, expand_result);\n    },\n\n    /**\r\n     * The quadratic function but only one side.\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Symbol}\r\n     */\n    quad: function (c, b, a) {\n      var bsqmin4ac = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))\n      /*b^2 - 4ac*/\n      ;\n\n      var det = _.pow(bsqmin4ac, Symbol(0.5));\n\n      var retval = [_.parse(_.divide(_.add(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone()))), _.parse(_.divide(_.subtract(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone())))];\n      return retval;\n    },\n\n    /**\r\n     * The cubic equation\r\n     * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n     * @param {Symbol} d_o\r\n     * @param {Symbol} c_o\r\n     * @param {Symbol} b_o\r\n     * @param {Symbol} a_o\r\n     * @returns {Array}\r\n     */\n    cubic: function (d_o, c_o, b_o, a_o) {\n      //convert everything to text\n      var a = a_o.text(),\n          b = b_o.text(),\n          c = c_o.text(),\n          d = d_o.text();\n\n      var d0s = '({1})^2-3*({0})*({2})',\n          d0 = _.parse(format(d0s, a, b, c)),\n          Q = _.parse(format('((2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3}))^2-4*(({1})^2-3*({0})*({2}))^3)^(1/2)', a, b, c, d)),\n          C = _.parse(format('((1/2)*(({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q)); //check if C equals 0\n\n\n      var scope = {}; //populate the scope object\n\n      variables(C).map(function (x) {\n        scope[x] = 1;\n      });\n      var Ct = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(C, scope);\n      });\n      if (Number(d0) === 0 && Number(Ct) === 0) //negate Q such that C != 0\n        C = _.parse(format('((1/2)*(-({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q));\n      var xs = ['-(b/(3*a))-C/(3*a)-(((b^2-3*a*c))/(3*a*C))', '-(b/(3*a))+(C*(1+i*sqrt(3)))/(6*a)+((1-i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY), '-(b/(3*a))+(C*(1-i*sqrt(3)))/(6*a)+((1+i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY)];\n      return xs.map(function (e, i) {\n        var o = {\n          a: a_o.clone(),\n          b: b_o.clone(),\n          c: c_o.clone(),\n          d: d_o.clone(),\n          C: C.clone()\n        };\n        return _.parse(e, o);\n      });\n    },\n\n    /**\r\n     * The quartic equation\r\n     * @param {Symbol} e\r\n     * @param {Symbol} d\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Array}\r\n     */\n    quartic: function (e, d, c, b, a) {\n      var scope = {};\n      core.Utils.arrayUnique(variables(a).concat(variables(b)).concat(variables(c)).concat(variables(d)).concat(variables(e))).map(function (x) {\n        scope[x] = 1;\n      });\n      a = a.toString();\n      b = b.toString();\n      c = c.toString();\n      d = d.toString();\n      e = e.toString();\n      var p, q, D, D0, D1, Q, x1, x2, x3, x4;\n      /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n       return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n       \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n       \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n       a, b, c, d, e), scope);\r\n       });*/\n\n      p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\n\n      q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString(); //a, b, c, d, e\n\n      D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\n\n      S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\n\n      x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      return [x1, x2, x3, x4];\n    },\n\n    /**\r\n     * Breaks the equation up in its factors and tries to solve the smaller parts\r\n     * @param {Symbol} symbol\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    divideAndConquer: function (symbol, solve_for) {\n      var sols = []; //see if we can solve the factors\n\n      var factors = core.Algebra.Factor.factor(symbol);\n\n      if (factors.group === CB) {\n        factors.each(function (x) {\n          x = Symbol.unwrapPARENS(x);\n          sols = sols.concat(solve(x, solve_for));\n        });\n      }\n\n      return sols;\n    },\n\n    /**\r\n     * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n     * @param {Symbol} eq\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    csolve: function (eq, solve_for) {\n      return core.Utils.block('IGNORE_E', function () {\n        var f, p, pn, n, pf, r, theta, sr, sp, roots;\n        roots = [];\n        f = core.Utils.decompose_fn(eq, solve_for, true);\n\n        if (f.x.group === S) {\n          p = _.parse(f.x.power);\n          pn = Number(p);\n          n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\n          pf = Symbol.toPolarFormArray(n);\n          r = pf[0];\n          theta = pf[1];\n          sr = r.toString();\n          sp = p.toString();\n          var k, root, str;\n\n          for (var i = 0; i < pn; i++) {\n            k = i;\n            str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\n            root = _.parse(str);\n            roots.push(root);\n          }\n        }\n\n        return roots;\n      }, true);\n    },\n\n    /**\r\n     * Generates starting points for the Newton solver given an expression at zero.\r\n     * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n     * Builds on the fact that if the sign changes over an interval then a zero\r\n     * must exist on that interval\r\n     * @param {Symbol} symbol\r\n     * @param {Number} step\r\n     * @returns {Array}\r\n     */\n    getPoints: function (symbol, step) {\n      step = step || 0.01;\n      var f = build(symbol);\n      var start = Math.round(f(0)),\n          last = f(start),\n          last_sign = last / Math.abs(last),\n          points = [],\n          rside = core.Settings.ROOTS_PER_SIDE,\n          // the max number of roots on right side\n      lside = rside * 2 + 1; // the max number of roots on left side\n      // check around the starting point\n\n      points.push(Math.floor(start / 2)); //half way from zero might be a good start\n\n      points.push(Math.abs(start)); //|f(0)| could be a good start\n\n      points.push(start); //|f(0)| could be a good start\n      //adjust for log. A good starting point to include for log is 0.1\n\n      symbol.each(function (x) {\n        if (x.containsFunction('log')) points.push(0.1);\n      }); // Possible issue #1. If the step size exceeds the zeros then they'll be missed. Consider the case\n      // where the function dips to negative and then back the positive with a step size of 0.1. The function\n      // will miss the zeros because it will jump right over it. Think of a case where this can happen.\n\n      for (var i = start; i < core.Settings.SOLVE_RADIUS; i++) {\n        var val = f(i * step),\n            sign = val / Math.abs(val);\n\n        if (isNaN(val) || !isFinite(val) || points.length > rside) {\n          break;\n        } //compare the signs. The have to be different if they cross a zero\n\n\n        if (sign !== last_sign) {\n          points.push((i - 1) / 2); //take note of the possible zero location\n        }\n\n        last_sign = sign;\n      } //check the other side\n\n\n      for (var i = start - 1; i > -core.Settings.SOLVE_RADIUS; i--) {\n        var val = f(i),\n            sign = val / Math.abs(val);\n        if (isNaN(val) || !isFinite(val) || points.length > lside) break; //compare the signs. The have to be different if they cross a zero\n\n        if (sign !== last_sign) points.push((i - 1) / 2); //take note of the possible zero location\n\n        last_sign = sign;\n      }\n\n      return points;\n    },\n    Newton: function (point, f, fp) {\n      var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\n          iter = 0; //first try the point itself. If it's zero viola. We're done\n\n      var x0 = point,\n          x;\n\n      do {\n        var fx0 = f(x0); //store the result of the function\n        //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\n\n        if (x0 === 0 && fx0 === 0) {\n          x = 0;\n          break;\n        }\n\n        iter++;\n        if (iter > maxiter) return; //naximum iterations reached\n\n        x = x0 - fx0 / fp(x0);\n        var e = Math.abs(x - x0);\n        x0 = x;\n      } while (e > Number.EPSILON);\n\n      return x;\n    },\n    rewrite: function (rhs, lhs, for_variable) {\n      lhs = lhs || new Symbol(0);\n\n      if (rhs.isComposite() && rhs.isLinear()) {\n        //try to isolate the square root\n        //container for the square roots\n        var sqrts = []; //all else\n\n        var rem = [];\n        rhs.each(function (x) {\n          x = x.clone();\n\n          if (x.fname === 'sqrt' && x.contains(for_variable)) {\n            sqrts.push(x);\n          } else {\n            rem.push(x);\n          }\n        }, true);\n\n        if (sqrts.length === 1) {\n          //move the remainder to the RHS\n          lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2))); //square both sides\n\n          rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\n        }\n      } else {\n        rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\n      }\n\n      var c = 0,\n          //a counter to see if we have all terms with the variable\n      l = rhs.length; //try to rewrite the whole thing\n\n      if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\n        rhs.distributeMultiplier();\n        var t = new Symbol(0); //first bring all the terms containing the variable to the lhs\n\n        rhs.each(function (x) {\n          if (x.contains(for_variable)) {\n            c++;\n            t = _.add(t, x.clone());\n          } else lhs = _.subtract(lhs, x.clone());\n        });\n        rhs = t; //if not all the terms contain the variable so it's in the form\n        //a*x^2+x\n\n        if (c !== l) {\n          return __.rewrite(rhs, lhs, for_variable);\n        } else {\n          return [rhs, lhs];\n        }\n      } else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\n        if (rhs.multiplier.lessThan(0)) {\n          rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\n          lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\n        }\n\n        if (lhs.equals(0)) return new Symbol(0);else {\n          var t = new Symbol(1);\n          rhs.each(function (x) {\n            if (x.contains(for_variable)) t = _.multiply(t, x.clone());else lhs = _.divide(lhs, x.clone());\n          });\n          rhs = t;\n          return __.rewrite(rhs, lhs, for_variable);\n        }\n      } else if (!rhs.isLinear() && rhs.contains(for_variable)) {\n        var p = _.parse(rhs.power.clone().invert());\n\n        rhs = _.pow(rhs, p.clone());\n        lhs = _.pow(_.expand(lhs), p.clone());\n        return __.rewrite(rhs, lhs, for_variable);\n      } else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {\n        return [rhs, lhs];\n      }\n    },\n    sqrtSolve: function (symbol, v) {\n      var sqrts = new Symbol(0);\n      var rem = new Symbol(0);\n\n      if (symbol.isComposite()) {\n        symbol.each(function (x) {\n          if (x.fname === 'sqrt' && x.contains(v)) {\n            sqrts = _.add(sqrts, x.clone());\n          } else {\n            rem = _.add(rem, x.clone());\n          }\n        }); //quick and dirty ATM\n\n        if (!sqrts.equals(0)) {\n          var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2))))); //square both sides\n\n\n          var solutions = solve(t, v); //test the points. The dumb way of getting the answers\n\n          solutions = solutions.filter(function (e) {\n            if (e.isImaginary()) return e;\n            var subs = {};\n            subs[v] = e;\n            var point = evaluate(symbol, subs);\n            if (point.equals(0)) return e;\n          });\n          return solutions;\n        }\n      }\n    }\n  };\n  /*\r\n   * \r\n   * @param {String[]|String|Equation} eqns\r\n   * @param {type} solve_for\r\n   * @returns {Array}\r\n   */\n\n\n  var solve = function (eqns, solve_for, solutions) {\n    //make preparations if it's an Equation\n    if (eqns instanceof Equation) {\n      //if it's zero then we're done\n      if (eqns.isZero()) return [new Symbol(0)]; //if the lhs = x then we're done\n\n      if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\n        return [eqns.RHS];\n      } //if the rhs = x then we're done\n\n\n      if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\n        return [eqns.LHS];\n      }\n    } //unwrap the vector since what we want are the elements\n\n\n    if (eqns instanceof core.Vector) eqns = eqns.elements;\n    solve_for = solve_for || 'x'; //assumes x by default\n    //If it's an array then solve it as a system of equations\n\n    if (isArray(eqns)) {\n      return __.solveSystem.apply(undefined, arguments);\n    } //parse out functions. Fix for issue #300\n    //eqns = core.Utils.evaluate(eqns);\n\n\n    solutions = solutions || []; //mark existing solutions as not to have duplicates\n\n    var existing = {}; //Is usued to add solutions to set. \n    //TODO: Set is now implemented and should be utilized\n\n    var add_to_result = function (r, has_trig) {\n      var r_is_symbol = isSymbol(r);\n      if (r === undefined || typeof r === 'number' && isNaN(r)) return;\n\n      if (isArray(r)) {\n        r.map(function (sol) {\n          add_to_result(sol);\n        });\n      } else {\n        if (r.valueOf() !== 'null') {\n          if (!r_is_symbol) r = _.parse(r); //try to convert the number to multiples of pi\n\n          if (core.Settings.make_pi_conversions && has_trig) {\n            var temp = _.divide(r.clone(), new Symbol(Math.PI)),\n                m = temp.multiplier,\n                a = Math.abs(m.num),\n                b = Math.abs(m.den);\n\n            if (a < 10 && b < 10) r = _.multiply(temp, new Symbol('pi'));\n          } //convert to a string so we can mark it as a known solution\n\n\n          var r_str = r.toString();\n          if (!existing[r_str]) solutions.push(r);\n          /*NO*/\n          //mark the answer as seen\n\n          existing[r_str] = true;\n        }\n      }\n    }; //maybe we get lucky\n\n\n    if (eqns.group === S && eqns.contains(solve_for)) {\n      add_to_result(new Symbol(0));\n      return solutions;\n    }\n\n    if (eqns.group === CB) {\n      var sf = String(solve_for); //everything else belongs to the coeff\n      //get the denominator and make sure it doesn't have x since we don't know how to solve for those\n\n      eqns.each(function (x) {\n        if (x.contains(sf)) solve(x, solve_for, solutions);\n      });\n      return solutions;\n    }\n\n    if (eqns.group === FN && eqns.fname === 'sqrt') {\n      eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\n    }\n\n    var eq = core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns),\n        vars = core.Utils.variables(eq),\n        //get a list of all the variables\n    numvars = vars.length; //how many variables are we dealing with\n    //if we're dealing with a single variable then we first check if it's a \n    //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \n    //Don't waste time\n\n    if (eq.group === S || eq.group === CB && eq.contains(solve_for)) return [new Symbol(0)]; //force to polynomial. We go through each and then we look at what it would \n    //take for its power to be an integer\n    //if the power is a fractional we divide by the fractional power\n\n    var fractionals = {},\n        cfact;\n\n    var correct_denom = function (symbol) {\n      symbol = _.expand(symbol);\n      var original = symbol.clone(); //preserve the original\n\n      if (symbol.symbols) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x]; //get the denominator of the sub-symbol\n\n          var den = sym.getDenom();\n\n          if (!den.isConstant(true) && symbol.isComposite()) {\n            var t = new Symbol(0);\n            symbol.each(function (e) {\n              t = _.add(t, _.multiply(e, den.clone()));\n            });\n            return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\n          }\n\n          var parts = explode(sym, solve_for);\n          var is_sqrt = parts[1].fname === core.Settings.SQRT;\n          var v = Symbol.unwrapSQRT(parts[1]);\n          var p = v.power.clone(); //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\n          //this needs to be terminated if p = 1/2\n\n          if (!isSymbol(p) && !p.equals(1 / 2)) {\n            if (p.den.gt(1)) {\n              if (is_sqrt) {\n                symbol = _.subtract(symbol, sym.clone());\n                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\n                return correct_denom(symbol);\n              }\n\n              var c = fractionals[p.den];\n              fractionals[p.den] = c ? c++ : 1;\n            } else if (p.sign() === -1) {\n              var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\n              //unwrap the symbol's denoniator\n\n\n              symbol.each(function (y, index) {\n                if (y.contains(solve_for)) {\n                  symbol.symbols[index] = _.multiply(y, factor.clone());\n                }\n              });\n              fractionals = {};\n              return correct_denom(_.parse(symbol));\n            } else if (sym.group === PL) {\n              var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\n\n              if (min_p < 0) {\n                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\n\n                var corrected = new Symbol(0);\n                original.each(function (x) {\n                  corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\n                }, true);\n                return corrected;\n              }\n            }\n          }\n        }\n      }\n\n      return symbol;\n    }; //separate the equation\n\n\n    var separate = function (eq) {\n      var lhs = new Symbol(0),\n          rhs = new Symbol(0);\n      eq.each(function (x) {\n        if (x.contains(solve_for, true)) lhs = _.add(lhs, x.clone());else rhs = _.subtract(rhs, x.clone());\n      });\n      return [lhs, rhs];\n    };\n\n    __.inverseFunctionSolve = function (name, lhs, rhs) {\n      //ax+b comes back as [a, x, ax, b];\n      var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n      var x = parts[1];\n\n      if (x.group === S) {\n        return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\n      }\n    }; //first remove any denominators\n\n\n    eq = correct_denom(eq);\n    if (eq.equals(0)) return [eq]; //correct fractionals. I can only handle one type right now\n\n    var fkeys = core.Utils.keys(fractionals);\n\n    if (fkeys.length === 1) {\n      //make a note of the factor\n      cfact = fkeys[0];\n      eq.each(function (x, index) {\n        if (x.contains(solve_for)) {\n          var parts = explode(x, solve_for);\n          var v = parts[1];\n          var p = v.power;\n\n          if (p.den.gt(1)) {\n            v.power = p.multiply(new core.Frac(cfact));\n            eq.symbols[index] = _.multiply(v, parts[0]);\n          }\n        }\n      });\n      eq = _.parse(eq);\n    } //try for nested sqrts as per issue #486\n\n\n    add_to_result(__.sqrtSolve(eq, solve_for)); //polynomial single variable\n\n    if (numvars === 1) {\n      if (eq.isPoly(true)) {\n        //try to factor and solve\n        var factors = new core.Algebra.Classes.Factors();\n        core.Algebra.Factor.factor(eq, factors); //if the equation has more than one symbolic factor then solve those individually\n\n        if (factors.getNumberSymbolics() > 1) {\n          for (var x in factors.factors) {\n            add_to_result(solve(factors.factors[x]));\n          }\n        } else {\n          var coeffs = core.Utils.getCoeffs(eq, solve_for),\n              deg = coeffs.length - 1,\n              was_calculated = false;\n\n          if (vars[0] === solve_for) {\n            //check to see if all the coefficients are constant\n            if (checkAll(coeffs, function (x) {\n              return x.group !== core.groups.N;\n            })) {\n              var roots = core.Algebra.proots(eq); //if all the roots are integers then return those\n\n              if (checkAll(roots, function (x) {\n                return !core.Utils.isInt(x);\n              })) {\n                //roots have been calculates\n                was_calculated = true;\n                roots.map(function (x) {\n                  add_to_result(new Symbol(x));\n                });\n              }\n            }\n\n            if (!was_calculated) {\n              //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\n              if (deg === 1) add_to_result(_.divide(coeffs[0], coeffs[1].negate()));else if (deg === 2) {\n                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\n              } else if (deg === 3) {\n                var solutions = []; //set to blank\n                //first try to factor and solve\n\n                var factored = core.Algebra.Factor.factor(eqns); //if it was successfully factored\n\n                var solutions = !factored.equals(eqns) ? solve(factored, solve_for) : [];\n                if (solutions.length > 0) add_to_result(solutions);else add_to_result(__.cubic.apply(undefined, coeffs));\n              } else {\n                /*\r\n                 var sym_roots = csolve(eq, solve_for); \r\n                 if(sym_roots.length === 0)\r\n                 sym_roots = divnconsolve(eq, solve_for);\r\n                 if(sym_roots.length > 0) \r\n                 add_to_result(sym_roots);\r\n                 else\r\n                 */\n                _A.proots(eq).map(add_to_result);\n              }\n            }\n          }\n        }\n      } else {\n        try {\n          //Attempt Newton\n          //since it's not a polynomial then we'll try to look for a solution using Newton's method\n          //this is not a very broad search but takes the positions that something is better than nothing\n          var has_trig = eq.hasTrig(); // we get all the points where a possible zero might exist.\n\n          var points1 = __.getPoints(eq, 0.1);\n\n          var points2 = __.getPoints(eq, 0.05);\n\n          var points3 = __.getPoints(eq, 0.01);\n\n          var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)),\n              l = points.length; //compile the function and the derivative of the function\n\n          var f = build(eq.clone());\n\n          var d = _C.diff(eq.clone());\n\n          var fp = build(d);\n\n          for (var i = 0; i < l; i++) {\n            var point = points[i];\n            add_to_result(__.Newton(point, f, fp), has_trig);\n          }\n\n          solutions.sort();\n        } catch (e) {\n          ;\n        }\n      }\n    } else {\n      //The idea here is to go through the equation and collect the coefficients\n      //place them in an array and call the quad or cubic function to get the results\n      if (!eq.hasFunc(solve_for) && eq.isComposite()) {\n        try {\n          var coeffs = core.Utils.getCoeffs(eq, solve_for);\n          var l = coeffs.length,\n              deg = l - 1; //the degree of the polynomial\n          //get the denominator and make sure it doesn't have x\n          //handle the problem based on the degree\n\n          switch (deg) {\n            case 0:\n              var separated = separate(eq);\n              var lhs = separated[0],\n                  rhs = separated[1];\n\n              if (lhs.group === core.groups.EX) {\n                add_to_result(_.parse(core.Utils.format('log(({0})/({2}))/log({1})', rhs, lhs.value, lhs.multiplier)));\n              }\n\n              break;\n\n            case 1:\n              //nothing to do but to return the quotient of the constant and the LT\n              //e.g. 2*x-1\n              add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\n              break;\n\n            case 2:\n              add_to_result(__.quad.apply(undefined, coeffs));\n              break;\n\n            case 3:\n              add_to_result(__.cubic.apply(undefined, coeffs));\n              break;\n\n            case 4:\n              add_to_result(__.quartic.apply(undefined, coeffs));\n              break;\n\n            default:\n              add_to_result(__.csolve(eq, solve_for));\n              if (solutions.length === 0) add_to_result(__.divideAndConquer(eq, solve_for));\n          }\n        } catch (e) {\n          /*something went wrong. EXITING*/\n          ;\n        }\n      } else {\n        try {\n          var rw = __.rewrite(eq, null, solve_for);\n\n          var lhs = rw[0];\n          var rhs = rw[1];\n\n          if (lhs.group === FN) {\n            if (lhs.fname === 'abs') {\n              add_to_result([rhs.clone(), rhs.negate()]);\n            } else if (lhs.fname === 'sin') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\n            } else if (lhs.fname === 'cos') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\n            } else if (lhs.fname === 'tan') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\n            } else if (lhs.fname === 'log') {\n              //ax+b comes back as [a, x, ax, b];\n              var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n              var x = parts[1];\n\n              if (x.group === S) {\n                rhs = _.divide(_.subtract(_.pow(new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\n                var eq = new Equation(x, rhs).toLHS();\n                add_to_result(solve(eq, solve_for));\n              }\n            } else add_to_result(_.subtract(lhs, rhs));\n          } else {\n            var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\n\n            if (neq.equals(eq)) throw new Error('Stopping. No stop condition exists');\n            add_to_result(solve(neq, solve_for));\n          }\n        } catch (error) {\n          //Let's try this another way\n          try {\n            //1. if the symbol is in the form a*b*c*... then the solution is zero if \n            //either a or b or c is zero.\n            if (eq.group === CB) add_to_result(0);else if (eq.group === CP) {\n              var separated = separate(eq);\n              var lhs = separated[0],\n                  rhs = separated[1]; //reduce the equation\n\n              if (lhs.group === core.groups.EX && lhs.value === solve_for) {\n                //change the base of both sides\n                var p = lhs.power.clone().invert();\n                add_to_result(_.pow(rhs, p));\n              }\n            }\n          } catch (error) {\n            ;\n          }\n        }\n      }\n    }\n\n    if (cfact) {\n      solutions = solutions.map(function (x) {\n        return _.pow(x, new Symbol(cfact));\n      });\n    }\n\n    return solutions;\n  }; //Register the functions for external use\n\n\n  nerdamer.register([{\n    name: 'solveEquations',\n    parent: 'nerdamer',\n    numargs: -1,\n    visible: true,\n    build: function () {\n      return solve; //comment out to return a vector\n\n      /*\r\n       return function() {\r\n       return core.Utils.convertToVector(solve.apply(null, arguments));\r\n       };\r\n       */\n    }\n  }, {\n    name: 'solve',\n    parent: 'Solve',\n    numargs: 2,\n    visible: true,\n    build: function () {\n      return core.Solve.solve;\n    }\n  },\n  /*\r\n   {\r\n   name: 'polysolve',\r\n   parent: 'Solve',\r\n   visible: true,\r\n   build: function(){ return polysolve; }\r\n   },\r\n   */\n  {\n    name: 'setEquation',\n    parent: 'Solve',\n    visible: true,\n    build: function () {\n      return setEq;\n    }\n  }]);\n  nerdamer.api();\n})();","map":null,"metadata":{},"sourceType":"script"}