{"ast":null,"code":"/*\n * function-plot\n *\n * Copyright (c) 2015 Mauricio Poppe\n * Licensed under the MIT license.\n */\n'use strict';\n\nrequire('./polyfills');\n\nvar d3 = window.d3;\n\nvar events = require('events');\n\nvar extend = require('extend');\n\nvar mousetip = require('./tip');\n\nvar helpers = require('./helpers/');\n\nvar annotations = require('./helpers/annotations');\n\nvar datumDefaults = require('./datum-defaults');\n\nvar globals;\nvar graphTypes;\nvar cache = [];\n\nmodule.exports = function (options) {\n  options = options || {};\n  options.data = options.data || []; // globals\n\n  var width, height;\n  var margin;\n  var zoomBehavior;\n  var xScale, yScale;\n  var line = d3.svg.line().x(function (d) {\n    return xScale(d[0]);\n  }).y(function (d) {\n    return yScale(d[1]);\n  });\n\n  function Chart() {\n    var n = Math.random();\n    var letter = String.fromCharCode(Math.floor(n * 26) + 97);\n    this.id = options.id = letter + n.toString(16).substr(2);\n    this.linkedGraphs = [this];\n    this.options = options;\n    cache[this.id] = this;\n    this.setUpEventListeners();\n  }\n\n  Chart.prototype = Object.create(events.prototype);\n  /**\n   * Rebuilds the entire graph from scratch recomputing\n   *\n   * - the inner width/height\n   * - scales/axes\n   *\n   * After this is done it does a complete redraw of all the datums,\n   * if only the datums need to be redrawn call `instance.draw()` instead\n   *\n   * @returns {Chart}\n   */\n\n  Chart.prototype.build = function () {\n    this.internalVars();\n    this.drawGraphWrapper();\n    return this;\n  };\n\n  Chart.prototype.initializeAxes = function () {\n    var integerFormat = d3.format('s');\n\n    var format = function (scale) {\n      return function (d) {\n        var decimalFormat = scale.tickFormat(10);\n        var isInteger = d === +d && d === (d | 0); // integers: d3.format('s'), see https://github.com/mbostock/d3/wiki/Formatting\n        // decimals: default d3.scale.linear() formatting see\n        //    https://github.com/mbostock/d3/blob/master/src/svg/axis.js#L29\n\n        return isInteger ? integerFormat(d) : decimalFormat(d);\n      };\n    };\n\n    function computeYScale(xScale) {\n      // assumes that xScale is a linear scale\n      var xDiff = xScale[1] - xScale[0];\n      return height * xDiff / width;\n    }\n\n    options.xAxis = options.xAxis || {};\n    options.xAxis.type = options.xAxis.type || 'linear';\n    options.yAxis = options.yAxis || {};\n    options.yAxis.type = options.yAxis.type || 'linear';\n\n    var xDomain = this.meta.xDomain = function (axis) {\n      if (axis.domain) {\n        return axis.domain;\n      }\n\n      if (axis.type === 'linear') {\n        var xLimit = 12;\n        return [-xLimit / 2, xLimit / 2];\n      } else if (axis.type === 'log') {\n        return [1, 10];\n      }\n\n      throw Error('axis type ' + axis.type + ' unsupported');\n    }(options.xAxis);\n\n    var yDomain = this.meta.yDomain = function (axis) {\n      if (axis.domain) {\n        return axis.domain;\n      }\n\n      var yLimit = computeYScale(xDomain);\n\n      if (axis.type === 'linear') {\n        return [-yLimit / 2, yLimit / 2];\n      } else if (axis.type === 'log') {\n        return [1, 10];\n      }\n\n      throw Error('axis type ' + axis.type + ' unsupported');\n    }(options.yAxis);\n\n    if (xDomain[0] >= xDomain[1]) {\n      throw Error('the pair defining the x-domain is inverted');\n    }\n\n    if (yDomain[0] >= yDomain[1]) {\n      throw Error('the pair defining the y-domain is inverted');\n    }\n\n    xScale = this.meta.xScale = d3.scale[options.xAxis.type]().domain(xDomain).range(options.xAxis.invert ? [width, 0] : [0, width]);\n    yScale = this.meta.yScale = d3.scale[options.yAxis.type]().domain(yDomain).range(options.yAxis.invert ? [0, height] : [height, 0]);\n    this.meta.xAxis = d3.svg.axis().scale(xScale).tickSize(options.grid ? -height : 0).tickFormat(format(xScale)).orient('bottom');\n    this.meta.yAxis = d3.svg.axis().scale(yScale).tickSize(options.grid ? -width : 0).tickFormat(format(yScale)).orient('left');\n  };\n\n  Chart.prototype.internalVars = function () {\n    // measurements and other derived data\n    this.meta = {};\n    margin = this.meta.margin = {\n      left: 30,\n      right: 30,\n      top: 20,\n      bottom: 20 // margin = this.meta.margin = {left: 0, right: 0, top: 20, bottom: 20}\n      // if there's a title make the top margin bigger\n\n    };\n\n    if (options.title) {\n      this.meta.margin.top = 40;\n    }\n\n    zoomBehavior = this.meta.zoomBehavior = d3.behavior.zoom(); // inner width/height\n\n    width = this.meta.width = (options.width || globals.DEFAULT_WIDTH) - margin.left - margin.right;\n    height = this.meta.height = (options.height || globals.DEFAULT_HEIGHT) - margin.top - margin.bottom;\n    this.initializeAxes();\n  };\n\n  Chart.prototype.drawGraphWrapper = function () {\n    var root = this.root = d3.select(options.target).selectAll('svg').data([options]); // enter\n\n    this.root.enter = root.enter().append('svg').attr('class', 'function-plot').attr('font-size', this.getFontSize()); // merge\n\n    root.attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);\n    this.buildTitle();\n    this.buildLegend();\n    this.buildCanvas();\n    this.buildClip();\n    this.buildAxis();\n    this.buildAxisLabel(); // draw each datum after the wrapper was set up\n\n    this.draw(); // helper to detect the closest fn to the cursor's current abscissa\n\n    var tip = this.tip = mousetip(extend(options.tip, {\n      owner: this\n    }));\n    this.canvas.call(tip);\n    this.buildZoomHelper();\n    this.setUpPlugins();\n  };\n\n  Chart.prototype.buildTitle = function () {\n    // join\n    var selection = this.root.selectAll('text.title').data(function (d) {\n      return [d.title].filter(Boolean);\n    }); // enter\n\n    selection.enter().append('text').attr('class', 'title').attr('y', margin.top / 2).attr('x', margin.left + width / 2).attr('font-size', 25).attr('text-anchor', 'middle').attr('alignment-baseline', 'middle').text(options.title); // exit\n\n    selection.exit().remove();\n  };\n\n  Chart.prototype.buildLegend = function () {\n    // enter\n    this.root.enter.append('text').attr('class', 'top-right-legend').attr('text-anchor', 'end'); // update + enter\n\n    this.root.select('.top-right-legend').attr('y', margin.top / 2).attr('x', width + margin.left);\n  };\n\n  Chart.prototype.buildCanvas = function () {\n    var self = this;\n    this.meta.zoomBehavior.x(xScale).y(yScale).on('zoom', function onZoom() {\n      self.emit('all:zoom', d3.event.translate, d3.event.scale);\n    }); // enter\n\n    var canvas = this.canvas = this.root.selectAll('.canvas').data(function (d) {\n      return [d];\n    });\n    this.canvas.enter = canvas.enter().append('g').attr('class', 'canvas'); // enter + update\n  };\n\n  Chart.prototype.buildClip = function () {\n    // (so that the functions don't overflow on zoom or drag)\n    var id = this.id;\n    var defs = this.canvas.enter.append('defs');\n    defs.append('clipPath').attr('id', 'function-plot-clip-' + id).append('rect').attr('class', 'clip static-clip'); // enter + update\n\n    this.canvas.selectAll('.clip').attr('width', width).attr('height', height); // marker clip (for vectors)\n\n    this.markerId = this.id + '-marker';\n    defs.append('clipPath').append('marker').attr('id', this.markerId).attr('viewBox', '0 -5 10 10').attr('refX', 10).attr('markerWidth', 5).attr('markerHeight', 5).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5L0,0').attr('stroke-width', '0px').attr('fill-opacity', 1).attr('fill', '#777');\n  };\n\n  Chart.prototype.buildAxis = function () {\n    // axis creation\n    var canvasEnter = this.canvas.enter;\n    canvasEnter.append('g').attr('class', 'x axis');\n    canvasEnter.append('g').attr('class', 'y axis'); // update\n\n    this.canvas.select('.x.axis').attr('transform', 'translate(0,' + height + ')').call(this.meta.xAxis);\n    this.canvas.select('.y.axis').call(this.meta.yAxis);\n  };\n\n  Chart.prototype.buildAxisLabel = function () {\n    // axis labeling\n    var xLabel, yLabel;\n    var canvas = this.canvas;\n    xLabel = canvas.selectAll('text.x.axis-label').data(function (d) {\n      return [d.xAxis.label].filter(Boolean);\n    });\n    xLabel.enter().append('text').attr('class', 'x axis-label').attr('text-anchor', 'end');\n    xLabel.attr('x', width).attr('y', height - 6).text(function (d) {\n      return d;\n    });\n    xLabel.exit().remove();\n    yLabel = canvas.selectAll('text.y.axis-label').data(function (d) {\n      return [d.yAxis.label].filter(Boolean);\n    });\n    yLabel.enter().append('text').attr('class', 'y axis-label').attr('y', 6).attr('dy', '.75em').attr('text-anchor', 'end').attr('transform', 'rotate(-90)');\n    yLabel.text(function (d) {\n      return d;\n    });\n    yLabel.exit().remove();\n  };\n  /**\n   * @private\n   *\n   * Draws each of the datums stored in data.options, to do a full\n   * redraw call `instance.draw()`\n   */\n\n\n  Chart.prototype.buildContent = function () {\n    var self = this;\n    var canvas = this.canvas;\n    canvas.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').call(zoomBehavior).each(function () {\n      var el = d3.select(this); // make a copy of all the listeners available to be removed/added later\n\n      var listeners = ['mousedown', 'touchstart', 'onwheel' in document ? 'wheel' : 'ononmousewheel' in document ? 'mousewheel' : 'MozMousePixelScroll'].map(function (d) {\n        return d + '.zoom';\n      });\n\n      if (!el._zoomListenersCache) {\n        listeners.forEach(function (l) {\n          el['_' + l] = el.on(l);\n        });\n        el._zoomListenersCache = true;\n      }\n\n      function setState(state) {\n        listeners.forEach(function (l) {\n          state ? el.on(l, el['_' + l]) : el.on(l, null);\n        });\n      }\n\n      setState(!options.disableZoom);\n    });\n    var content = this.content = canvas.selectAll(':scope > g.content').data(function (d) {\n      return [d];\n    }); // g tag clipped to hold the data\n\n    content.enter().append('g').attr('clip-path', 'url(#function-plot-clip-' + this.id + ')').attr('class', 'content'); // helper line, x = 0\n\n    if (options.xAxis.type === 'linear') {\n      var yOrigin = content.selectAll(':scope > path.y.origin').data([[[0, yScale.domain()[0]], [0, yScale.domain()[1]]]]);\n      yOrigin.enter().append('path').attr('class', 'y origin').attr('stroke', 'black').attr('opacity', 0.2);\n      yOrigin.attr('d', line);\n    } // helper line y = 0\n\n\n    if (options.yAxis.type === 'linear') {\n      var xOrigin = content.selectAll(':scope > path.x.origin').data([[[xScale.domain()[0], 0], [xScale.domain()[1], 0]]]);\n      xOrigin.enter().append('path').attr('class', 'x origin').attr('stroke', 'black').attr('opacity', 0.2);\n      xOrigin.attr('d', line);\n    } // annotations\n\n\n    content.call(annotations({\n      owner: self\n    })); // content construction\n    // - join options.data to <g class='graph'> elements\n    // - for each datum determine the sampler to use\n\n    var graphs = content.selectAll(':scope > g.graph').data(function (d) {\n      return d.data.map(datumDefaults);\n    }); // enter\n\n    graphs.enter().append('g').attr('class', 'graph'); // enter + update\n\n    graphs.each(function (d, index) {\n      // additional options needed in the graph-types/helpers\n      d.index = index;\n      d3.select(this).call(graphTypes[d.graphType](self));\n      d3.select(this).call(helpers(self));\n    });\n  };\n\n  Chart.prototype.buildZoomHelper = function () {\n    // dummy rect (detects the zoom + drag)\n    var self = this; // enter\n\n    this.draggable = this.canvas.enter.append('rect').attr('class', 'zoom-and-drag').style('fill', 'none').style('pointer-events', 'all'); // update\n\n    this.canvas.select('.zoom-and-drag').attr('width', width).attr('height', height).on('mouseover', function () {\n      self.emit('all:mouseover');\n    }).on('mouseout', function () {\n      self.emit('all:mouseout');\n    }).on('mousemove', function () {\n      self.emit('all:mousemove');\n    });\n  };\n\n  Chart.prototype.setUpPlugins = function () {\n    var plugins = options.plugins || [];\n    var self = this;\n    plugins.forEach(function (plugin) {\n      plugin(self);\n    });\n  };\n\n  Chart.prototype.addLink = function () {\n    for (var i = 0; i < arguments.length; i += 1) {\n      this.linkedGraphs.push(arguments[i]);\n    }\n  };\n\n  Chart.prototype.updateAxes = function () {\n    var instance = this;\n    var canvas = instance.canvas;\n    canvas.select('.x.axis').call(instance.meta.xAxis);\n    canvas.select('.y.axis').call(instance.meta.yAxis); // updates the style of the axes\n\n    canvas.selectAll('.axis path, .axis line').attr('fill', 'none').attr('stroke', 'black').attr('shape-rendering', 'crispedges').attr('opacity', 0.1);\n  };\n\n  Chart.prototype.syncOptions = function () {\n    // update the original options yDomain and xDomain\n    this.options.xAxis.domain = this.meta.xScale.domain();\n    this.options.yAxis.domain = this.meta.yScale.domain();\n  };\n\n  Chart.prototype.programmaticZoom = function (xDomain, yDomain) {\n    var instance = this;\n    d3.transition().duration(750).tween('zoom', function () {\n      var ix = d3.interpolate(xScale.domain(), xDomain);\n      var iy = d3.interpolate(yScale.domain(), yDomain);\n      return function (t) {\n        zoomBehavior.x(xScale.domain(ix(t))).y(yScale.domain(iy(t)));\n        instance.draw();\n      };\n    }).each('end', function () {\n      instance.emit('programmatic-zoom');\n    });\n  };\n\n  Chart.prototype.getFontSize = function () {\n    return Math.max(Math.max(width, height) / 50, 8);\n  };\n\n  Chart.prototype.draw = function () {\n    var instance = this;\n    instance.emit('before:draw');\n    instance.syncOptions();\n    instance.updateAxes();\n    instance.buildContent();\n    instance.emit('after:draw');\n  };\n\n  Chart.prototype.setUpEventListeners = function () {\n    var instance = this;\n    var events = {\n      mousemove: function (coordinates) {\n        instance.tip.move(coordinates);\n      },\n      mouseover: function () {\n        instance.tip.show();\n      },\n      mouseout: function () {\n        instance.tip.hide();\n      },\n      zoom: function (translate, scale) {\n        zoomBehavior.translate(translate).scale(scale);\n      },\n      'tip:update': function (x, y, index) {\n        var meta = instance.root.datum().data[index];\n        var title = meta.title || '';\n\n        var format = meta.renderer || function (x, y) {\n          return x.toFixed(3) + ', ' + y.toFixed(3);\n        };\n\n        var text = [];\n        title && text.push(title);\n        text.push(format(x, y));\n        instance.root.select('.top-right-legend').attr('fill', globals.COLORS[index]).text(text.join(' '));\n      }\n    };\n    var all = {\n      mousemove: function () {\n        var mouse = d3.mouse(instance.root.select('rect.zoom-and-drag').node());\n        var coordinates = {\n          x: xScale.invert(mouse[0]),\n          y: yScale.invert(mouse[1])\n        };\n        instance.linkedGraphs.forEach(function (graph) {\n          graph.emit('before:mousemove', coordinates);\n          graph.emit('mousemove', coordinates);\n        });\n      },\n      zoom: function (translate, scale) {\n        instance.linkedGraphs.forEach(function (graph, i) {\n          graph.emit('zoom', translate, scale);\n          graph.draw();\n        }); // emit the position of the mouse to all the registered graphs\n\n        instance.emit('all:mousemove');\n      }\n    };\n    Object.keys(events).forEach(function (e) {\n      instance.on(e, events[e]); // create an event for each event existing on `events` in the form 'all:' event\n      // e.g. all:mouseover all:mouseout\n      // the objective is that all the linked graphs receive the same event as the current graph\n\n      !all[e] && instance.on('all:' + e, function () {\n        var args = Array.prototype.slice.call(arguments);\n        instance.linkedGraphs.forEach(function (graph) {\n          var localArgs = args.slice();\n          localArgs.unshift(e);\n          graph.emit.apply(graph, localArgs);\n        });\n      });\n    });\n    Object.keys(all).forEach(function (e) {\n      instance.on('all:' + e, all[e]);\n    });\n  };\n\n  var instance = cache[options.id];\n\n  if (!instance) {\n    instance = new Chart();\n  }\n\n  return instance.build();\n};\n\nglobals = module.exports.globals = require('./globals');\ngraphTypes = module.exports.graphTypes = require('./graph-types/');\nmodule.exports.plugins = require('./plugins/');\nmodule.exports.eval = require('./helpers/eval');","map":null,"metadata":{},"sourceType":"script"}