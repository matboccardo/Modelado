{"ast":null,"code":"/**\n * Created by mauricio on 5/14/15.\n */\n'use strict';\n\nvar intervalArithmeticEval = require('interval-arithmetic-eval');\n\nvar Interval = intervalArithmeticEval.Interval;\n\nvar evaluate = require('../helpers/eval').interval;\n\nvar utils = require('../utils'); // disable the use of typed arrays in interval-arithmetic to improve the performance\n\n\nintervalArithmeticEval.policies.disableRounding();\n\nfunction interval1d(chart, meta, range, nSamples) {\n  var xCoords = utils.space(chart, range, nSamples);\n  var xScale = chart.meta.xScale;\n  var yScale = chart.meta.yScale;\n  var yMin = yScale.domain()[0];\n  var yMax = yScale.domain()[1];\n  var samples = [];\n  var i;\n\n  for (i = 0; i < xCoords.length - 1; i += 1) {\n    var x = {\n      lo: xCoords[i],\n      hi: xCoords[i + 1]\n    };\n    var y = evaluate(meta, 'fn', {\n      x: x\n    });\n\n    if (!Interval.isEmpty(y) && !Interval.isWhole(y)) {\n      samples.push([x, y]);\n    }\n\n    if (Interval.isWhole(y)) {\n      // means that the next and prev intervals need to be fixed\n      samples.push(null);\n    }\n  } // asymptote determination\n\n\n  for (i = 1; i < samples.length - 1; i += 1) {\n    if (!samples[i]) {\n      var prev = samples[i - 1];\n      var next = samples[i + 1];\n\n      if (prev && next && !Interval.intervalsOverlap(prev[1], next[1])) {\n        // case:\n        //\n        //   |\n        //\n        //     |\n        //\n        //   p n\n        if (prev[1].lo > next[1].hi) {\n          prev[1].hi = Math.max(yMax, prev[1].hi);\n          next[1].lo = Math.min(yMin, next[1].lo);\n        } // case:\n        //\n        //     |\n        //\n        //   |\n        //\n        //   p n\n\n\n        if (prev[1].hi < next[1].lo) {\n          prev[1].lo = Math.min(yMin, prev[1].lo);\n          next[1].hi = Math.max(yMax, next[1].hi);\n        }\n      }\n    }\n  }\n\n  samples.scaledDx = xScale(xCoords[1]) - xScale(xCoords[0]);\n  return [samples];\n}\n\nvar rectEps;\n\nfunction smallRect(x, y) {\n  return Interval.width(x) < rectEps;\n}\n\nfunction quadTree(x, y, meta) {\n  var sample = evaluate(meta, 'fn', {\n    x: x,\n    y: y\n  });\n  var fulfills = Interval.zeroIn(sample);\n\n  if (!fulfills) {\n    return this;\n  }\n\n  if (smallRect(x, y)) {\n    this.push([x, y]);\n    return this;\n  }\n\n  var midX = x.lo + (x.hi - x.lo) / 2;\n  var midY = y.lo + (y.hi - y.lo) / 2;\n  var east = {\n    lo: midX,\n    hi: x.hi\n  };\n  var west = {\n    lo: x.lo,\n    hi: midX\n  };\n  var north = {\n    lo: midY,\n    hi: y.hi\n  };\n  var south = {\n    lo: y.lo,\n    hi: midY\n  };\n  quadTree.call(this, east, north, meta);\n  quadTree.call(this, east, south, meta);\n  quadTree.call(this, west, north, meta);\n  quadTree.call(this, west, south, meta);\n}\n\nfunction interval2d(chart, meta) {\n  var xScale = chart.meta.xScale;\n  var xDomain = chart.meta.xScale.domain();\n  var yDomain = chart.meta.yScale.domain();\n  var x = {\n    lo: xDomain[0],\n    hi: xDomain[1]\n  };\n  var y = {\n    lo: yDomain[0],\n    hi: yDomain[1]\n  };\n  var samples = []; // 1 px\n\n  rectEps = xScale.invert(1) - xScale.invert(0);\n  quadTree.call(samples, x, y, meta);\n  samples.scaledDx = 1;\n  return [samples];\n}\n\nvar sampler = function (chart, d, range, nSamples) {\n  var fnTypes = {\n    implicit: interval2d,\n    linear: interval1d\n  };\n\n  if (!fnTypes.hasOwnProperty(d.fnType)) {\n    throw Error(d.fnType + ' is not supported in the `interval` sampler');\n  }\n\n  return fnTypes[d.fnType].apply(null, arguments);\n};\n\nmodule.exports = sampler;","map":null,"metadata":{},"sourceType":"script"}