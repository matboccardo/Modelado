{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\L1000246\\\\Desktop\\\\Modelado2\\\\Modelado\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"C:\\\\Users\\\\L1000246\\\\Desktop\\\\Modelado2\\\\Modelado\\\\src\\\\components\\\\PhaseDiagram.js\";\nimport React, { useMemo, useState } from 'react';\nimport { useTwoPointsPrecision } from '../customHooks';\nimport { getNodeNameByPoint, findPoints, evaluate } from '../helpers/helper';\nimport { uniqBy, round, uniq, orderBy, random } from 'loadsh';\n\nconst functionPlot = require(\"function-plot\");\n\nconst getSamplePointsOnEachRange = (forkPoints, pValue, qValue) => {\n  if (pValue && qValue) {\n    let phaseDiagramPoints = orderBy(uniq(forkPoints));\n    let testPoints = [];\n\n    for (let i = 0; i < phaseDiagramPoints.length; i++) {\n      let numberToTest;\n\n      if (i === 0) {\n        numberToTest = random(phaseDiagramPoints[i] - 1, phaseDiagramPoints[i], true);\n        phaseDiagramPoints[i + 1] ? testPoints.push(random(phaseDiagramPoints[i], phaseDiagramPoints[i + 1], true)) : testPoints.push(phaseDiagramPoints[i] + 1);\n      } else {\n        if (i === phaseDiagramPoints.length - 1) {\n          numberToTest = random(phaseDiagramPoints[i], phaseDiagramPoints[i] + 1, true);\n        } else {\n          numberToTest = (phaseDiagramPoints[i] + phaseDiagramPoints[i + 1]) / 2;\n        }\n      }\n\n      testPoints.push(numberToTest);\n      testPoints.push(phaseDiagramPoints[i]);\n    }\n\n    if (testPoints.length == 0) {\n      testPoints.push(0);\n    }\n\n    testPoints = orderBy(testPoints);\n    return testPoints.map(point => getNodeNameByPoint({\n      p: round(evaluate(pValue, {\n        a: point\n      }), 10),\n      q: round(evaluate(qValue, {\n        a: point\n      }), 10)\n    }));\n  } else {\n    return [];\n  }\n};\n\nconst PhaseDiagram = ({\n  func,\n  pValue,\n  qValue,\n  handleSetPoints\n}) => {\n  const forkPoints = useMemo(() => findPoints(func, pValue, qValue), [func, pValue, qValue]);\n  const trajectoryTypes = useMemo(() => uniqBy(getSamplePointsOnEachRange(forkPoints, pValue, qValue), 'id'), [forkPoints]);\n\n  const _useState = useState(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        activeClassId = _useState2[0],\n        setActiveClassId = _useState2[1];\n\n  const renderUpdate = a => {\n    const p = round(evaluate(pValue, {\n      a: a\n    }), 10);\n    const q = round(evaluate(qValue, {\n      a: a\n    }), 10);\n    handleSetPoints([p, q]);\n    setActiveClassId(getNodeNameByPoint({\n      p,\n      q\n    }).id);\n  };\n\n  const graph = useMemo(() => {\n    if (pValue && qValue && func) {\n      const svg = document.querySelector(\"#phase-diagram>svg\");\n      svg && document.querySelector(\"#phase-diagram\").removeChild(svg);\n      return functionPlot({\n        title: 'Diagrama de fases',\n        target: document.querySelector(\"#phase-diagram\"),\n        width: 800,\n        height: 400,\n        yAxis: {\n          domain: [-4, 4]\n        },\n        tip: {\n          renderer: renderUpdate\n        },\n        grid: true,\n        data: [{\n          fn: '0 * x'\n        }, {\n          points: forkPoints.map(point => [point, 0]),\n          fnType: 'points',\n          graphType: 'scatter',\n          color: 'black',\n          attr: {\n            r: 3\n          }\n        }],\n        annotations: forkPoints.map(p => ({\n          x: p,\n          text: \"a=\".concat(round(p, 3))\n        }))\n      });\n    } else {\n      return null;\n    }\n  }, [pValue, qValue, forkPoints, func]);\n  useTwoPointsPrecision(graph, renderUpdate, forkPoints);\n  return React.createElement(\"div\", {\n    id: \"phase-diagram\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    className: \"guide-container\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107\n    },\n    __self: this\n  }, trajectoryTypes.map(x => React.createElement(\"div\", {\n    id: x.id,\n    key: x.id,\n    className: activeClassId === x.id ? 'active' : undefined,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109\n    },\n    __self: this\n  }, x.text))));\n};\n\nexport default PhaseDiagram;","map":{"version":3,"sources":["C:\\Users\\L1000246\\Desktop\\Modelado2\\Modelado\\src\\components\\PhaseDiagram.js"],"names":["React","useMemo","useState","useTwoPointsPrecision","getNodeNameByPoint","findPoints","evaluate","uniqBy","round","uniq","orderBy","random","functionPlot","require","getSamplePointsOnEachRange","forkPoints","pValue","qValue","phaseDiagramPoints","testPoints","i","length","numberToTest","push","map","point","p","a","q","PhaseDiagram","func","handleSetPoints","trajectoryTypes","activeClassId","setActiveClassId","renderUpdate","id","graph","svg","document","querySelector","removeChild","title","target","width","height","yAxis","domain","tip","renderer","grid","data","fn","points","fnType","graphType","color","attr","r","annotations","x","text","undefined"],"mappings":"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","sourcesContent":["import React, { useMemo, useState } from 'react';\r\nimport { useTwoPointsPrecision } from '../customHooks';\r\nimport { getNodeNameByPoint, findPoints, evaluate } from '../helpers/helper';\r\nimport { uniqBy, round, uniq, orderBy, random } from 'loadsh';\r\nconst functionPlot = require(\"function-plot\");\r\n\r\nconst getSamplePointsOnEachRange = (forkPoints, pValue, qValue) => {\r\n  if (pValue && qValue) {\r\n    let phaseDiagramPoints = orderBy(uniq(forkPoints));\r\n    let testPoints = [];\r\n    for (let i = 0; i < phaseDiagramPoints.length; i++) {\r\n      let numberToTest;\r\n      if (i === 0) {\r\n        numberToTest = random(phaseDiagramPoints[i] - 1, phaseDiagramPoints[i], true);\r\n        phaseDiagramPoints[i + 1] ?\r\n          testPoints.push(random(phaseDiagramPoints[i], phaseDiagramPoints[i + 1], true)) :\r\n          testPoints.push(phaseDiagramPoints[i] + 1);\r\n      }\r\n      else {\r\n        if (i === phaseDiagramPoints.length - 1) {\r\n          numberToTest = random(phaseDiagramPoints[i], phaseDiagramPoints[i] + 1, true);\r\n        }\r\n        else {\r\n          numberToTest = (phaseDiagramPoints[i] + phaseDiagramPoints[i + 1]) / 2;\r\n        }\r\n      }\r\n      testPoints.push(numberToTest);\r\n      testPoints.push(phaseDiagramPoints[i]);\r\n    }\r\n    if (testPoints.length == 0) {\r\n      testPoints.push(0);\r\n    }\r\n    testPoints = orderBy(testPoints);\r\n    return testPoints.map(point =>\r\n      getNodeNameByPoint(\r\n        {\r\n          p: round(evaluate(pValue, { a: point }), 10),\r\n          q: round(evaluate(qValue, { a: point }), 10),\r\n        })\r\n    );\r\n  }\r\n  else {\r\n    return [];\r\n  }\r\n}\r\n\r\nconst PhaseDiagram = ({\r\n  func,\r\n  pValue,\r\n  qValue,\r\n  handleSetPoints,\r\n}) => {\r\n  const forkPoints = useMemo(() => findPoints(func, pValue, qValue), [func, pValue, qValue]);\r\n  const trajectoryTypes = useMemo(() => uniqBy(getSamplePointsOnEachRange(forkPoints, pValue, qValue), 'id'), [forkPoints]);\r\n  const [activeClassId, setActiveClassId] = useState(0);\r\n\r\n  const renderUpdate = (a) => {\r\n    const p = round(evaluate(pValue, { a: a }), 10);\r\n    const q = round(evaluate(qValue, { a: a }), 10);\r\n    handleSetPoints([p, q]);\r\n    setActiveClassId(getNodeNameByPoint({ p, q }).id);\r\n  }\r\n\r\n  const graph = useMemo(() => {\r\n    if (pValue && qValue && func) {\r\n      const svg = document.querySelector(\"#phase-diagram>svg\");\r\n      svg && document.querySelector(\"#phase-diagram\").removeChild(svg);\r\n      return functionPlot({\r\n        title: 'Diagrama de fases',\r\n        target: document.querySelector(\"#phase-diagram\"),\r\n        width: 800,\r\n        height: 400,\r\n        yAxis: { domain: [-4, 4] },\r\n        tip: {\r\n          renderer: renderUpdate,\r\n        },\r\n        grid: true,\r\n        data: [\r\n          {\r\n            fn: '0 * x',\r\n          },\r\n          {\r\n            points: forkPoints.map(point => [point, 0]),\r\n            fnType: 'points',\r\n            graphType: 'scatter',\r\n            color: 'black',\r\n            attr: {\r\n              r: 3,\r\n            },\r\n          },\r\n        ],\r\n        annotations: forkPoints.map(p => (\r\n          {\r\n            x: p,\r\n            text: `a=${round(p, 3)}`\r\n          })),\r\n      });\r\n    }\r\n    else {\r\n      return null;\r\n    }\r\n  }, [pValue, qValue, forkPoints, func]);\r\n\r\n  useTwoPointsPrecision(graph, renderUpdate, forkPoints);\r\n  return (\r\n    <div id='phase-diagram'>\r\n      <div className='guide-container'>\r\n        {trajectoryTypes.map(x =>\r\n          <div id={x.id} key={x.id} className={activeClassId === x.id ? 'active' : undefined}>{x.text}</div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PhaseDiagram;"]},"metadata":{},"sourceType":"module"}