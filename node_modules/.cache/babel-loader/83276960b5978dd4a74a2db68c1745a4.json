{"ast":null,"code":"'use strict';\n\nvar clamp = require('clamp');\n\nvar linspace = require('linspace');\n\nvar utils = require('../utils');\n\nvar evaluate = require('../helpers/eval').builtIn;\n\nfunction checkAsymptote(d0, d1, meta, sign, level) {\n  if (!level) {\n    return {\n      asymptote: true,\n      d0: d0,\n      d1: d1\n    };\n  }\n\n  var i;\n  var n = 10;\n  var x0 = d0[0];\n  var x1 = d1[0];\n  var samples = linspace(x0, x1, n);\n  var oldY, oldX;\n\n  for (i = 0; i < n; i += 1) {\n    var x = samples[i];\n    var y = evaluate(meta, 'fn', {\n      x: x\n    });\n\n    if (i) {\n      var deltaY = y - oldY;\n      var newSign = utils.sgn(deltaY);\n\n      if (newSign === sign) {\n        return checkAsymptote([oldX, oldY], [x, y], meta, sign, level - 1);\n      }\n    }\n\n    oldY = y;\n    oldX = x;\n  }\n\n  return {\n    asymptote: false,\n    d0: d0,\n    d1: d1\n  };\n}\n/**\n * Splits the evaluated data into arrays, each array is separated by any asymptote found\n * through the process of detecting slope/sign brusque changes\n * @param chart\n * @param data\n * @returns {Array[]}\n */\n\n\nfunction split(chart, meta, data) {\n  var i, oldSign;\n  var deltaX;\n  var st = [];\n  var sets = [];\n  var domain = chart.meta.yScale.domain();\n  var zoomScale = chart.meta.zoomBehavior.scale();\n  var yMin = domain[0];\n  var yMax = domain[1];\n\n  if (data[0]) {\n    st.push(data[0]);\n    deltaX = data[1][0] - data[0][0];\n    oldSign = utils.sgn(data[1][1] - data[0][1]);\n  }\n\n  function updateY(d) {\n    d[1] = Math.min(d[1], yMax);\n    d[1] = Math.max(d[1], yMin);\n    return d;\n  }\n\n  i = 1;\n\n  while (i < data.length) {\n    var y0 = data[i - 1][1];\n    var y1 = data[i][1];\n    var deltaY = y1 - y0;\n    var newSign = utils.sgn(deltaY); // make a new set if:\n\n    if ( // utils.sgn(y1) * utils.sgn(y0) < 0 && // there's a change in the evaluated values sign\n    // there's a change in the slope sign\n    oldSign !== newSign && // the slope is bigger to some value (according to the current zoom scale)\n    Math.abs(deltaY / deltaX) > 1 / zoomScale) {\n      // retest this section again and determine if it's an asymptote\n      var check = checkAsymptote(data[i - 1], data[i], meta, newSign, 3);\n\n      if (check.asymptote) {\n        st.push(updateY(check.d0));\n        sets.push(st);\n        st = [updateY(check.d1)];\n      }\n    }\n\n    oldSign = newSign;\n    st.push(data[i]);\n    ++i;\n  }\n\n  if (st.length) {\n    sets.push(st);\n  }\n\n  return sets;\n}\n\nfunction linear(chart, meta, range, n) {\n  var allX = utils.space(chart, range, n);\n  var yDomain = chart.meta.yScale.domain();\n  var yDomainMargin = yDomain[1] - yDomain[0];\n  var yMin = yDomain[0] - yDomainMargin * 1e5;\n  var yMax = yDomain[1] + yDomainMargin * 1e5;\n  var data = [];\n  var i;\n\n  for (i = 0; i < allX.length; i += 1) {\n    var x = allX[i];\n    var y = evaluate(meta, 'fn', {\n      x: x\n    });\n\n    if (utils.isValidNumber(x) && utils.isValidNumber(y)) {\n      data.push([x, clamp(y, yMin, yMax)]);\n    }\n  }\n\n  data = split(chart, meta, data);\n  return data;\n}\n\nfunction parametric(chart, meta, range, nSamples) {\n  // range is mapped to canvas coordinates from the input\n  // for parametric plots the range will tell the start/end points of the `t` param\n  var parametricRange = meta.range || [0, 2 * Math.PI];\n  var tCoords = utils.space(chart, parametricRange, nSamples);\n  var samples = [];\n\n  for (var i = 0; i < tCoords.length; i += 1) {\n    var t = tCoords[i];\n    var x = evaluate(meta, 'x', {\n      t: t\n    });\n    var y = evaluate(meta, 'y', {\n      t: t\n    });\n    samples.push([x, y]);\n  }\n\n  return [samples];\n}\n\nfunction polar(chart, meta, range, nSamples) {\n  // range is mapped to canvas coordinates from the input\n  // for polar plots the range will tell the start/end points of the `theta` param\n  var polarRange = meta.range || [-Math.PI, Math.PI];\n  var thetaSamples = utils.space(chart, polarRange, nSamples);\n  var samples = [];\n\n  for (var i = 0; i < thetaSamples.length; i += 1) {\n    var theta = thetaSamples[i];\n    var r = evaluate(meta, 'r', {\n      theta: theta\n    });\n    var x = r * Math.cos(theta);\n    var y = r * Math.sin(theta);\n    samples.push([x, y]);\n  }\n\n  return [samples];\n}\n\nfunction points(chart, meta, range, nSamples) {\n  return [meta.points];\n}\n\nfunction vector(chart, meta, range, nSamples) {\n  meta.offset = meta.offset || [0, 0];\n  return [[meta.offset, [meta.vector[0] + meta.offset[0], meta.vector[1] + meta.offset[1]]]];\n}\n\nvar sampler = function (chart, d, range, nSamples) {\n  var fnTypes = {\n    parametric: parametric,\n    polar: polar,\n    points: points,\n    vector: vector,\n    linear: linear\n  };\n\n  if (!(d.fnType in fnTypes)) {\n    throw Error(d.fnType + ' is not supported in the `builtIn` sampler');\n  }\n\n  return fnTypes[d.fnType].apply(null, arguments);\n};\n\nmodule.exports = sampler;","map":null,"metadata":{},"sourceType":"script"}